<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++11新特性 | Fengzi7的奇妙空间</title><meta name="author" content="封子期"><meta name="copyright" content="封子期"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++11新特性&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则auto name&#x3D;value;  &#x3D;&#x3D;auto&#x3D;&#x3D;是一个占位符，在编译器期间会被真正的类型替代，且必须初始化，不能只是声明，必须赋值，因为&#x3D;&#x3D;auto&#x3D;&#x3D;会根据&#x3D;右边的值判断&#x3D;&#x3D;auto&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11新特性">
<meta property="og:url" content="https://fengzi7.magicalroom.com/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Fengzi7的奇妙空间">
<meta property="og:description" content="C++11新特性&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则auto name&#x3D;value;  &#x3D;&#x3D;auto&#x3D;&#x3D;是一个占位符，在编译器期间会被真正的类型替代，且必须初始化，不能只是声明，必须赋值，因为&#x3D;&#x3D;auto&#x3D;&#x3D;会根据&#x3D;右边的值判断&#x3D;&#x3D;auto&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg">
<meta property="article:published_time" content="2024-03-18T06:45:08.161Z">
<meta property="article:modified_time" content="2024-03-19T06:59:35.073Z">
<meta property="article:author" content="封子期">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fengzi7.magicalroom.com/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++11新特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-19 14:59:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/boqi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Fengzi7的奇妙空间"><span class="site-name">Fengzi7的奇妙空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++11新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-18T06:45:08.161Z" title="发表于 2024-03-18 14:45:08">2024-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T06:59:35.073Z" title="更新于 2024-03-19 14:59:35">2024-03-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++11新特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="auto-类型推导语法和规则"><a href="#auto-类型推导语法和规则" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name=value;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;auto&#x3D;&#x3D;是一个占位符，在编译器期间会被真正的类型替代，且必须初始化，不能只是声明，必须赋值，因为&#x3D;&#x3D;auto&#x3D;&#x3D;会根据&#x3D;右边的值判断&#x3D;&#x3D;auto&#x3D;&#x3D;到底是什么类型。</p>
<h3 id="auto-高级用法"><a href="#auto-高级用法" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;高级用法"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;高级用法</h3><p>除了可以独立使用，还可以和某些具体类型混合使用，这样&#x3D;&#x3D;auto&#x3D;&#x3D;就是‘半个’类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">//p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">//p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">//r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">//r2 为  int，auto 推导为 int</span></span><br><span class="line"><span class="comment">/*第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</span></span><br><span class="line"><span class="comment">第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</span></span><br><span class="line"><span class="comment">第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</span></span><br><span class="line"><span class="comment">第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;auto&#x3D;&#x3D;还可以和&#x3D;&#x3D;const&#x3D;&#x3D;结合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span>  <span class="keyword">auto</span> n = x;  <span class="comment">//n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;      <span class="comment">//f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第 2 行代码中，n 为 const int，auto 被推导为 int。</span></span><br><span class="line"><span class="comment">第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</span></span><br><span class="line"><span class="comment">第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</span></span><br><span class="line"><span class="comment">第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>·当类型不为引用时，&#x3D;&#x3D;auto&#x3D;&#x3D;的推到结果将不保留表达式的const属性</p>
<p>·当类型为引用时，&#x3D;&#x3D;auto&#x3D;&#x3D;的推到结果将保留表达式的const属性。</p>
<h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;的限制"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;的限制</h3><p>1）&#x3D;&#x3D;auto&#x3D;&#x3D;不能再函数的参数里使用</p>
<p>2）&#x3D;&#x3D;auto&#x3D;&#x3D;不能作用于类的非静态成员变量（没有关键字static）</p>
<p>3）&#x3D;&#x3D;auto&#x3D;&#x3D;关键字不能定义数组</p>
<p>4）&#x3D;&#x3D;auto&#x3D;&#x3D;不能作用于模板参数</p>
<hr>
<h2 id="decltype-类型推导完全攻略"><a href="#decltype-类型推导完全攻略" class="headerlink" title="&#x3D;&#x3D;decltype&#x3D;&#x3D;类型推导完全攻略"></a>&#x3D;&#x3D;decltype&#x3D;&#x3D;类型推导完全攻略</h2><p>&#x3D;&#x3D;decltype&#x3D;&#x3D; C++11的新关键字，和&#x3D;&#x3D;auto&#x3D;&#x3D;的功能一样，都是自动推导除变量的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname=value;</span><br></pre></td></tr></table></figure>

<p>auto必须初始化，但是&#x3D;&#x3D;decltype&#x3D;&#x3D;不需要初始化可以直接声明,exp是一个表达式，auto是根据&#x3D;右边的值推导关键字，decltype与&#x3D;右值无关，只和exp有关。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure>

<h3 id="exp注意事项"><a href="#exp注意事项" class="headerlink" title="exp注意事项"></a>exp注意事项</h3><p>原则上讲，exp可以是一个普通的表达式，可以是任意复杂的形式，但是不能是void，尤其是exp调用的一个函数的返回值类型是void，exp结果也是void</p>
<p>&#x3D;&#x3D;decltype&#x3D;&#x3D;推导规则</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">·如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</span><br><span class="line">·如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</span><br><span class="line">·如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</span><br></pre></td></tr></table></figure>



<h4 id="exp是一个普通表达式（不被”（）“包围的表达式）"><a href="#exp是一个普通表达式（不被”（）“包围的表达式）" class="headerlink" title="exp是一个普通表达式（不被”（）“包围的表达式）"></a>exp是一个普通表达式（不被”（）“包围的表达式）</h4><p>exp是什么&#x3D;&#x3D;decltype&#x3D;&#x3D;就是什么</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exp位函数调用（返回值是什么exp就是什么，-不能是void类型-）"><a href="#exp位函数调用（返回值是什么exp就是什么，-不能是void类型-）" class="headerlink" title="exp位函数调用（返回值是什么exp就是什么，&#x3D;&#x3D;不能是void类型&#x3D;&#x3D;）"></a>exp位函数调用（返回值是什么exp就是什么，&#x3D;&#x3D;不能是void类型&#x3D;&#x3D;）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">(<span class="type">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<h4 id="exp是左值或者被”（）“包围"><a href="#exp是左值或者被”（）“包围" class="headerlink" title="exp是左值或者被”（）“包围"></a>exp是左值或者被”（）“包围</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="&#x3D;&#x3D;decltype&#x3D;&#x3D;的实际应用"></a>&#x3D;&#x3D;decltype&#x3D;&#x3D;的实际应用</h4><p>auto比decltype简单，但是限制多，</p>
<p>auto只能用于类的静态成员，不能用于费劲太成员，但是decltype没有这个限制。代码会更加简便一些。</p>
<p>&#x3D;&#x3D;原格式&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98&#x2F;03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;低版本编译器不支持T().begin()写法&#x3D;&#x3D;</p>
<hr>
<h2 id="返回值类型后置"><a href="#返回值类型后置" class="headerlink" title="返回值类型后置"></a>返回值类型后置</h2><p>写法1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>() + <span class="built_in">U</span>()) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T,U可能是无参构造函数的类，则需要修改为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用返回值后置写法，需要将auto和decltype混合使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>&amp; f)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="auto-和-decltype的区别"><a href="#auto-和-decltype的区别" class="headerlink" title="auto 和 decltype的区别"></a>auto 和 decltype的区别</h2><p>1.auto是通过编译器计算变量的初始值来推断类型的，decltype同样也是通过编译器来分析表达式进而得到它的类型，但是它不用将表达式的值计算出来。</p>
<p>2.编译器推断出来的auto类型有可能和初始值类型不同，比如对于顶层const，auto会忽略顶层const性质，但是decltype是保留下来的，这在下面的代码中会有所体现。</p>
<p>3.与auto不一样，decltype的结果类型与表达式形式有密切关系。比如decltype（）内层没有括号，那么得到的类型就是变量的类型，如果有多层括号decltype（（））那么返回的就是引用，具体可以通过代码分析。</p>
<figure class="highlight plaintext"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">#include &quot;Sales_item.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i = 4,&amp;p =i;</span><br><span class="line">	auto a = i;//相当于int a=i；</span><br><span class="line">	decltype (i) b = i;//编译器推断i是一个int，相当于int b=i；</span><br><span class="line">	decltype ((i)) c = i;//只要出现了表达式那么decltype就推断出是引用</span><br><span class="line">						 //相当于int &amp;c = i；</span><br><span class="line">	decltype(p) q = i;//即int &amp;q = i；</span><br><span class="line">	decltype(p + 0) r = i;//表达式的结果是int型 即int r =i；</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt;&quot; &quot;&lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">	c++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	q++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	const int m = 10;</span><br><span class="line">	auto d = m;//由于auto会失去顶层const的性质，即int d=m；</span><br><span class="line">	d++;//合法，d是整数</span><br><span class="line">	decltype (m) e = 11;//相反decltype 会保留const性质，即const int e=11；</span><br><span class="line">	e++;//该句非法操作 e是常量</span><br><span class="line">	decltype((m))f = d;//即const int &amp;f=d；</span><br><span class="line">	int g = 12;</span><br><span class="line">	f = g;//该句非法操作，是因为f是常量引用</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="using定义别名"><a href="#using定义别名" class="headerlink" title="using定义别名"></a>using定义别名</h2><p>一般定义别名的使用typedef(重定义一个类型)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">unit_t</span></span><br></pre></td></tr></table></figure>

<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型去了一个新的名字。因此下面的用法不合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unit_t</span>)</span><span class="comment">//不合法</span></span></span><br></pre></td></tr></table></figure>

<p>同时也无法重定义一个模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, std::string&gt; <span class="type">map_str_t</span>;</span><br></pre></td></tr></table></figure>

<p>需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<hr>
<p>C++11出现一个新的语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>

<p>using别名覆盖了typedef的全部功能对普通类型的重定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<p>typedef void (*func_t)(int, int);</p>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<p>using func_t &#x3D; void (*)(int, int);</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>



<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span> (*func_call)(<span class="type">int</span>, <span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">func_t</span>&lt;<span class="type">int</span>&gt; func_call)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h2><p>在C++98&#x2F;03，类模板可以有默认的模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U=<span class="type">int</span> ,U N=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>不支持函数的默认模板参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T</span>=<span class="type">int</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在C++11中可以使用了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val&#x3D;97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U &#x3D; int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</char></p>
<p>&#x3D;&#x3D;再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    <span class="built_in">func</span>();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h2><h3 id="tuple对象的创建"><a href="#tuple对象的创建" class="headerlink" title="tuple对象的创建"></a>tuple对象的创建</h3><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure>

<p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p>
<h4 id="1-类的构造函数"><a href="#1-类的构造函数" class="headerlink" title="1) 类的构造函数"></a>1) 类的构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-make-tuple-函数"><a href="#2-make-tuple-函数" class="headerlink" title="2) make_tuple()函数"></a>2) make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p>
<p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">make_tuple</span> (<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = std::<span class="built_in">make_tuple</span> (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure>

<p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p>
<h3 id="tuple常用函数"><a href="#tuple常用函数" class="headerlink" title="tuple常用函数"></a>tuple常用函数</h3><p>为了方便您在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如表 1 所示。</tuple></p>
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>tup1.swap(tup2) swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td>
</tr>
<tr>
<td>get<num>(tup)</num></td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td>
</tr>
<tr>
<td>tuple_size<type>::value</type></td>
<td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td>
</tr>
<tr>
<td>tuple_element&lt;I, type&gt;::type</td>
<td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td>
</tr>
<tr>
<td>forward_as_tuple&lt;args…&gt;</td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) &#x3D; tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 x</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="C-11列表初始化（统一了初始化方式）"><a href="#C-11列表初始化（统一了初始化方式）" class="headerlink" title="C++11列表初始化（统一了初始化方式）"></a>C++11列表初始化（统一了初始化方式）</h2><p>C++98&#x2F;03的对象初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p>
<p>为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</span><br></pre></td></tr></table></figure>

<h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。&#x3D;&#x3D;</p>
<p>在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，请看下面的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。</p>
<p>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p>
<p>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。</p>
<p>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure>

<p>在初始化时，<code>&#123;&#125;</code>前面的等于号是否书写对初始化行为没有影响。</p>
<p>另外，如同读者所想的那样，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。</p>
<p>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p>
<p>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p>
<p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h2><p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中各部分的含义分别为：</p>
<ol>
<li>[外部变量方位方式说明符]<br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
</li>
</ol>
<p>&#x3D;&#x3D;注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；&#x3D;&#x3D;</p>
<ol start="4">
<li>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</li>
</ol>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<ol start="5">
<li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
</li>
<li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</span><br></pre></td></tr></table></figure>

<p>下面定义一个最简单的lambda匿名函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h4><p>对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</span><br></pre></td></tr></table></figure>

<h4 id="lambda-匿名函数的定义和使用。"><a href="#lambda-匿名函数的定义和使用。" class="headerlink" title="lambda 匿名函数的定义和使用。"></a>lambda 匿名函数的定义和使用。</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<h4 id="值传递和引用传递的区别"><a href="#值传递和引用传递的区别" class="headerlink" title="值传递和引用传递的区别"></a>值传递和引用传递的区别</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p>
<p>其中，lambda1 匿名函数是以&#x3D;&#x3D;[&#x3D;]&#x3D;&#x3D; 值传递的方式导入的局部变量，这意味着默认情况下，&#x3D;&#x3D;此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外-&#x3D;&#x3D;。相对地，lambda2 匿名函数以 &#x3D;&#x3D;[&amp;]&#x3D;&#x3D; 引用传递的方式导入这 3 个局部变量，&#x3D;&#x3D;因此在该函数的内部不就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。&#x3D;&#x3D;</p>
<p>如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，&#x3D;&#x3D;真正外部变量的值并不会发生改变。&#x3D;&#x3D;</p>
<h4 id="执行抛出异常类型"><a href="#执行抛出异常类型" class="headerlink" title="执行抛出异常类型"></a>执行抛出异常类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，在看一下反例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="built_in">throw</span>(<span class="type">char</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">except1</span>();</span><br><span class="line">        <span class="built_in">except2</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<p>&#x3D;&#x3D;如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。&#x3D;&#x3D;</p>
<hr>
<h1 id="C-11非受限联合体（union）"><a href="#C-11非受限联合体（union）" class="headerlink" title="C++11非受限联合体（union）"></a>C++11非受限联合体（union）</h1><p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h4><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</p>
<p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。</p>
<p>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ol>
<li><p>没有&#x3D;&#x3D;用户自定义&#x3D;&#x3D;的&#x3D;&#x3D;构造函数、析构函数、拷贝构造函数和移动构造函数&#x3D;&#x3D;。</p>
</li>
<li><p>不能包含&#x3D;&#x3D;虚函数和虚基类&#x3D;&#x3D;。</p>
</li>
<li><p>非静态成员必须声明为 &#x3D;&#x3D;public&#x3D;&#x3D;。</p>
</li>
<li><p>类中的第一个非静态成员的类型与其基类(父类)不同，例如：</p>
</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">class B1&#123;&#125;;</span><br><span class="line">class B2 : B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure>

<p>class B2 的第一个非静态成员 b 是&#x3D;&#x3D;基类&#x3D;&#x3D;类型，所以它不是 POD 类型。</p>
<ol start="5">
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
</ol>
<ul>
<li>&#x3D;&#x3D;派生类&#x3D;&#x3D;中&#x3D;&#x3D;有非静态成员&#x3D;&#x3D;，且只有一个&#x3D;&#x3D;仅包含静态成员&#x3D;&#x3D;的&#x3D;&#x3D;基类&#x3D;&#x3D;；</li>
<li>基类有非静态成员，而派生类&#x3D;&#x3D;没有非静态成员&#x3D;&#x3D;。</li>
</ul>
<p>总结：父类和子类的非静态成员是冲突的，一个有非静态成员另一个就不能有。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123; <span class="type">static</span> <span class="type">int</span> n; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : B1 &#123; <span class="type">int</span> n1; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : B2 &#123; <span class="type">static</span> <span class="type">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure>

<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<ol start="6">
<li><p>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p>
</li>
<li><p>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p>
</li>
</ol>
<h4 id="2C-11-允许联合体有静态成员"><a href="#2C-11-允许联合体有静态成员" class="headerlink" title="2C++11 允许联合体有静态成员"></a>2C++11 允许联合体有静态成员</h4><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。&#x3D;&#x3D;</p>
<h2 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<hr>
<p>解决上面问题的一般需要用到 placement new</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h4 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h4><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</p>
<p>placement new 的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(...)</span><br></pre></td></tr></table></figure>

<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="type">int</span> x; &#125;;  <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="constexpr验证常量表达式"><a href="#constexpr验证常量表达式" class="headerlink" title="constexpr验证常量表达式"></a>constexpr验证常量表达式</h1><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure>

<p>代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p>
<p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>&#x3D;&#x3D;constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。&#x3D;&#x3D;</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</span><br></pre></td></tr></table></figure>

<h2 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p>
<h2 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constexpr int display(int x) &#123;</span><br><span class="line">    int ret = 1 + 2 + x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。&#x3D;&#x3D;</p>
<ol start="2">
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<ol start="3">
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在&#x3D;&#x3D;使用前，必须要有该函数的定义。&#x3D;&#x3D;</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;<span class="comment">//使用前</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>return 返回的表达式必须是常量表达式，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;<span class="comment">//num影响结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<p>&#x3D;&#x3D;注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x&#x3D;1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。&#x3D;&#x3D;</p>
<hr>
<hr>
<h2 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<p>&#x3D;&#x3D;注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。&#x3D;&#x3D;</p>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="long-long-超长整形详解"><a href="#long-long-超长整形详解" class="headerlink" title="long long 超长整形详解"></a>long long 超长整形详解</h1><table>
<thead>
<tr>
<th>整数类型</th>
<th>等价类型</th>
<th>C++11标准规定占用最少位数</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>unsigned short int（无符号短整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned</td>
<td>unsigned int（无符号整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long</td>
<td>unsigned long int（无符号长整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long long（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned long long int（C++11）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。注意，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</span><br></pre></td></tr></table></figure>

<h1 id="C-11右值引用（一看即懂）"><a href="#C-11右值引用（一看即懂）" class="headerlink" title="C++11右值引用（一看即懂）"></a>C++11右值引用（一看即懂）</h1><h2 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h2><ol>
<li>&#x3D;&#x3D;可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。&#x3D;&#x3D;举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br></pre></td></tr></table></figure>

<p>变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>&#x3D;&#x3D;有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。&#x3D;&#x3D;</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p>
<h2 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h2><p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98&#x2F;03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<p>&#x3D;&#x3D;需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>和常量左值引用不同的是，右值引用还可以对右值进行修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure>





<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的值类型</th>
<th>使用场景</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<h1 id="移动构造函数及std-move-的使用"><a href="#移动构造函数及std-move-的使用" class="headerlink" title="移动构造函数及std::move() 的使用"></a>移动构造函数及std::move() 的使用</h1><h2 id="复制构造和移动构造"><a href="#复制构造和移动构造" class="headerlink" title="复制构造和移动构造"></a>复制构造和移动构造</h2><img src="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images/image-20240313115645107.png" style="zoom:150%;">

<img src="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images/image-20240313115707702.png" style="zoom:150%;">

<p>复制构造和移动构造的差别：<br>这种情况下，我们觉得这个临时对象完成了复制构造后，就不需要它了，我们就没有必要去首先产生一个副本，然后析构这个临时对象，这样费两遍事，又占用内存空间，干脆将临时对象原本的堆内存直接转给构造的对象就行了。 当临时对象在被复制后，就不再被利用了。我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制构造。</p>
<p>什么时候该触发移动构造呢？<br>如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>std::move函数可以以非常简单的方式<strong>将左值转换为右值引用</strong>。<br>通过std::move，可以避免不必要的拷贝操作。<br>std::move是为性能而生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//这里假设我们只需要将str的内容放到vector中，完成以后永远都不需要再用到str</span></span><br><span class="line">	vector&lt;string&gt; v;</span><br><span class="line">	<span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(str);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After copy, str is :&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//先把str转为右值引用，然后调用移动构造函数转交所有权</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="built_in">move</span>(str));</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After move, str is:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The contents of the vector are:&#123;&quot;</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">		&lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;&#125;&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=string%E7%B1%BB&spm=1001.2101.3001.7020">string类</a>的数据成员简单的来说其实最关键的就是一个<code>char*</code>(至于其他的东西不重要)，指向动态内存分配空间的首地址。</p>
<p><img src="/../typora-user-images/image-20240313121538178.png" alt="image-20240313121538178"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">	s1 = <span class="built_in">move</span>(s2); </span><br><span class="line">	<span class="comment">// s1==&quot;banana&quot;</span></span><br><span class="line">	cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">	v1 = <span class="built_in">move</span>(v2);  <span class="comment">//从v2转移到v1</span></span><br><span class="line">	<span class="comment">//v1==&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>s1 = move(s2);</code>move函数先把s2转为右值引用，然后就可以执行string类的移动构造函数和移动赋值运算符函数。</p>
<h3 id="继续深入分析C-11的右值引用："><a href="#继续深入分析C-11的右值引用：" class="headerlink" title="继续深入分析C++11的右值引用："></a>继续深入分析C++11的右值引用：</h3><p>1.什么是左值，什么是右值，<strong>简单说左值可以赋值，右值不可以赋值</strong>。以下面代码为例，“ A a &#x3D; getA();”该语句中a是左值，getA()的返回值是右值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a = <span class="built_in">getA</span>();<span class="comment">// getA()是一个右值</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../typora-user-images/image-20240313121854166.png" alt="image-20240313121854166"></p>
<p>可以看到A的构造函数调用一次，拷贝构造函数调用了一次，构造函数和拷贝构造函数是消耗比较大的，这里是否可以避免拷贝构造？C++11做到了这一点。（注意，上面这个例子中，虽然getA()是一个右值，但是由于没有自定义move constructor，所以调用了默认的copy constructor。如果对象中有堆内存管理，必须定义move constructor。<br>2.自定义A的移动构造函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a = <span class="built_in">getA</span>();<span class="comment">// getA()是一个右值</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/Fengzi../Typora/typora-user-images/image-20240313141133632.png" alt="image-20240313141133632"></p>
<p>3.修改代码，给A类添加一个成员变量如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> B&amp;) &#123; cout &lt;&lt; <span class="string">&quot;B Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>()) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; src) :<span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb)))<span class="comment">//深拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; src) :<span class="built_in">pb</span>(src.pb)</span><br><span class="line">	&#123;</span><br><span class="line">		src.pb = <span class="literal">nullptr</span>;<span class="comment">//这里是关键，这样以后，当src.pb被delete时，由于其为空指针，并不会释放原来的堆内存</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A Move Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> pb; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	B* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a = <span class="built_in">getA</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../typora-user-images/image-20240313141646721.png" alt="image-20240313141646721"></p>
<p>4.std::move语句可以将左值变为右值而避免拷贝构造，修改代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">const</span> B&amp;) &#123; cout &lt;&lt; <span class="string">&quot;B Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>()) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; src) :<span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb)))<span class="comment">//深拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; src) :<span class="built_in">pb</span>(src.pb)</span><br><span class="line">	&#123;</span><br><span class="line">		src.pb = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A Move Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; src) <span class="keyword">noexcept</span><span class="comment">//深拷贝</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> pb;</span><br><span class="line">		pb = <span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb));</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=(const A&amp; src)&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(A&amp;&amp; src) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> pb;</span><br><span class="line">		pb = src.pb;</span><br><span class="line">		src.pb = <span class="literal">nullptr</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=(const A&amp;&amp; src)&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> pb; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	B* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a = <span class="built_in">getA</span>();<span class="comment">//移动构造</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">A <span class="title">a2</span><span class="params">(move(a))</span></span>;<span class="comment">//移动构造</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	a2 = <span class="built_in">getA</span>();<span class="comment">//移动赋值（因为getA()是右值）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">	a2 = a1;<span class="comment">//拷贝赋值（因为a1是左值）</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../typora-user-images/image-20240313141943171.png" alt="image-20240313141943171"></p>
<h3 id="使用move函数转交unique-ptr的所有权"><a href="#使用move函数转交unique-ptr的所有权" class="headerlink" title="使用move函数转交unique_ptr的所有权"></a>使用move函数转交unique_ptr的所有权</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span>*p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">56</span>);</span><br><span class="line">	<span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up_int1</span><span class="params">(p1)</span></span>;</span><br><span class="line">	unique_ptr&lt;<span class="type">int</span>&gt; up_int2= <span class="built_in">move</span>(up_int1);<span class="comment">//转交所有权（法1）</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;int&gt; p2(p1.release()); //转交所有权（法2）</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	string* p2 = <span class="keyword">new</span> string[<span class="number">2</span>];<span class="comment">//对象数组</span></span><br><span class="line">	p2[<span class="number">0</span>] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">	p2[<span class="number">1</span>] = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;string[]&gt; <span class="title">up_str1</span><span class="params">(p2)</span></span>;</span><br><span class="line">	unique_ptr&lt;string[]&gt; up_str2;</span><br><span class="line">	up_str2 = <span class="built_in">move</span>(up_str1);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="引用限定符的用法"><a href="#引用限定符的用法" class="headerlink" title="引用限定符的用法"></a>引用限定符的用法</h1><p>本节中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。</p>
<p>同理，我们再次修改程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p>
<p>&#x3D;&#x3D;注意，引用限定符不适用于静态成员函数和友元函数。&#x3D;&#x3D;</p>
<h2 id="const和引用限定符"><a href="#const和引用限定符" class="headerlink" title="const和引用限定符"></a>const和引用限定符</h2><p>const 也可以用于修饰类的成员函数，我们习惯称为常成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 get_num() 就是一个常成员函数。</p>
<p>const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>需要注意的一点是，当 &#x3D;&#x3D;const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象&#x3D;&#x3D;；当&#x3D;&#x3D;const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。&#x3D;&#x3D;无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，&#x3D;&#x3D;内部都不允许对当前对象做修改操作。&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num,<span class="type">int</span> num2) :<span class="built_in">num</span>(num),<span class="built_in">num2</span>(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;        <span class="comment">// 正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11完美转发及实现方法"><a href="#C-11完美转发及实现方法" class="headerlink" title="C++11完美转发及实现方法"></a>C++11完美转发及实现方法</h1><h2 id="什么是完美转发？"><a href="#什么是完美转发？" class="headerlink" title="什么是完美转发？"></a><strong>什么是完美转发</strong>？</h2><p>它指的是<strong>函数模板</strong>可以将自己的参数“<strong>完美</strong>”地转发给<strong>内部调用的其它函数</strong>。</p>
<ul>
<li>完美，表示能保证被转发参数的左、右值属性不变。</li>
</ul>
<p><strong>“不完美“函数举例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span> <span class="comment">// 非引用，形参会对实参进行拷贝。</span></span></span><br><span class="line"><span class="function"></span>&#123;                  <span class="comment">// 对于函数内部来说，t有自己的名称，也可以获取它的存储地址，因此它永远都是左值。</span></span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>传递给 otherdef() 函数的参数 t 永远都是左值。</li>
</ul>
<p><strong>C++11实现完美转发：</strong></p>
<p>问题1：怎么解决函数模板参数的左、右值接收问题？</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。<br>但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为<strong>“万能引用”</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T &amp;&amp;t)</span> <span class="comment">//既可以接受左值，又可以接受右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);   <span class="comment">// t继续传参，在otherdef()中又变成了左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>记住：在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</li>
</ul>
<p>问题2：如何将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数？</p>
<ul>
<li><p>C++11引入了一个模板函数 forword() 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);   <span class="comment">// rvalue</span></span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);   <span class="comment">// lvalue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h1 id="nullptr：初始化空指针"><a href="#nullptr：初始化空指针" class="headerlink" title="nullptr：初始化空指针"></a>nullptr：初始化空指针</h1><p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p>
<p>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p>
<p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);<span class="comment">// int  n</span></span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);<span class="comment">//int  n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。</p>
<p>如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 &#x3D;&#x3D;nullptr&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;<strong>在使用 nullptr 之前，读者需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，读者需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std&#x3D;c++0x 编译选项）。</strong>&#x3D;&#x3D;</p>
<p>**&#x3D;&#x3D;(nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。)&#x3D;&#x3D;**nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。</p>
<hr>
<h1 id="shared-ptr智能指针"><a href="#shared-ptr智能指针" class="headerlink" title="shared_ptr智能指针"></a>shared_ptr智能指针</h1><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>C++98&#x2F;03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p>
<p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<h2 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr<T>（其中 T 表示指针指向的具体数据类型）的定义位于&#x3D;&#x3D;<code>&lt;memory&gt;</code>&#x3D;&#x3D;头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</strong>&#x3D;&#x3D;</p>
<h3 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h3><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数</T></p>
<ol>
<li><p>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。&#x3D;&#x3D;</p>
</li>
<li><p>在构建 shared_ptr 智能指针，也可以明确其指向。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>​	C++11 标准中还提供了 std::make_shared<T> 模板函数，其可以用于初始化 shared_ptr 智能指针</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>除此之外，shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数</T></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure>

<p>p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 &#x3D;&#x3D;p3 为空智能指针，则 p4 也为空智能指针&#x3D;&#x3D;，其引用计数初始值为 0；反之，&#x3D;&#x3D;则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1&#x3D;&#x3D;。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，&#x3D;&#x3D;用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针&#x3D;&#x3D;。</p>
<p>注意，&#x3D;&#x3D;同一普通指针不能同时为多个 shared_ptr 对象赋值&#x3D;&#x3D;，否则会导致程序发生异常</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr<T>模板类提供的成员方法</T></h3><p>为了方便用户使用 shared_ptr 智能指针，shared_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator&#x3D;()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">10</span><br><span class="line">p1 为空</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="C-智能指针之unique-ptr"><a href="#C-智能指针之unique-ptr" class="headerlink" title="C++智能指针之unique_ptr"></a>C++智能指针之unique_ptr</h1><h2 id="一、unique-ptr"><a href="#一、unique-ptr" class="headerlink" title="一、unique_ptr"></a>一、unique_ptr</h2><p>一个 unique_ptr“拥有”它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr 被销毁时，它所指向的对象也被销毁。</p>
<p> <strong>unique_ptr的操作</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ef47727c15734247a9aed330233e0e02.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/de8258bb34394577878e613f3b5b74e3.png" alt="img"></p>
<h3 id="1-1-unique-ptr类的初始化"><a href="#1-1-unique-ptr类的初始化" class="headerlink" title="1.1 unique_ptr类的初始化"></a>1.1 unique_ptr类的初始化</h3><p>  unique_ptr没有类似shared_ptr中make_shared的标准库函数返回一个unique_ptr，我们定义一个unique_ptr时，需要将它绑定到一个new返回的指针上，并且不能直接将new的结果用赋值运算符“&#x3D;”赋值给unique_ptr（即初始化方式必须采用直接初始化方式）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; p1;<span class="comment">//正确</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;<span class="comment">//正确</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-unique-ptr禁止拷贝和赋值"><a href="#1-2-unique-ptr禁止拷贝和赋值" class="headerlink" title="1.2 unique_ptr禁止拷贝和赋值"></a>1.2 unique_ptr禁止拷贝和赋值</h3><p>  因为unique_ptr所指向的对象只能有一个unique_ptr指针，也就是一个引用计数。因此unique_ptr不支持普通的拷贝和赋值操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;HelloWorld&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//是错误</span></span><br><span class="line">unique_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p1;<span class="comment">//错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>特殊情况：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">虽然两个unique_ptr不可以同时指向同一个内存对象，但是可以将一个即将销毁的unqie_ptr指针拷贝或赋值给另一个unqie_ptr</span><br></pre></td></tr></table></figure>

<p> 函数的参数传递和返回值就是一个很好的例子，因为在函数内部的unique_ptr指针随着作用域的结束会自动销毁，因此可以将其作为返回值，然后将内存传递给另一个unique_ptr指针管理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*unique_ptr&lt;int&gt; clone(int p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    unique_ptr&lt;int&gt; ret(new int(p));</span></span><br><span class="line"><span class="comment">    return ret;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; p = <span class="built_in">clone</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt;*p &lt;&lt; endl; <span class="comment">//打印10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-release、reset函数"><a href="#1-3-release、reset函数" class="headerlink" title="1.3 release、reset函数"></a>1.3 release、reset函数</h3><p>虽然unique_ptr之间不能拷贝与赋值。但是可以使用release和reset函数来将指针的所有权从一个（非const）unique_ptr转移给另一个unique。</p>
<p><strong>release函数</strong></p>
<ul>
<li>将当前的unique_ptr指针所指的内存置为空，并且对这块内存的所有权消失</li>
<li>返回值：返回当前unique_ptr所指的内存</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;<span class="comment">//p1将自己所指的内存空间置空，并且返回该内存空间。之后对该内存空间的操作权消失，从而p2得到该内存的权限</span></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">release</span>();<span class="comment">//错误，虽然p1断开了与内存的关系，但是没有另一个unqieu_ptr来接手这块内存，造成内存泄漏</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改正：</span></span><br><span class="line"><span class="comment">unique_ptr&lt;string&gt; p2(p1.release()); //将p1的原来内存交给另一个unique_ptr管理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<p>  因为release函数会使unque_ptr指针与内存之间的关系。所以unique_ptr调用release函数之后必须将返回值传递给另一个unqiue_ptr，否则就会内存泄露</p>
<hr>
<p><strong>reset函数</strong></p>
<ul>
<li>用来重置当前unqie_ptr指针。</li>
<li>重置之后接手另一块内存或者一直处于空状态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>();<span class="comment">//将p1置空，不指向内存对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);<span class="comment">//同上</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;World&quot;</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line">p1.<span class="built_in">reset</span>(p2.<span class="built_in">release</span>());<span class="comment">//p2置空之后，然后p1也置空，然后p1来接手p2所指向的内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-向unique-ptr传递删除器"><a href="#1-4-向unique-ptr传递删除器" class="headerlink" title="1.4 向unique_ptr传递删除器"></a>1.4 向unique_ptr传递删除器</h3><p>与shared_ptr类相同，unique_ptr默认情况下会调用默认析构函数来释放(delete)自己所指向的对象。不过我们也可以通过重载来指定unqie_ptr的删除器。</p>
<p>  与shared_ptr重载删除器不同，unique_ptr重载删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。</p>
<p>  与重载关联容器的比较操作类似，我们必须在&lt;&gt;中unique_ptr指向类型之后提供删除器类型。</p>
<p>  在创建或reset一个这种unique_ptr类型对象时，必须提供一个指定类型的可调用对象（删除器）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用decltype来指明函数类型，在后面加一个*代表函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span> </span>&#123;</span><br><span class="line">    connection c=<span class="built_in">connec</span>(&amp;d);</span><br><span class="line">    <span class="function">unique_ptr&lt;connection,<span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c,end_connection)</span></span>;</span><br><span class="line"> </span><br><span class="line">    ...<span class="comment">//使用这个连接</span></span><br><span class="line">     <span class="comment">//当f函数退出或者异常退出，p都会调用end_connection函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-5-unique-ptr与动态数组的使用"><a href="#1-5-unique-ptr与动态数组的使用" class="headerlink" title="1.5 unique_ptr与动态数组的使用"></a>1.5 unique_ptr与动态数组的使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;)</span></span>; <span class="comment">//定义一个指向int型数组的智能指针对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;</span><br><span class="line">arr.<span class="built_in">release</span>();  <span class="comment">//自动调用delete[]销毁其指针</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>[]&gt; arr= <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;  <span class="comment">//错误</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr类操作数组的方法：</span></span><br><span class="line"><span class="comment">unique_ptr操作数组，不提供点和箭头成员运算符，因为数组不是一个对象。但是可以通过下标运算符来访问操作数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        arr[i] = i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="C-智能指针weak-ptr"><a href="#C-智能指针weak-ptr" class="headerlink" title="C++智能指针weak_ptr"></a>C++智能指针weak_ptr</h1><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>std::weak_ptr 是一种智能指针，通常不单独使用，只能和 shared_ptr 类型指针搭配使用，可以视为 shared_ptr 指针的一种辅助工具。借助 weak_ptr 类型指针可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、通过expired()判断shared_ptr 指针指向的堆内存是否已经被释放等等，还可以解决shared_ptr 循环引用的问题。</p>
<h3 id="二、内部函数"><a href="#二、内部函数" class="headerlink" title="二、内部函数"></a>二、内部函数</h3><p>std::weak_ptr的成员函数如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200730221824168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNjA4NjQx,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="三、std-weak-ptr用法"><a href="#三、std-weak-ptr用法" class="headerlink" title="三、std::weak_ptr用法"></a>三、std::<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=weak_ptr&spm=1001.2101.3001.7020">weak_ptr</a>用法</h3><p>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()&#x3D;&#x3D;0，但更快。表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        std::cout &lt;&lt; sh_ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line"> </span><br><span class="line">        <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sh_ptr)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 赋值给weak_ptr后还是输出1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!wp.<span class="built_in">expired</span>())&#123; <span class="comment">// 检查sh_ptr是否还有效</span></span><br><span class="line">            std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr2 = wp.<span class="built_in">lock</span>(); <span class="comment">//将sh_ptr赋值给sh_ptr2</span></span><br><span class="line">            *sh_ptr = <span class="number">100</span>;</span><br><span class="line">            std::cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//delete memory</span></span><br><span class="line">       </span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        wp = sh_ptr;</span><br><span class="line">        std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; std::endl;  <span class="comment">// 输出false，引用对象还没删除</span></span><br><span class="line">    &#125; <span class="comment">//delete memory</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; std::endl;  <span class="comment">// 输出true，引用对象已经删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>weak_ptr可以使用一个非常重要的成员函数<code>lock()</code>从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当<code>expired()==true</code>的时候，<code>lock()</code>函数将返回一个存储空指针的shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; pa = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wp指向对象为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sp.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; pa = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wp指向对象为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">wp指向对象为空</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="四、循环引用问题"><a href="#四、循环引用问题" class="headerlink" title="四、循环引用问题"></a>四、循环引用问题</h3><p>weak_ptr的一个作用是解决share_ptr的循环引用问题。如下面代码所示，class AA中含有指向class BB的shared指针, class BB 中含有指向class AA的shared指针，这样形成了循环引用。m_bb_ptr和m_aa_ptr的强引用计数永远大于等于1，所以直到程序退出前都不会被退出，这种情况有时候在正常的业务逻辑中是不可避免的，而解决循环引用的方法是改用weak_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::~AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;BB&gt; m_bb_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::~BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;AA&gt; m_aa_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;AA&gt; <span class="title">ptr_a</span><span class="params">(<span class="keyword">new</span> AA)</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;BB&gt; <span class="title">ptr_b</span><span class="params">(<span class="keyword">new</span> BB)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_a use_count: &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_b use_count: &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//下面两句导致了AA与BB的循环引用，结果就是AA和BB对象都不会析构</span></span><br><span class="line">	ptr_a-&gt;m_bb_ptr = ptr_b;</span><br><span class="line">	ptr_b-&gt;m_aa_ptr = ptr_a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_a use_count: &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_b use_count: &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20200730222046259.png" alt="img"></p>
<p>可以看到由于AA和BB内部的shared_ptr各自保存了对方的一次引用，所以导致了ptr_a和ptr_b销毁的时候都认为内部保存的指针计数没有变成0，所以AA和BB的析构函数不会被调用。解决方法就是把一个shared_ptr替换成weak_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::~AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;BB&gt; m_bb_ptr;  <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::~BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;AA&gt; m_aa_ptr; <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200730222154923.png" alt="img"></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="&#x3D;&#x3D;五、总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;五、总结&#x3D;&#x3D;</h3><p>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。<br>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。<br>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。<br>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Fengzi7.magicalroom.com">封子期</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fengzi7.magicalroom.com/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/">https://fengzi7.magicalroom.com/2024/03/18/C++11新特性/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Fengzi7.magicalroom.com" target="_blank">Fengzi7的奇妙空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++多线程</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/18/hello-world/" title="Hello World"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/boqi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">封子期</div><div class="author-info__description">这个人很懒，请出门左转</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">C++11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E8%AF%AD%E6%B3%95%E5%92%8C%E8%A7%84%E5%88%99"><span class="toc-text">&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-text">&#x3D;&#x3D;auto&#x3D;&#x3D;高级用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">&#x3D;&#x3D;auto&#x3D;&#x3D;的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">&#x3D;&#x3D;decltype&#x3D;&#x3D;类型推导完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exp%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">exp注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exp%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%8D%E8%A2%AB%E2%80%9D%EF%BC%88%EF%BC%89%E2%80%9C%E5%8C%85%E5%9B%B4%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89"><span class="toc-text">exp是一个普通表达式（不被”（）“包围的表达式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp%E4%BD%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88exp%E5%B0%B1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C-%E4%B8%8D%E8%83%BD%E6%98%AFvoid%E7%B1%BB%E5%9E%8B-%EF%BC%89"><span class="toc-text">exp位函数调用（返回值是什么exp就是什么，&#x3D;&#x3D;不能是void类型&#x3D;&#x3D;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp%E6%98%AF%E5%B7%A6%E5%80%BC%E6%88%96%E8%80%85%E8%A2%AB%E2%80%9D%EF%BC%88%EF%BC%89%E2%80%9C%E5%8C%85%E5%9B%B4"><span class="toc-text">exp是左值或者被”（）“包围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-text">&#x3D;&#x3D;decltype&#x3D;&#x3D;的实际应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE"><span class="toc-text">返回值类型后置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-%E5%92%8C-decltype%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">auto 和 decltype的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-text">using定义别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-text">C++11支持函数模板的默认模板参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple%E5%85%83%E7%BB%84"><span class="toc-text">tuple元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">tuple对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1) 类的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-make-tuple-%E5%87%BD%E6%95%B0"><span class="toc-text">2) make_tuple()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">tuple常用函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E7%BB%9F%E4%B8%80%E4%BA%86%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">C++11列表初始化（统一了初始化方式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">统一的初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">lambda匿名函数的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">lambda匿名函数中的[外部变量]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-text">lambda 匿名函数的定义和使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">值传递和引用传递的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-text">执行抛出异常类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89"><span class="toc-text">C++11非受限联合体（union）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-11-%E5%85%81%E8%AE%B8%E9%9D%9E-POD-%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. C++11 允许非 POD 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2C-11-%E5%85%81%E8%AE%B8%E8%81%94%E5%90%88%E4%BD%93%E6%9C%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">2C++11 允许联合体有静态成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E8%B5%8B%E5%80%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">非受限联合体的赋值注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#placement-new-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">placement new 是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%A3%B0%E6%98%8E%E5%92%8C%E2%80%9C%E6%9E%9A%E4%B8%BE%E5%BC%8F%E7%B1%BB%E2%80%9D"><span class="toc-text">非受限联合体的匿名声明和“枚举式类”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#constexpr%E9%AA%8C%E8%AF%81%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">constexpr验证常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-text">constexpr修饰普通变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0"><span class="toc-text">constexpr修饰函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">constexpr修饰类的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constexpr%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-text">constexpr修饰模板函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#long-long-%E8%B6%85%E9%95%BF%E6%95%B4%E5%BD%A2%E8%AF%A6%E8%A7%A3"><span class="toc-text">long long 超长整形详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%88%E4%B8%80%E7%9C%8B%E5%8D%B3%E6%87%82%EF%BC%89"><span class="toc-text">C++11右值引用（一看即懂）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text">C++左值和右值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">C++右值引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8Astd-move-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">移动构造函数及std::move() 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-text">复制构造和移动构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-move"><span class="toc-text">std::move</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90C-11%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-text">继续深入分析C++11的右值引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8move%E5%87%BD%E6%95%B0%E8%BD%AC%E4%BA%A4unique-ptr%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">使用move函数转交unique_ptr的所有权</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">引用限定符的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%92%8C%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">const和引用限定符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">C++11完美转发及实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%EF%BC%9F"><span class="toc-text">什么是完美转发？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nullptr%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">nullptr：初始化空指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">shared_ptr智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11-shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">C++11 shared_ptr智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81shared-ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1、shared_ptr智能指针的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81shared-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">2、shared_ptr模板类提供的成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8Bunique-ptr"><span class="toc-text">C++智能指针之unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81unique-ptr"><span class="toc-text">一、unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-unique-ptr%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.1 unique_ptr类的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-unique-ptr%E7%A6%81%E6%AD%A2%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">1.2 unique_ptr禁止拷贝和赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-release%E3%80%81reset%E5%87%BD%E6%95%B0"><span class="toc-text">1.3 release、reset函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%90%91unique-ptr%E4%BC%A0%E9%80%92%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">1.4 向unique_ptr传递删除器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-unique-ptr%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.5 unique_ptr与动态数组的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88weak-ptr"><span class="toc-text">C++智能指针weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-text">二、内部函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81std-weak-ptr%E7%94%A8%E6%B3%95"><span class="toc-text">三、std::weak_ptr用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">四、循环引用问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">&#x3D;&#x3D;五、总结&#x3D;&#x3D;</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/stl/" title="STL"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL"/></a><div class="content"><a class="title" href="/2024/03/18/stl/" title="STL">STL</a><time datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/socket/" title="socket"><img src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="socket"/></a><div class="content"><a class="title" href="/2024/03/18/socket/" title="socket">socket</a><time datetime="2024-03-18T06:45:14.362Z" title="发表于 2024-03-18 14:45:14">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++多线程"/></a><div class="content"><a class="title" href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-03-18T06:45:10.276Z" title="发表于 2024-03-18 14:45:10">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++11新特性"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11新特性"/></a><div class="content"><a class="title" href="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++11新特性">C++11新特性</a><time datetime="2024-03-18T06:45:08.161Z" title="发表于 2024-03-18 14:45:08">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/hello-world/" title="Hello World"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/03/18/hello-world/" title="Hello World">Hello World</a><time datetime="2024-03-18T02:45:02.016Z" title="发表于 2024-03-18 10:45:02">2024-03-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 封子期</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1957725779" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>