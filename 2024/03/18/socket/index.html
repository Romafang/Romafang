<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>socket | Fengzi7的奇妙空间</title><meta name="author" content="封子期"><meta name="copyright" content="封子期"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="socket是什么？套接字是什么？网络编程就是编写程序使两台联网的计算机相互交换数据。这就是全部内容了吗？是的！网络编程要比想象中的简单许多。 那么，这两台计算机之间用什么传输数据呢？首先需要物理连接。如今大部分计算机都已经连接到互联网，因此不用担心这一点。 在此基础上，只需要考虑如何编写数据传输程序。但实际上这点也不用愁，因为操作系统已经提供了 socket。即使对网络数据传输的原理不太熟悉，我">
<meta property="og:type" content="article">
<meta property="og:title" content="socket">
<meta property="og:url" content="https://fengzi7.magicalroom.com/2024/03/18/socket/index.html">
<meta property="og:site_name" content="Fengzi7的奇妙空间">
<meta property="og:description" content="socket是什么？套接字是什么？网络编程就是编写程序使两台联网的计算机相互交换数据。这就是全部内容了吗？是的！网络编程要比想象中的简单许多。 那么，这两台计算机之间用什么传输数据呢？首先需要物理连接。如今大部分计算机都已经连接到互联网，因此不用担心这一点。 在此基础上，只需要考虑如何编写数据传输程序。但实际上这点也不用愁，因为操作系统已经提供了 socket。即使对网络数据传输的原理不太熟悉，我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg">
<meta property="article:published_time" content="2024-03-18T06:45:14.362Z">
<meta property="article:modified_time" content="2024-03-19T06:59:35.081Z">
<meta property="article:author" content="封子期">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fengzi7.magicalroom.com/2024/03/18/socket/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'socket',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-19 14:59:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/boqi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Fengzi7的奇妙空间"><span class="site-name">Fengzi7的奇妙空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">socket</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-18T06:45:14.362Z" title="发表于 2024-03-18 14:45:14">2024-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T06:59:35.081Z" title="更新于 2024-03-19 14:59:35">2024-03-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="socket"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="socket是什么？套接字是什么？"><a href="#socket是什么？套接字是什么？" class="headerlink" title="socket是什么？套接字是什么？"></a>socket是什么？套接字是什么？</h1><p>网络编程就是编写程序使两台联网的计算机相互交换数据。这就是全部内容了吗？是的！网络编程要比想象中的简单许多。</p>
<p>那么，这两台计算机之间用什么传输数据呢？首先需要物理连接。如今大部分计算机都已经连接到互联网，因此不用担心这一点。</p>
<p>在此基础上，只需要考虑如何编写数据传输程序。但实际上这点也不用愁，因为操作系统已经提供了 <a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>。即使对网络数据传输的原理不太熟悉，我们也能通过 socket 来编程。</p>
<h2 id="什么是-socket？"><a href="#什么是-socket？" class="headerlink" title="什么是 socket？"></a>什么是 socket？</h2><p>&#x3D;&#x3D;<strong>socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</strong>&#x3D;&#x3D;</p>
<p>我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。</p>
<p>socket 的典型应用就是 Web 服务器和浏览器：浏览器获取用户输入的 URL，向服务器发起请求，服务器分析接收到的 URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。</p>
<p>学习 socket，也就是学习计算机之间如何通信，并编写出实用的程序。</p>
<h2 id="UNIX-Linux-中的-socket-是什么？"><a href="#UNIX-Linux-中的-socket-是什么？" class="headerlink" title="UNIX&#x2F;Linux 中的 socket 是什么？"></a>UNIX&#x2F;Linux 中的 socket 是什么？</h2><p>为了表示和区分已经打开的文件，UNIX&#x2F;Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：</p>
<ul>
<li>通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；</li>
<li>通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。</li>
</ul>
<p>UNIX&#x2F;Linux 程序在执行任何形式的 I&#x2F;O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p>
<p>&#x3D;&#x3D;<strong>网络连接也是一个文件，它也有文件描述符！</strong>&#x3D;&#x3D;</p>
<p>我们可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p>
<ul>
<li>用 read() 读取从远程计算机传来的数据；</li>
<li>用 write() 向远程计算机写入数据。</li>
</ul>
<h2 id="Window-系统中的-socket-是什么？"><a href="#Window-系统中的-socket-是什么？" class="headerlink" title="Window 系统中的 socket 是什么？"></a>Window 系统中的 socket 是什么？</h2><p>Windows 也有类似“文件描述符”的概念，但通常被称为“文件句柄”。因此，本教程如果涉及 Windows 平台将使用&#x3D;&#x3D;“句柄”&#x3D;&#x3D;，如果涉及 Linux 平台则使用<strong>“描述符”</strong>。</p>
<p>与 UNIX&#x2F;Linux 不同的是，Windows 会区分 socket 和文件，Windows 就把 socket 当做一个网络连接来对待，因此需要调用专门针对 socket 而设计的数据传输函数，针对普通文件的输入输出函数就无效了。</p>
<h1 id="套接字有哪些类型？socket有哪些类型？"><a href="#套接字有哪些类型？socket有哪些类型？" class="headerlink" title="套接字有哪些类型？socket有哪些类型？"></a>套接字有哪些类型？socket有哪些类型？</h1><p>有很多种套接字（<a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>），比如 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）等。nternet 套接字，它是最具代表性的，也是最经典最常用的。以后我们提及套接字，指的都是 Internet 套接字。</p>
<h2 id="流格式套接字（SOCK-STREAM）"><a href="#流格式套接字（SOCK-STREAM）" class="headerlink" title="流格式套接字（SOCK_STREAM）"></a>流格式套接字（SOCK_STREAM）</h2><p>流格式套接字（Stream Sockets）也叫“面向连接的套接字”，在代码中使用 SOCK_STREAM 表示。</p>
<p><strong>SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。</strong></p>
<p>SOCK_STREAM 有以下几个特征：</p>
<ul>
<li>数据在传输过程中不会消失；</li>
<li>数据是按照顺序传输的；</li>
<li>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。</li>
</ul>
<p> SOCK_STREAM 比喻成一条传送带，只要传送带本身没有问题（不会断网），就能保证数据不丢失；同时，较晚传送的数据不会先到达，较早传送的数据不会晚到达，这就保证了数据是按照顺序传递的。</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190123/1-1Z1232154153L.gif" alt="将面向连接的套接字比喻成传送带"></p>
<p>为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议（The Transmission Control Protocol，传输控制协议），TCP 协议会控制你的数据按照顺序到达并且没有错误。</p>
<p>TCP&#x2F;IP”。TCP 用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。</p>
<p><strong>“数据的发送和接收不同步”</strong></p>
<p>假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。</p>
<p>流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。</p>
<p>不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。</p>
<p>浏览器所使用的 http 协议就基于面向连接的套接字，因为必须要确保数据准确无误，否则加载的 HTML 将无法解析。</p>
<h2 id="数据报格式套接字（SOCK-DGRAM）"><a href="#数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="数据报格式套接字（SOCK_DGRAM）"></a>数据报格式套接字（SOCK_DGRAM）</h2><p>数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”，在代码中使用 SOCK_DGRAM 表示。</p>
<p>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p>
<p>因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。</p>
<p>可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：</p>
<ul>
<li>强调快速传输而非传输顺序；</li>
<li>传输的数据可能丢失也可能损毁；</li>
<li>限制每次传输的数据大小；</li>
<li>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</li>
</ul>
<p>速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度交给客户就行。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，想要传递大量包裹，就得分配发送。用两辆摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以<strong>“数据的发送和接收是同步的”；换句话说，接收次数应该和发送次数相同。</strong></p>
<p>&#x3D;&#x3D;<strong>总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。</strong>&#x3D;&#x3D;</p>
<p>数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p>
<p>QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响</p>
<h1 id="面向连接和无连接的套接字到底有什么区别？"><a href="#面向连接和无连接的套接字到底有什么区别？" class="headerlink" title="面向连接和无连接的套接字到底有什么区别？"></a>面向连接和无连接的套接字到底有什么区别？</h1><p>从字面上理解，面向连接好像有一条管道，它连接发送端和接收端，数据包都通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。</p>
<p>无连接好像没头苍蝇乱撞，数据包从发送端到接收端并没有固定的线路，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是，大家最终都能殊途同归，到达接收端。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190125/1-1Z1251140543K.gif" alt="一个简化的互联网模型"></p>
<p>假设 H1 要发送若干个数据包给 H6，那么有多条路径可以选择，比如：</p>
<ul>
<li>路径①：H1 –&gt; A –&gt; C –&gt; E –&gt; H6</li>
<li>路径②：H1 –&gt; A –&gt; B –&gt; E –&gt; H6</li>
<li>路径③：H1 –&gt; A –&gt; B –&gt; D –&gt; E –&gt; H6</li>
<li>路径④：H1 –&gt; A –&gt; B –&gt; C –&gt; E –&gt; H6</li>
<li>路径⑤：H1 –&gt; A –&gt; C –&gt; B –&gt; D –&gt; E –&gt; H6</li>
</ul>
<p>数据包的传输路径是路由器根据算法来计算出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。</p>
<h3 id="无连接的套接字"><a href="#无连接的套接字" class="headerlink" title="无连接的套接字"></a><strong>无连接的套接字</strong></h3><p>于无连接的套接字，每个数据包可以选择不同的路径，比如第一个数据包选择路径④，第二个数据包选择路径①，第三个数据包选择路径②……当然，它们也可以选择相同的路径，那也只不过是巧合而已。</p>
<p>每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达 H6。但是，到达的顺序是不确定的，比如：</p>
<ul>
<li>第一个数据包选择了一条比较长的路径（比如路径⑤），第三个数据包选择了一条比较短的路径（比如路径①），虽然第一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。</li>
<li>第一个数据包选择了一条比较短的路径（比如路径①），第三个数据包选择了一条比较长的路径（比如路径⑤），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理得很慢，所以它还是晚于第三个数据包达到了。</li>
</ul>
<p>还有一些意外情况会发生，比如：</p>
<ul>
<li>第一个数据包选择了路径①，但是路由器C突然断电了，那它就到不了 H6 了。</li>
<li>第三个数据包选择了路径②，虽然路不远，但是太拥堵，以至于它等待的时间太长，路由器把它丢弃了。</li>
</ul>
<p>对于无连接的套接字，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1 只负责把数据包发出，至于它什么时候到达，先到达还是后到达，有没有成功到达，H1 都不管了；H6 也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。</p>
<p>无连接套接字遵循的是「尽最大努力交付」的原则，就是尽力而为，实在做不到了也没办法。无连接套接字提供的没有质量保证的服务。</p>
<h3 id="面向连接的套接字"><a href="#面向连接的套接字" class="headerlink" title="面向连接的套接字"></a>面向连接的套接字</h3><p>面向连接的套接字在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么会重新建立路径。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190125/1-1Z1251F50LS.gif" alt="选好的路径"></p>
<p>这条路径是由路由器维护的，路径上的所有路由器都要存储该路径的信息（实际上只需要存储上游和下游的两个路由器的位置就行），所以路由器是有开销的。</p>
<p>H1 和 H6 通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。</p>
<p>在很多网络通信教程中，这条预先建立好的路径被称为“虚电路”，就是一条虚拟的通信电路。</p>
<p>为了保证数据包准确、顺序地到达，发送端在发送数据包以后，必须得到接收端的确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍然没有得到接收端的回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。</p>
<p>&#x3D;&#x3D;<strong>发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每一个数据包分配一个 ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了 ID 为 xxx 的数据包。</strong>&#x3D;&#x3D;</p>
<p>面向连接的套接字会比无连接的套接字多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。</p>
<p>不但是数量多了，每个数据包也变大了：除了源端口和目的端口，面向连接的套接字还包括序号、确认信号、数据偏移、控制标志（通常说的 URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息；而无连接的套接字则只包含长度和校验和信息。</p>
<p>有连接的数据包比无连接大很多，这意味着更大的负载和更大的带宽。许多即时聊天软件采用 UDP 协议（无连接套接字），与此有莫大的关系。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种套接字各有优缺点：</p>
<ul>
<li>无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险；</li>
<li>有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。</li>
</ul>
<p>两种套接字的特点决定了它们的应用场景，有些服务对可靠性要求比较高，必须数据包能够完整无误地送达，那就得选择有连接的套接字（TCP 服务），比如 HTTP、FTP 等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择无连接的套接字（UDP 服务），比如 DNS、即时聊天工具等。</p>
<h1 id="OSI网络七层模型简明教程"><a href="#OSI网络七层模型简明教程" class="headerlink" title="OSI网络七层模型简明教程"></a>OSI网络七层模型简明教程</h1><p><img src="https://c.biancheng.net/uploads/allimg/190124/1-1Z1241445324H.jpg" alt="OSI 七层网络模型和 TCP/IP 四层网络模型的对比"></p>
<p><strong>这个网络模型究竟是干什么呢？简而言之就是进行数据封装的。</strong></p>
<p>我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层的协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。</p>
<p>当另一台计算机接收到数据包时，会从网络接口层再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。</p>
<p>给数据加包装的过程，实际上就是在数据的头部增加一个标志（一个数据块），表示数据经过了这一层，我已经处理过了。给数据拆包装的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。</p>
<p>&#x3D;&#x3D;<strong>我们所说的 <a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a> 编程，是站在传输层的基础上，所以可以使用 TCP&#x2F;UDP 协议，但是不能干「访问网页」这样的事情，因为访问网页所需要的 http 协议位于应用层。</strong>&#x3D;&#x3D;</p>
<p>两台计算机进行通信时，必须遵守以下原则：</p>
<ul>
<li>必须是同一层次进行通信，比如，A 计算机的应用层和 B 计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。</li>
<li>每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。</li>
<li>数据只能逐层传输，不能跃层。</li>
<li>每一层可以使用下层提供的服务，并向上层提供服务。</li>
</ul>
<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h1><p>目前实际使用的网络模型是 TCP&#x2F;IP 模型，它对 OSI 模型进行了简化，只包含了四层，从上到下分别是应用层、传输层、网络层和链路层（网络接口层），每一层都包含了若干协议。</p>
<p>协议（Protocol）就是网络通信过程中的约定或者合同，通信的双方必须都遵守才能正常收发数据。协议有很多种，例如 TCP、UDP、IP 等，通信的双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。</p>
<p>&#x3D;&#x3D;<strong>协议仅仅是一种规范，必须由计算机软件来实现。例如 IP 协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵守该协议，不能另起炉灶。</strong>&#x3D;&#x3D;</p>
<p>TCP&#x2F;IP 模型包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百个互为关联的协议，其中 TCP 和 IP 是最常用的两种底层协议，所以把它们统称为“TCP&#x2F;IP 协议族”。</p>
<p>也就是说，“TCP&#x2F;IP模型”中所涉及到的协议称为“TCP&#x2F;IP协议族”，你可以区分这两个概念，也可以认为它们是等价的</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190126/1-1Z126104435N0.gif" alt="TCP/IP协议的层次图"></p>
<h1 id="IP、MAC和端口号——网络通信中确认身份信息的三要素"><a href="#IP、MAC和端口号——网络通信中确认身份信息的三要素" class="headerlink" title="IP、MAC和端口号——网络通信中确认身份信息的三要素"></a>IP、MAC和端口号——网络通信中确认身份信息的三要素</h1><p>在茫茫的互联网海洋中，要找到一台计算机非常不容易，有三个要素必须具备，它们分别是 IP 地址、MAC 地址和端口号。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。</p>
<p>目前大部分软件使用 IPv4 地址，但 IPv6 也正在被人们接受，尤其是在教育网中，已经大量使用。</p>
<p>一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。</p>
<p>在因特网上进行通信时，必须要知道对方的 IP 地址。实际上数据包中已经附带了 IP 地址，把数据包发送给路由器以后，路由器会根据 IP 地址找到对方的地里位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快就会找到目标计算机。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>现实的情况是，一个局域网往往才能拥有一个独立的 IP；换句话说，IP 地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信啊。</p>
<p>其实，真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的。计算机出厂时，MAC 地址已经被写死到网卡里面了（当然通过某些“奇巧淫技”也是可以修改的）。局域网中的路由器&#x2F;交换机会记录每台计算机的 MAC 地址。</p>
<p>&#x3D;&#x3D;<strong>MAC 地址是 Media Access Control Address 的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address）。</strong>&#x3D;&#x3D;</p>
<p>数据包中除了会附带对方的 IP 地址，还会附带对方的 MAC 地址，当数据包达到局域网以后，路由器&#x2F;交换机会根据数据包中的 MAC 地址找到对应的计算机，然后把数据包转交给它，这样就完成了数据的传递。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>有了 IP 地址和 MAC 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等，仅有 IP 地址和 MAC 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。</p>
<p>为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。</p>
<p>端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。如下图所示：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190126/15060130Z-0.jpg" alt="img"></p>
<h1 id="Linux下的socket演示程序"><a href="#Linux下的socket演示程序" class="headerlink" title="Linux下的socket演示程序"></a>Linux下的socket演示程序</h1><p>server.cpp</p>
<p><img src="/../../typora-user-images/image-20240316101556455.png" alt="image-20240316101556455"></p>
<p>client.cpp</p>
<p><img src="/../../typora-user-images/image-20240316101626733.png" alt="image-20240316101626733"></p>
<p>启动一个终端（Shell），先编译 server.cpp 并运行：</p>
<p><img src="/../../typora-user-images/image-20240316101653780.png" alt="image-20240316101653780"></p>
<p>正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。</p>
<p>接下再启动一个终端，编译 client.cpp 并运行：</p>
<p><img src="/../../typora-user-images/image-20240316101722680.png" alt="image-20240316101722680"></p>
<p>client 接收到从 server发送过来的字符串就运行结束了，同时，server 完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。</p>
<p>client 运行后，通过 connect() 函数向 server 发起请求，处于监听状态的 server 被激活，执行 accept() 函数，接受客户端的请求，然后执行 write() 函数向 client 传回数据。client 接收到传回的数据后，connect() 就运行结束了，然后使用 read() 将数据读取出来。</p>
<p>源码解析</p>
<p>server.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="comment">/*通过 socket() 函数创建了一个套接字，参数 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向连接的套接字，IPPROTO_TCP 表示使用 TCP 协议。在 Linux 中，socket 也是一种文件，有文件描述符，可以使用 write() / read() 函数进行 I/O 操作，这一点已在《socket是什么》中进行了讲解。*/</span></span><br><span class="line">    <span class="type">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">/*通过 bind() 函数将套接字 serv_sock 与特定的 IP 地址和端口绑定，IP 地址和端口都保存在 sockaddr_in 结构体中。socket() 函数确定了套接字的各种属性，bind() 函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="comment">/*让套接字处于被动监听状态。所谓被动监听，是指套接字一直处于“睡眠”中，直到客户端发起请求才会被“唤醒”*/</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">/* accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。*/</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;http://c.biancheng.net/socket/&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">/* accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。*/</span></span><br><span class="line">    <span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   <span class="comment">//通过 read() 从套接字文件中读取数据。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Windows下终端g-执行socket需要带动态链接库后缀-lws2-32"><a href="#Windows下终端g-执行socket需要带动态链接库后缀-lws2-32" class="headerlink" title="&#x3D;&#x3D;Windows下终端g++执行socket需要带动态链接库后缀        -lws2_32&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>Windows下终端g++执行socket需要带动态链接库后缀        -lws2_32</strong>&#x3D;&#x3D;</h1><h1 id="Windows下的socket演示程序"><a href="#Windows下的socket演示程序" class="headerlink" title="Windows下的socket演示程序"></a>Windows下的socket演示程序</h1><p>服务器端代码 server.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化 DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET servSock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    <span class="built_in">listen</span>(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    SOCKET clntSock = <span class="built_in">accept</span>(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">//char *str=&quot;Hello World!&quot;;error&quot;Hello World!&quot;是常量不能修改，char*指针类型是可以修改数据的所以不能使用，要加const</span></span><br><span class="line">    <span class="built_in">send</span>(clntSock, str, <span class="built_in">strlen</span>(str)+<span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clntSock);</span><br><span class="line">    <span class="built_in">closesocket</span>(servSock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止 DLL 的使用</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> szBuffer[MAXBYTE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(sock, szBuffer, MAXBYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, szBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止使用 DLL</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/../../typora-user-images/image-20240316142343404.png" alt="image-20240316142343404"></p>
<p>Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别：</p>
<ol>
<li><p>Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。DLL 有两种加载方式</p>
</li>
<li><p>Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。</p>
</li>
<li><p>Linux 下使用 read() &#x2F; write() 函数读写，而 Windows 下使用 recv() &#x2F; send() 函数发送和接收。</p>
</li>
<li><p>关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。</p>
</li>
</ol>
<h1 id="Windows下使用WSAStartup-函数加载DLL"><a href="#Windows下使用WSAStartup-函数加载DLL" class="headerlink" title="Windows下使用WSAStartup()函数加载DLL"></a>Windows下使用WSAStartup()函数加载DLL</h1><ul>
<li>较早的DLL是 wsock32.dll，大小为 28KB，对应的头文件为 winsock1.h；</li>
<li>最新的DLL是 ws2_32.dll，大小为 69KB，对应的头文件为 winsock2.h。</li>
</ul>
<p>几乎所有的 Windows 操作系统都已经支持 ws2_32.dll，包括个人操作系统 Windows 95 OSR2、Windows 98、Windows Me、Windows 2000、XP、Vista、Win7、Win8、Win10 以及服务器操作系统 Windows NT 4.0 SP4、Windows Server 2003、Windows Server 2008 等，所以你可以毫不犹豫地使用最新的 ws2_32.dll。<br>使用<code>#pragma</code>命令，在编译时加载：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="WSAStartup-函数"><a href="#WSAStartup-函数" class="headerlink" title="WSAStartup() 函数"></a>WSAStartup() 函数</h2><p>使用 DLL 之前，还需要调用 WSAStartup() 函数进行初始化，以指明 WinSock 规范的版本，它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA lpWSAData)</span></span>;</span><br></pre></td></tr></table></figure>

<p>wVersionRequested 为 WinSock 规范的版本号，低字节为主版本号，高字节为副版本号（修正版本号）；lpWSAData 为指向 WSAData 结构体的指针。</p>
<p><strong>关于 WinSock 规范</strong><br>WinSock 规范的最新版本号为 2.2，较早的有 2.1、2.0、1.1、1.0，ws2_32.dll 支持所有的规范，而 wsock32.dll 仅支持 1.0 和 1.1。</p>
<p>wsock32.dll 已经能够很好的支持 TCP&#x2F;IP 通信程序的开发，ws2_32.dll 主要增加了对其他协议的支持，不过建议使用最新的 2.2 版本。</p>
<p>wVersionRequested 参数用来指明我们希望使用的版本号，它的类型为 WORD，等价于 unsigned short，是一个整数，所以需要用 MAKEWORD() 宏函数对版本号进行转换。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//主版本号为1，副版本号为2，返回 0x0201</span></span><br><span class="line"><span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">//主版本号为2，副版本号为2，返回 0x0202</span></span><br></pre></td></tr></table></figure>

<p><strong>关于 WSAData 结构体</strong></p>
<p>WSAStartup() 函数执行成功后，会将与 ws2_32.dll 有关的信息写入 WSAData 结构体变量。WSAData 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">    WORD           wVersion;  <span class="comment">//ws2_32.dll 建议我们使用的版本号</span></span><br><span class="line">    WORD           wHighVersion;  <span class="comment">//ws2_32.dll 支持的最高版本号</span></span><br><span class="line">    <span class="comment">//一个以 null 结尾的字符串，用来说明 ws2_32.dll 的实现以及厂商信息</span></span><br><span class="line">    <span class="type">char</span>           szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//一个以 null 结尾的字符串，用来说明 ws2_32.dll 的状态以及配置信息</span></span><br><span class="line">    <span class="type">char</span>           szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxSockets;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxUdpDg;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">    <span class="type">char</span> FAR       *lpVendorInfo;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">&#125; WSADATA, *LPWSADATA;</span><br><span class="line"><span class="comment">/*只需关注前两个成员即可*/</span></span><br></pre></td></tr></table></figure>

<h1 id="socket-函数用法详解：创建套接字"><a href="#socket-函数用法详解：创建套接字" class="headerlink" title="socket()函数用法详解：创建套接字"></a>socket()函数用法详解：创建套接字</h1><p>不管是 Windows 还是 Linux，都使用 <a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>() 函数来创建套接字。socket() 在两个平台下的参数是相同的，不同的是返回值</p>
<p>Linux 中的一切都是文件，每个文件都有一个整数类型的文件描述符；socket 也是一个文件，也有文件描述符。使用 socket() 函数创建套接字以后，返回值就是一个 int 类型的文件描述符。</p>
<p>Windows 会区分 socket 和普通文件，它把 socket 当做一个网络连接来对待，调用 socket() 以后，返回值是 SOCKET 类型，用来表示一个套接字。</p>
<h2 id="Linux-下的-socket-函数"><a href="#Linux-下的-socket-函数" class="headerlink" title="Linux 下的 socket() 函数"></a>Linux 下的 socket() 函数</h2><p>在 Linux 下使用 &#x3D;&#x3D;&lt;sys&#x2F;socket.h&gt;&#x3D;&#x3D;头文件中 socket() 函数来创建套接字，原型为</p>
<ol>
<li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</li>
</ol>
<p>大家需要记住&#x3D;&#x3D;<strong><code>127.0.0.1</code></strong>&#x3D;&#x3D;，它是一个特殊IP地址，表示本机地址，后面的教程会经常用到。</p>
<p><code>可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</code></p>
<ol start="2">
<li><p>type 为数据传输方式&#x2F;套接字类型，常用的有 SOCK_STREAM（流格式套接字&#x2F;面向连接的套接字） 和 SOCK_DGRAM（数据报套接字&#x2F;无连接的套接字），我们已经在《<a target="_blank" rel="noopener" href="https://c.biancheng.net/view/2124.html">套接字有哪些类型</a>》一节中进行了介绍。</p>
</li>
<li><p>protocol 表示传输协议，常用的有 &#x3D;&#x3D;IPPROTO_TCP&#x3D;&#x3D; 和 &#x3D;&#x3D;IPPTOTO_UDP&#x3D;&#x3D;，分别表示 TCP 传输协议和 UDP 传输协议。</p>
</li>
</ol>
<p>有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？</p>
<p>正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：&#x3D;&#x3D;<strong>有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</strong>&#x3D;&#x3D;</p>
<p>使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用 socket() 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="comment">//IPPROTO_TCP表示TCP协议</span></span><br></pre></td></tr></table></figure>

<p>这种套接字称为 TCP 套接字。</p>
<p>如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket() 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  <span class="comment">//IPPROTO_UDP表示UDP协议</span></span><br></pre></td></tr></table></figure>

<p>这种套接字称为 UDP 套接字。</p>
<p>面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  <span class="comment">//创建UDP套接字</span></span><br></pre></td></tr></table></figure>

<p>后面的教程中多采用这种简化写法。</p>
<h2 id="在Windows下创建socket"><a href="#在Windows下创建socket" class="headerlink" title="在Windows下创建socket"></a>在Windows下创建socket</h2><p>Windows 下也使用 socket() 函数来创建套接字，原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除了返回值类型不同，其他都是相同的。Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br></pre></td></tr></table></figure>

<h1 id="bind-和connect-函数：绑定套接字并建立连接"><a href="#bind-和connect-函数：绑定套接字并建立连接" class="headerlink" title="bind()和connect()函数：绑定套接字并建立连接"></a>bind()和connect()函数：绑定套接字并建立连接</h1><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 bind() 函数将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理。类似地，客户端也要用 connect() 函数建立连接。</p>
<h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind() 函数"></a>bind() 函数</h2><p>bind() 函数的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>Linux为例</p>
<p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。</p>
<p><img src="/../../typora-user-images/image-20240316150402739.png" alt="image-20240316150402739"></p>
<h3 id="sockaddr-in-结构体"><a href="#sockaddr-in-结构体" class="headerlink" title="sockaddr_in 结构体"></a>sockaddr_in 结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;     <span class="comment">//16位的端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>            sin_zero[<span class="number">8</span>];  <span class="comment">//不使用，一般用0填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>sin_family 和 socket() 的第一个参数的含义相同，取值也要保持一致。</p>
</li>
<li><p>sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0<del>65536，但 0</del>1023 的端口一般由系统分配给特定的服务程序，例如 <strong>Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。</strong></p>
</li>
</ol>
<p>&#x3D;&#x3D;端口号需要用 htons() 函数转换，后面会讲解为什么。&#x3D;&#x3D;</p>
<ol start="3">
<li><p>sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。</p>
</li>
<li><p>sin_zero[8] 是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。</p>
</li>
</ol>
<h3 id="in-addr-结构体"><a href="#in-addr-结构体" class="headerlink" title="in_addr 结构体"></a>in_addr 结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">in_addr_t</span>  s_addr;  <span class="comment">//32位的IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>in_addr_t 在头文件 &#x3D;&#x3D;&lt;netinet&#x2F;in.h&gt;&#x3D;&#x3D; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ip = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ip);</span><br></pre></td></tr></table></figure>

<p><img src="https://c.biancheng.net/uploads/allimg/190219/112P63295-0.jpg" alt="img"></p>
<h3 id="为什么使用-sockaddr-in-而不使用-sockaddr"><a href="#为什么使用-sockaddr-in-而不使用-sockaddr" class="headerlink" title="为什么使用 sockaddr_in 而不使用 sockaddr"></a>为什么使用 sockaddr_in 而不使用 sockaddr</h3><p>bind() 第二个参数的类型为 sockaddr，而代码中却使用 sockaddr_in，然后再强制转换为 sockaddr，这是为什么呢？</p>
<p>sockaddr 结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;    </span><br><span class="line">    <span class="type">sa_family_t</span>  sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">char</span>         sa_data[<span class="number">14</span>];      <span class="comment">//IP地址和端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://c.biancheng.net/uploads/allimg/190219/112PA615-1.jpg" alt="img"></p>
<p>sockaddr 和 sockaddr_in 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，&#x3D;&#x3D;没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。&#x3D;&#x3D;这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。</p>
<p><strong>可以认为，&#x3D;&#x3D;sockaddr 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，而 sockaddr_in 是专门用来保存 IPv4 地址的结构体。&#x3D;&#x3D;另外还有 sockaddr_in6，用来保存 IPv6 地址，它的定义如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123; </span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;  <span class="comment">//(2)地址类型，取值为AF_INET6</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;  <span class="comment">//(2)16位端口号</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;  <span class="comment">//(4)IPv6流信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class="comment">//(4)具体的IPv6地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;  <span class="comment">//(4)接口范围ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>正是由于通用结构体 sockaddr 使用不便，才针对不同的地址类型定义了不同的结构体。</strong></p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect() 函数"></a>connect() 函数</h2><p>connect() 函数用来建立连接，它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>各个参数的说明和 bind() 相同</p>
<h1 id="listen-和accept-函数：让套接字进入监听状态并响应客户端请求"><a href="#listen-和accept-函数：让套接字进入监听状态并响应客户端请求" class="headerlink" title="listen()和accept()函数：让套接字进入监听状态并响应客户端请求"></a>listen()和accept()函数：让套接字进入监听状态并响应客户端请求</h1><p>对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。</p>
<h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen() 函数"></a>listen() 函数</h2><p>通过 listen() 函数可以让套接字进入被动监听状态，它的原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int listen(int sock, int backlog);  //Linuxint listen(SOCKET sock, int backlog);  //Windows</span><br></pre></td></tr></table></figure>

<p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。</p>
<p>所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p>
<h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p>
<p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p>
<p>如果将 backlog 的值设置为 <strong>SOMAXCONN</strong>，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p>
<p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</p>
<p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept() 函数"></a>accept() 函数</h2><p>当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//LinuxSOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen);  //Windows</span></span><br></pre></td></tr></table></figure>

<p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p>
<p>&#x3D;&#x3D;accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。&#x3D;&#x3D;</p>
<p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p>
<h1 id="send-recv-和write-read-：发送数据和接收数据"><a href="#send-recv-和write-read-：发送数据和接收数据" class="headerlink" title="send()&#x2F;recv()和write()&#x2F;read()：发送数据和接收数据"></a>send()&#x2F;recv()和write()&#x2F;read()：发送数据和接收数据</h1><h2 id="Linux下数据的接收和发送"><a href="#Linux下数据的接收和发送" class="headerlink" title="Linux下数据的接收和发送"></a>Linux下数据的接收和发送</h2><p>&#x3D;&#x3D;Linux 不区分套接字文件和普通文件&#x3D;&#x3D;，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p>
<p>&#x3D;&#x3D;<strong>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</strong>&#x3D;&#x3D;</p>
<p>write() 的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd 为要写入的文件的描述符(就是socket套接字)，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。</p>
<blockquote>
<p>size_t 是通过 typedef 声明的 unsigned int 类型；ssize_t 在 “size_t” 前面加了一个”s”，代表 signed，即 ssize_t 是通过 typedef 声明的 signed int 类型。</p>
</blockquote>
<p>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。</p>
<p>read() 的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p>
<p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p>
<h2 id="Windows下数据的接收和发送"><a href="#Windows下数据的接收和发送" class="headerlink" title="Windows下数据的接收和发送"></a>Windows下数据的接收和发送</h2><p>Windows 和 Linux 不同，Windows 区分普通文件和套接字，并定义了专门的接收和发送的函数。</p>
<p>从服务器端发送数据使用 send() 函数，它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sock 为要发送数据的套接字，buf 为要发送的数据的缓冲区地址，len 为要发送的数据的字节数，flags 为发送数据时的选项。</p>
<p>返回值和前三个参数不再赘述，最后的 flags 参数一般设置为 0 或 NULL，初学者不必深究。</p>
<p>在客户端接收数据使用 recv() 函数，它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(SOCKET sock, <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="socket缓冲区以及阻塞模式详解"><a href="#socket缓冲区以及阻塞模式详解" class="headerlink" title="socket缓冲区以及阻塞模式详解"></a>socket缓冲区以及阻塞模式详解</h1><h2 id="socket缓冲区"><a href="#socket缓冲区" class="headerlink" title="socket缓冲区"></a><a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>缓冲区</h2><p><strong>&#x3D;&#x3D;每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。&#x3D;&#x3D;</strong></p>
<p>write()&#x2F;send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p>
<p>TCP协议独立于 write()&#x2F;send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p>
<p>read()&#x2F;recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190219/1149355056-0.jpg" alt="TCP套接字的I/O缓冲区示意图"></p>
<p>这些I&#x2F;O缓冲区特性可整理如下：</p>
<ul>
<li>I&#x2F;O缓冲区在每个TCP套接字中单独存在；</li>
<li>I&#x2F;O缓冲区在创建套接字时自动生成；</li>
<li>即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</li>
<li>关闭套接字将丢失输入缓冲区中的数据。(剩下的没接收)</li>
</ul>
<p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> optVal;</span><br><span class="line"><span class="type">int</span> optLen = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">getsockopt</span>(servSock, SOL_SOCKET, SO_SNDBUF, (<span class="type">char</span>*)&amp;optVal, &amp;optLen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Buffer length: %d\n&quot;</span>, optVal);</span><br></pre></td></tr></table></figure>

<h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><p>对于TCP套接字（默认情况下），当使用 write()&#x2F;send() 发送数据时：</p>
<ol>
<li><p>首先会检查缓冲区，如果缓冲区的可用空间长度&#x3D;&#x3D;小于&#x3D;&#x3D;要发送的数据，那么 write()&#x2F;send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()&#x2F;send() 函数继续写入数据。</p>
</li>
<li><p>如果TCP协议&#x3D;&#x3D;正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()&#x2F;send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()&#x2F;send() 才会被唤醒。&#x3D;&#x3D;</p>
</li>
<li><p>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</p>
</li>
<li><p>直到所有数据被写入缓冲区 write()&#x2F;send() 才能返回。</p>
</li>
</ol>
<p>当使用 read()&#x2F;recv() 读取数据时：</p>
<ol>
<li><p>首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。</p>
</li>
<li><p>如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()&#x2F;recv() 函数再次读取。</p>
</li>
<li><p>直到读取到数据后 read()&#x2F;recv() 函数才会返回，否则就一直被阻塞。</p>
</li>
</ol>
<p>这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。</p>
<blockquote>
<p>TCP套接字默认情况下是阻塞模式，也是最常用的。当然你也可以更改为非阻塞模式，后续我们会讲解。</p>
</blockquote>
<h1 id="TCP协议的粘包问题（数据的无边界性）"><a href="#TCP协议的粘包问题（数据的无边界性）" class="headerlink" title="TCP协议的粘包问题（数据的无边界性）"></a>TCP协议的粘包问题（数据的无边界性）</h1><p>上节我们讲到了<a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>缓冲区和数据的传递过程，可以看到数据的接收和发送是无关的，read()&#x2F;recv() 函数不管数据发送了多少次，都会尽可能多的接收数据。也就是说，read()&#x2F;recv() 和 write()&#x2F;send() 的执行次数可能不同。</p>
<p>例如，write()&#x2F;send() 重复执行三次，每次都发送字符串”abc”，那么目标机器上的 read()&#x2F;recv() 可能分三次接收，每次都接收”abc”；也可能分两次接收，第一次接收”abcab”，第二次接收”cabc”；也可能一次就接收到字符串”abcabcabc”。</p>
<p>假设我们希望客户端每次发送一位学生的学号，让服务器端返回该学生的姓名、住址、成绩等信息，这时候可能就会出现问题，服务器端不能区分学生的学号。例如第一次发送 1，第二次发送 3，服务器可能当成 13 来处理，返回的信息显然是错误的。</p>
<p>&#x3D;&#x3D;这就是数据的“粘包”问题，客户端发送的多个数据包被当做一个数据包接收。也称数据的无边界性，read()&#x2F;recv() 函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），只把它们当做连续的数据流来处理。&#x3D;&#x3D;</p>
<p>下面的代码演示了粘包问题，客户端连续三次向服务器端发送数据，服务器端却一次性接收到所有数据。</p>
<p>server.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET servSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    <span class="built_in">listen</span>(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//缓冲区</span></span><br><span class="line">    SOCKET clntSock = <span class="built_in">accept</span>(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10000</span>);  <span class="comment">//注意这里，让程序暂停10秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端发来的数据，并原样返回</span></span><br><span class="line">    <span class="type">int</span> recvLen = <span class="built_in">recv</span>(clntSock, buffer, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">send</span>(clntSock, buffer, recvLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字并终止DLL的使用</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clntSock);</span><br><span class="line">    <span class="built_in">closesocket</span>(servSock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户输入的字符串并发送给服务器</span></span><br><span class="line">    <span class="type">char</span> bufSend[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span>(bufSend);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">send</span>(sock, bufSend, <span class="built_in">strlen</span>(bufSend), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> bufRecv[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(sock, bufRecv, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, bufRecv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);  <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();  <span class="comment">//终止使用 DLL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行 server，再运行 client，并在10秒内输入字符串”abc”，再等数秒，服务器就会返回数据。</p>
<p><img src="/../../typora-user-images/image-20240316155829752.png" alt="image-20240316155829752"></p>
<p>本程序的关键是 server.cpp 第31行的代码<code>Sleep(10000);</code>，它让程序暂停执行10秒。在这段时间内，client 连续三次发送字符串”abc”，由于 server 被阻塞，数据只能堆积在缓冲区中，10秒后，server 开始运行，从缓冲区中一次性读出所有积压的数据，并返回给客户端。</p>
<p>另外还需要说明的是 client.cpp 第34行代码。client 执行到 recv() 函数，由于输入缓冲区中没有数据，所以会被阻塞，直到10秒后 server 传回数据才开始执行。用户看到的直观效果就是，client 暂停一段时间才输出 server 返回的结果。</p>
<p>client 的 send() 发送了三个数据包，而 server 的 recv() 却只接收到一个数据包，这很好的说明了数据的粘包问题。</p>
<h1 id="图解TCP数据报结构以及三次握手（非常详细）"><a href="#图解TCP数据报结构以及三次握手（非常详细）" class="headerlink" title="图解TCP数据报结构以及三次握手（非常详细）"></a>图解TCP数据报结构以及三次握手（非常详细）</h1><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。</p>
<p>客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。</p>
<p>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p>
<ul>
<li>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”</li>
<li>[Shake 2] 套接字B：“好的，我这边已准备就绪。”</li>
<li>[Shake 3] 套接字A：“谢谢你受理我的请求。”</li>
</ul>
<h2 id="TCP数据报结构"><a href="#TCP数据报结构" class="headerlink" title="TCP数据报结构"></a>TCP数据报结构</h2><p>我们先来看一下TCP数据报的结构：<br><img src="https://c.biancheng.net/uploads/allimg/190219/1155315343-0.jpg" alt="img"></p>
<p>带阴影的几个字段需要重点说明一下：</p>
<ol>
<li><p>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</p>
</li>
<li><p>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，&#x3D;&#x3D;Ack &#x3D; Seq + 1。&#x3D;&#x3D;</p>
</li>
<li><p>标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p>
</li>
</ol>
<ul>
<li>URG：紧急指针（urgent pointer）有效。</li>
<li>ACK：确认序号有效。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：建立一个新连接。</li>
<li>FIN：断开一个连接。</li>
</ul>
<blockquote>
<p>对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p>
</blockquote>
<h2 id="连接的建立（三次握手）"><a href="#连接的建立（三次握手）" class="headerlink" title="连接的建立（三次握手）"></a>连接的建立（三次握手）</h2><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190219/1155312401-1.jpg" alt="img"></p>
<p>客户端调用 <a target="_blank" rel="noopener" href="https://c.biancheng.net/socket/">socket</a>() 函数创建套接字后，因为没有建立连接，所以套接字处于<code>CLOSED</code>状态；服务器端调用 listen() 函数后，套接字进入<code>LISTEN</code>状态，开始监听客户端请求。</p>
<p>这个时候，客户端开始发起请求：</p>
<ol>
<li><p>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了<code>SYN-SEND</code>状态。</p>
</li>
<li><p>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。</p>
</li>
</ol>
<p>服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。</p>
<p>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。</p>
<p>服务器将数据包发出，进入<code>SYN-RECV</code>状态。</p>
<ol start="3">
<li>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。</li>
</ol>
<p>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。</p>
<p>客户端将数据包发出，进入<code>ESTABLISED</code>状态，表示连接已经成功建立。</p>
<ol start="4">
<li>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入<code>ESTABLISED</code>状态。</li>
</ol>
<p>至此，客户端和服务器都进入了<code>ESTABLISED</code>状态，连接建立成功，接下来就可以收发数据了。</p>
<h2 id="最后的说明"><a href="#最后的说明" class="headerlink" title="最后的说明"></a>最后的说明</h2><p>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看<code>Ack = Seq + 1</code>是否成立，如果成立说明对方正确收到了自己的数据包。</p>
<h1 id="详细分析TCP数据的传输过程"><a href="#详细分析TCP数据的传输过程" class="headerlink" title="详细分析TCP数据的传输过程"></a>详细分析TCP数据的传输过程</h1><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190219/115A462I-0.jpg" alt="TCP 套接字的数据交换过程"><br>图1：TCP 套接字的数据交换过程</p>
<p>上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。</p>
<blockquote>
<p>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。</p>
</blockquote>
<p>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：</p>
<p>&#x3D;&#x3D;<strong>Ack号 &#x3D; Seq号 + 传递的字节数 + 1</strong>&#x3D;&#x3D;</p>
<p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。</p>
<p>下面分析传输过程中数据包丢失的情况，如下图所示：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190219/115A453O-1.jpg" alt="img"><br>图2：TCP套接字数据传输过程中发生错误</p>
<p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。</p>
<p>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。</p>
<blockquote>
<p>上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。</p>
</blockquote>
<h4 id="重传超时时间（RTO-Retransmission-Time-Out）"><a href="#重传超时时间（RTO-Retransmission-Time-Out）" class="headerlink" title="重传超时时间（RTO, Retransmission Time Out）"></a>重传超时时间（RTO, Retransmission Time Out）</h4><p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。</p>
<blockquote>
<p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。</p>
</blockquote>
<h4 id="重传次数"><a href="#重传次数" class="headerlink" title="重传次数"></a>重传次数</h4><p>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p>
<p>&#x3D;&#x3D;最后需要说明的是，发送端只有在收到对方的 ACK 确认包后，才会清空输出缓冲区中的数据。&#x3D;&#x3D;</p>
<h1 id="图解TCP四次握手断开连接"><a href="#图解TCP四次握手断开连接" class="headerlink" title="图解TCP四次握手断开连接"></a>图解TCP四次握手断开连接</h1><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。</p>
<p>建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：</p>
<ul>
<li>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”</li>
<li>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”</li>
<li>等待片刻后……</li>
<li>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”</li>
<li>[Shake 4] 套接字A：“好的，谢谢合作。”</li>
</ul>
<p>下图演示了客户端主动断开连接的场景：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/190219/115T13926-0.jpg" alt="img"></p>
<p>建立连接后，客户端和服务器都处于<code>ESTABLISED</code>状态。这时，客户端发起断开连接的请求：</p>
<ol>
<li><p>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入<code>FIN_WAIT_1</code>状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p>
</li>
<li><p>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入<code>CLOSE_WAIT</code>状态。</p>
</li>
</ol>
<p>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p>
<ol start="3">
<li><p>客户端收到“确认包”后进入<code>FIN_WAIT_2</code>状态，等待服务器准备完毕后再次发送数据包。</p>
</li>
<li><p>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入<code>LAST_ACK</code>状态。</p>
</li>
<li><p>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入<code>TIME_WAIT</code>状态。</p>
</li>
<li><p>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入<code>CLOSED</code>状态。</p>
</li>
</ol>
<h2 id="关于-TIME-WAIT-状态的说明"><a href="#关于-TIME-WAIT-状态的说明" class="headerlink" title="关于 TIME_WAIT 状态的说明"></a>关于 TIME_WAIT 状态的说明</h2><p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p>
<p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p>
<p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，&#x3D;&#x3D;服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。&#x3D;&#x3D;那么，要等待多久呢？</p>
<p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为&#x3D;&#x3D;报文最大生存时间（MSL，Maximum Segment Lifetime）&#x3D;&#x3D;。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，&#x3D;&#x3D;2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。&#x3D;&#x3D;</p>
<h1 id="shutdown-函数：优雅地断开TCP连接"><a href="#shutdown-函数：优雅地断开TCP连接" class="headerlink" title="shutdown()函数：优雅地断开TCP连接"></a>shutdown()函数：优雅地断开TCP连接</h1><p>调用 close()&#x2F;close<a target="_blank" rel="noopener" href="http://c.biancheng.net/socket/">socket</a>() 函数意味着完全断开连接，即不能发送数据也不能接收数据，这种“生硬”的方式有时候会显得不太“优雅”。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190219/1350141P8-0.jpg" alt="close()/closesocket() 断开连接"><br>图1：close()&#x2F;closesocket() 断开连接</p>
<p>上图演示了两台正在进行双向通信的主机。主机A发送完数据后，单方面调用 close()&#x2F;closesocket() 断开连接，之后主机A、B都不能再接受对方传输的数据。实际上，是完全无法调用与数据收发有关的函数。</p>
<p>一般情况下这不会有问题，但有些特殊时刻，需要只断开一条数据传输通道，而保留另一条。</p>
<p>使用 shutdown() 函数可以达到这个目的，它的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span></span>; <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(SOCKET s, <span class="type">int</span> howto)</span></span>; <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>sock 为需要断开的套接字，howto 为断开方式。</p>
<p>howto 在 Linux 下有以下取值：</p>
<ul>
<li>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。</li>
<li>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。</li>
<li>SHUT_RDWR：同时断开 I&#x2F;O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。</li>
</ul>
<p>howto 在 Windows 下有以下取值：</p>
<ul>
<li>SD_RECEIVE：关闭接收操作，也就是断开输入流。</li>
<li>SD_SEND：关闭发送操作，也就是断开输出流。</li>
<li>SD_BOTH：同时关闭接收和发送操作。</li>
</ul>
<p>至于什么时候需要调用 shutdown() 函数，下节我们会以文件传输为例进行讲解。</p>
<p><strong>close()&#x2F;closesocket()和shutdown()的区别</strong></p>
<p>确切地说，close() &#x2F; closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/">C语言</a>中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p>
<p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</p>
<p>调用 close()&#x2F;closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p>
<p>默认情况下，close()&#x2F;closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()&#x2F;closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。</p>
<h1 id="再谈UDP和TCP"><a href="#再谈UDP和TCP" class="headerlink" title="再谈UDP和TCP"></a>再谈UDP和TCP</h1><p>TCP 是面向连接的传输协议，建立连接时要经过三次握手，断开连接时要经过四次握手，中间传输数据时也要回复 ACK 包确认，多种机制保证了数据能够正确到达，不会丢失或出错。</p>
<p>UDP 是非连接的传输协议，没有建立连接和断开连接的过程，它只是简单地把数据丢到网络中，也不需要 ACK 包确认。</p>
<p>UDP 传输数据就好像我们邮寄包裹，邮寄前需要填好寄件人和收件人地址，之后送到快递公司即可，但包裹是否正确送达、是否损坏我们无法得知，也无法保证。UDP 协议也是如此，它只管把数据包发送到网络，然后就不管了，如果数据丢失或损坏，发送端是无法知道的，当然也不会重发。</p>
<p>既然如此，TCP 应该是更加优质的传输协议吧？</p>
<p>如果只考虑可靠性，TCP 的确比 UDP 好。但 UDP 在结构上比 TCP 更加简洁，不会发送 ACK 的应答消息，也不会给数据包分配 Seq 序号，所以 UDP 的传输效率有时会比 TCP 高出很多，编程中实现 UDP 也比 TCP 简单。</p>
<p>UDP 的可靠性虽然比不上TCP，但也不会像想象中那么频繁地发生数据损毁，在更加重视传输效率而非可靠性的情况下，UDP 是一种很好的选择。比如视频通信或音频通信，就非常适合采用 UDP 协议；通信时数据必须高效传输才不会产生“卡顿”现象，用户体验才更加流畅，如果丢失几个数据包，视频画面可能会出现“雪花”，音频可能会夹带一些杂音，这些都是无妨的。</p>
<p>与 UDP 相比，TCP 的生命在于流控制，这保证了数据传输的正确性。</p>
<p>最后需要说明的是：TCP 的速度无法超越 UDP，但在收发某些类型的数据时有可能接近 UDP。例如，每次交换的数据量越大，TCP 的传输速率就越接近于 UDP。</p>
<h1 id="基于UDP的服务器端和客户端"><a href="#基于UDP的服务器端和客户端" class="headerlink" title="基于UDP的服务器端和客户端"></a>基于UDP的服务器端和客户端</h1><h2 id="UDP中的服务器端和客户端没有连接"><a href="#UDP中的服务器端和客户端没有连接" class="headerlink" title="UDP中的服务器端和客户端没有连接"></a>UDP中的服务器端和客户端没有连接</h2><p>UDP 不像 TCP，无需在连接状态下交换数据，因此基于 UDP 的服务器端和客户端也无需经过连接过程。也就是说，不必调用 listen() 和 accept() 函数。UDP 中只有创建套接字的过程和数据交换的过程。</p>
<h2 id="UDP服务器端和客户端均只需1个套接字"><a href="#UDP服务器端和客户端均只需1个套接字" class="headerlink" title="UDP服务器端和客户端均只需1个套接字"></a>UDP服务器端和客户端均只需1个套接字</h2><p>TCP 中，套接字是一对一的关系。如要向 10 个客户端提供服务，那么除了负责监听的套接字外，还需要创建 10 套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。之前解释 UDP 原理的时候举了邮寄包裹的例子，负责邮寄包裹的快递公司可以比喻为 UDP 套接字，只要有 1 个快递公司，就可以通过它向任意地址邮寄包裹。同样，只需 1 个 UDP 套接字就可以向任意主机传送数据。</p>
<h2 id="基于UDP的接收和发送函数"><a href="#基于UDP的接收和发送函数" class="headerlink" title="基于UDP的接收和发送函数"></a>基于UDP的接收和发送函数</h2><p>创建好 TCP 套接字后，传输数据时无需再添加地址信息，因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态，每次传输数据都要添加目标地址信息，这相当于在邮寄包裹前填写收件人地址。</p>
<p>发送数据使用 sendto() 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linuxint </span></span><br><span class="line"><span class="built_in">sendto</span>(SOCKET sock, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> nbytes, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockadr *to, <span class="type">int</span> addrlen);  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>Linux 和 Windows 下的 sendto() 函数类似，下面是详细参数说明：</p>
<ul>
<li>sock：用于传输 UDP 数据的套接字；</li>
<li>buf：保存待传输数据的缓冲区地址；</li>
<li>nbytes：带传输数据的长度（以字节计）；</li>
<li>flags：可选项参数，若没有可传递 0；</li>
<li>to：存有目标地址信息的 sockaddr 结构体变量的地址；</li>
<li>addrlen：传递给参数 to 的地址值结构体变量的长度。</li>
</ul>
<p>UDP 发送函数 sendto() 与TCP发送函数 write()&#x2F;send() 的最大区别在于，sendto() 函数需要向他传递目标地址信息。</p>
<p>接收数据使用 recvfrom() 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockadr *from, <span class="type">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recvfrom</span><span class="params">(SOCKET sock, <span class="type">char</span> *buf, <span class="type">int</span> nbytes, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *from, <span class="type">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure>

<p>由于 UDP 数据的发送端不定，所以 recvfrom() 函数定义为可接收发送端信息的形式，具体参数如下：</p>
<ul>
<li>sock：用于接收 UDP 数据的套接字；</li>
<li>buf：保存接收数据的缓冲区地址；</li>
<li>nbytes：可接收的最大字节数（不能超过 buf 缓冲区的大小）；</li>
<li>flags：可选项参数，若没有可传递 0；</li>
<li>from：存有发送端地址信息的 sockaddr 结构体变量的地址；</li>
<li>addrlen：保存参数 from 的结构体变量长度的变量地址值。</li>
</ul>
<h2 id="基于UDP的回声服务器端-客户端"><a href="#基于UDP的回声服务器端-客户端" class="headerlink" title="基于UDP的回声服务器端&#x2F;客户端"></a>基于UDP的回声服务器端&#x2F;客户端</h2><p>下面结合之前的内容实现回声客户端。需要注意的是，UDP 不同于 TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端，只是因为其提供服务而称为服务器端，希望各位读者不要误解。</p>
<p>下面给出 Windows 下的代码，Linux 与此类似，不再赘述。</p>
<p>服务器端 server.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    servAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//自动获取IP地址</span></span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(sock, (SOCKADDR*)&amp;servAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;  <span class="comment">//客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];  <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> strLen = <span class="built_in">recvfrom</span>(sock, buffer, BUF_SIZE, <span class="number">0</span>, &amp;clntAddr, &amp;nSize);</span><br><span class="line">        <span class="built_in">sendto</span>(sock, buffer, strLen, <span class="number">0</span>, &amp;clntAddr, nSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li><p>第 12 行代码在创建套接字时，向 socket() 第二个参数传递 SOCK_DGRAM，以指明使用 UDP 协议。</p>
</li>
<li><p>第 18 行代码中使用<code>htonl(INADDR_ANY)</code>来自动获取 IP 地址。</p>
</li>
</ol>
<p>利用常数 INADDR_ANY 自动获取 IP 地址有一个明显的好处，就是当软件安装到其他服务器或者服务器 IP 地址改变时，不用再更改源码重新编译，也不用在启动软件时手动输入。而且，如果一台计算机中已分配多个 IP 地址（例如路由器），那么只要端口号一致，就可以从不同的 IP 地址接收数据。所以，服务器中优先考虑使用 INADDR_ANY；而客户端中除非带有一部分服务器功能，否则不会采用。</p>
<p>客户端 client.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    servAddr.sin_family = PF_INET;</span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断获取用户输入并发送给服务器，然后接受服务器数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span> fromAddr;</span><br><span class="line">    <span class="type">int</span> addrLen = <span class="built_in">sizeof</span>(fromAddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">        <span class="built_in">gets</span>(buffer);</span><br><span class="line">        <span class="built_in">sendto</span>(sock, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servAddr, <span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">        <span class="type">int</span> strLen = <span class="built_in">recvfrom</span>(sock, buffer, BUF_SIZE, <span class="number">0</span>, &amp;fromAddr, &amp;addrLen);</span><br><span class="line">        buffer[strLen] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行 server，再运行 client，client 输出结果为：</p>
<p>Input a string: C语言中文网<br>Message form server: C语言中文网<br>Input a string: c.biancheng.net Founded in 2012<br>Message form server: c.biancheng.net Founded in 2012<br>Input a string:</p>
<p>从代码中可以看出，server.cpp 中没有使用 listen() 函数，client.cpp 中也没有使用 connect() 函数，因为 UDP 不需要连接。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Fengzi7.magicalroom.com">封子期</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fengzi7.magicalroom.com/2024/03/18/socket/">https://fengzi7.magicalroom.com/2024/03/18/socket/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Fengzi7.magicalroom.com" target="_blank">Fengzi7的奇妙空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/18/stl/" title="STL"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STL</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++多线程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/boqi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">封子期</div><div class="author-info__description">这个人很懒，请出门左转</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A5%97%E6%8E%A5%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">socket是什么？套接字是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-socket%EF%BC%9F"><span class="toc-text">什么是 socket？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNIX-Linux-%E4%B8%AD%E7%9A%84-socket-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">UNIX&#x2F;Linux 中的 socket 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-socket-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Window 系统中的 socket 是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9Fsocket%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">套接字有哪些类型？socket有哪些类型？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%A0%BC%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88SOCK-STREAM%EF%BC%89"><span class="toc-text">流格式套接字（SOCK_STREAM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88SOCK-DGRAM%EF%BC%89"><span class="toc-text">数据报格式套接字（SOCK_DGRAM）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">面向连接和无连接的套接字到底有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">无连接的套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">面向连接的套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OSI%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B"><span class="toc-text">OSI网络七层模型简明教程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-text">TCP&#x2F;IP协议族</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IP%E3%80%81MAC%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%A1%AE%E8%AE%A4%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-text">IP、MAC和端口号——网络通信中确认身份信息的三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84socket%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F"><span class="toc-text">Linux下的socket演示程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E4%B8%8B%E7%BB%88%E7%AB%AFg-%E6%89%A7%E8%A1%8Csocket%E9%9C%80%E8%A6%81%E5%B8%A6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%90%8E%E7%BC%80-lws2-32"><span class="toc-text">&#x3D;&#x3D;Windows下终端g++执行socket需要带动态链接库后缀        -lws2_32&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E4%B8%8B%E7%9A%84socket%E6%BC%94%E7%A4%BA%E7%A8%8B%E5%BA%8F"><span class="toc-text">Windows下的socket演示程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E4%B8%8B%E4%BD%BF%E7%94%A8WSAStartup-%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDDLL"><span class="toc-text">Windows下使用WSAStartup()函数加载DLL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WSAStartup-%E5%87%BD%E6%95%B0"><span class="toc-text">WSAStartup() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">socket()函数用法详解：创建套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E4%B8%8B%E7%9A%84-socket-%E5%87%BD%E6%95%B0"><span class="toc-text">Linux 下的 socket() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Windows%E4%B8%8B%E5%88%9B%E5%BB%BAsocket"><span class="toc-text">在Windows下创建socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bind-%E5%92%8Cconnect-%E5%87%BD%E6%95%B0%EF%BC%9A%E7%BB%91%E5%AE%9A%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B9%B6%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-text">bind()和connect()函数：绑定套接字并建立连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-%E5%87%BD%E6%95%B0"><span class="toc-text">bind() 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sockaddr-in-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">sockaddr_in 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-addr-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">in_addr 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-sockaddr-in-%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8-sockaddr"><span class="toc-text">为什么使用 sockaddr_in 而不使用 sockaddr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#connect-%E5%87%BD%E6%95%B0"><span class="toc-text">connect() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#listen-%E5%92%8Caccept-%E5%87%BD%E6%95%B0%EF%BC%9A%E8%AE%A9%E5%A5%97%E6%8E%A5%E5%AD%97%E8%BF%9B%E5%85%A5%E7%9B%91%E5%90%AC%E7%8A%B6%E6%80%81%E5%B9%B6%E5%93%8D%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-text">listen()和accept()函数：让套接字进入监听状态并响应客户端请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#listen-%E5%87%BD%E6%95%B0"><span class="toc-text">listen() 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97"><span class="toc-text">请求队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#accept-%E5%87%BD%E6%95%B0"><span class="toc-text">accept() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#send-recv-%E5%92%8Cwrite-read-%EF%BC%9A%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-text">send()&#x2F;recv()和write()&#x2F;read()：发送数据和接收数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-text">Linux下数据的接收和发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E4%B8%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-text">Windows下数据的接收和发送</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%A5%E5%8F%8A%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-text">socket缓冲区以及阻塞模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">socket缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-text">阻塞模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E8%BE%B9%E7%95%8C%E6%80%A7%EF%BC%89"><span class="toc-text">TCP协议的粘包问题（数据的无边界性）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-text">图解TCP数据报结构以及三次握手（非常详细）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84"><span class="toc-text">TCP数据报结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="toc-text">连接的建立（三次握手）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">最后的说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90TCP%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-text">详细分析TCP数据的传输过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%EF%BC%88RTO-Retransmission-Time-Out%EF%BC%89"><span class="toc-text">重传超时时间（RTO, Retransmission Time Out）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%AC%A1%E6%95%B0"><span class="toc-text">重传次数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3TCP%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-text">图解TCP四次握手断开连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">关于 TIME_WAIT 状态的说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shutdown-%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BC%98%E9%9B%85%E5%9C%B0%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">shutdown()函数：优雅地断开TCP连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E8%B0%88UDP%E5%92%8CTCP"><span class="toc-text">再谈UDP和TCP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">基于UDP的服务器端和客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E8%BF%9E%E6%8E%A5"><span class="toc-text">UDP中的服务器端和客户端没有连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9D%87%E5%8F%AA%E9%9C%801%E4%B8%AA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">UDP服务器端和客户端均只需1个套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">基于UDP的接收和发送函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%9B%9E%E5%A3%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">基于UDP的回声服务器端&#x2F;客户端</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" title="无题"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/03/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" title="无题">无题</a><time datetime="2024-03-26T09:30:04.592Z" title="发表于 2024-03-26 17:30:04">2024-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/21/C++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" title="C++常见函数"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++常见函数"/></a><div class="content"><a class="title" href="/2024/03/21/C++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" title="C++常见函数">C++常见函数</a><time datetime="2024-03-21T02:05:51.254Z" title="发表于 2024-03-21 10:05:51">2024-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="STL查漏补缺"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL查漏补缺"/></a><div class="content"><a class="title" href="/2024/03/20/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="STL查漏补缺">STL查漏补缺</a><time datetime="2024-03-20T03:49:28.924Z" title="发表于 2024-03-20 11:49:28">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/stl/" title="STL"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL"/></a><div class="content"><a class="title" href="/2024/03/18/stl/" title="STL">STL</a><time datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/socket/" title="socket"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="socket"/></a><div class="content"><a class="title" href="/2024/03/18/socket/" title="socket">socket</a><time datetime="2024-03-18T06:45:14.362Z" title="发表于 2024-03-18 14:45:14">2024-03-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 封子期</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1957725779" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>