<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Fengzi7的奇妙空间 | Fengzi7的奇妙空间</title><meta name="author" content="封子期"><meta name="copyright" content="封子期"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:type" content="article">
<meta property="og:title" content="Fengzi7的奇妙空间">
<meta property="og:url" content="https://fengzi7.magicalroom.com/2024/03/18/stl/index.html">
<meta property="og:site_name" content="Fengzi7的奇妙空间">
<meta property="og:description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.bing.com/images/search?view=detailV2&ccid=kPPTkJNR&id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&exph=2160&expw=3840&q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&simid=608003546881291737&FORM=IRPRST&ck=1F00BD2D7089875D5241D7C9F0EA63E5&selectedIndex=47&itb=0">
<meta property="article:published_time" content="2024-03-18T13:46:47.366Z">
<meta property="article:modified_time" content="2024-03-18T14:50:11.366Z">
<meta property="article:author" content="封子期">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.bing.com/images/search?view=detailV2&ccid=kPPTkJNR&id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&exph=2160&expw=3840&q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&simid=608003546881291737&FORM=IRPRST&ck=1F00BD2D7089875D5241D7C9F0EA63E5&selectedIndex=47&itb=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fengzi7.magicalroom.com/2024/03/18/stl/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Fengzi7的奇妙空间',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-18 22:50:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/background.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://www.bing.com/images/search?q=%E5%A0%80%E4%B8%8E%E5%AE%AB%E6%9D%91%E7%9A%84%E5%A4%B4%E5%83%8F&amp;FORM=IQFRBA&amp;id=6D5841ACED25074E8D26C74E72615F8BAEB23D42" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.bing.com/images/search?view=detailV2&amp;ccid=kPPTkJNR&amp;id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&amp;thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&amp;mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&amp;exph=2160&amp;expw=3840&amp;q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&amp;simid=608003546881291737&amp;FORM=IRPRST&amp;ck=1F00BD2D7089875D5241D7C9F0EA63E5&amp;selectedIndex=47&amp;itb=0')"><nav id="nav"><span id="blog-info"><a href="/" title="Fengzi7的奇妙空间"><span class="site-name">Fengzi7的奇妙空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-18T14:50:11.366Z" title="更新于 2024-03-18 22:50:11">2024-03-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a>STL基础</h1><h2 id="C-STL是什么，有什么用？"><a href="#C-STL是什么，有什么用？" class="headerlink" title="C++ STL是什么，有什么用？"></a>C++ STL是什么，有什么用？</h2><p>在已有 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？</p>
<p>STL，英文全称 s<a target="_blank" rel="noopener" href="https://c.biancheng.net/ref/tan.html">tan</a>dard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p>
<p><code>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</code></p>
<p>根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p>
<h2 id="C-STL要学哪些知识"><a href="#C-STL要学哪些知识" class="headerlink" title="C++STL要学哪些知识"></a>C++STL要学哪些知识</h2><p>&#x3D;&#x3D;<strong>C++ STL基本组成（6大组件+13个头文件）</strong>&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>STL的组成</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>一些封装<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td>算法</td>
<td>STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。</td>
</tr>
<tr>
<td>迭代器</td>
<td>在 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td>函数对象</td>
<td>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td>适配器</td>
<td>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td>
</tr>
<tr>
<td>内存分配器</td>
<td>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody></table>
<p>在 C++ 标准中，它们被重新组织为 13 个头文件，如表 2 所示。</p>
<p><img src="C:/Users/fangyong/AppData/Roaming/Typora/typora-user-images/image-20240318220604552.png" alt="image-20240318220604552"></p>
<p>按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 &lt;vector.h&gt; 为有扩展名的形式。</p>
<p>但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件（例如 Visual C++ 支持的 Dinkumware 版本同时具备 &lt;vector.h&gt; 和 <vector>）；甚至有些 STL 版本同时拥有 3 种形式的头文件（例如 SGI 版本同时拥有 <vector>、&lt;vector.h&gt; 和 &lt;stl_vector.h&gt;）；但也有个别的 STL 版本只存在包含扩展名的头文件（例如 C++ Builder 的 RaugeWare 版本只有 &lt;vector.h&gt;）</p>
<h1 id="STL序列式容器"><a href="#STL序列式容器" class="headerlink" title="STL序列式容器"></a>STL序列式容器</h1><h2 id="C-STL容器是什么？"><a href="#C-STL容器是什么？" class="headerlink" title="C++ STL容器是什么？"></a>C++ STL容器是什么？</h2><p>&#x3D;&#x3D;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&#x3D;&#x3D;STL 提供有 3 类标准容器，分别是<strong>序列容器、排序容器和哈希容器</strong>，其中后两类容器有时也统称为&#x3D;&#x3D;关联容器&#x3D;&#x3D;。</p>
<p>它们各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>容器种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>序列容器</td>
<td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td>
</tr>
<tr>
<td>排序容器</td>
<td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td>
</tr>
<tr>
<td>哈希容器</td>
<td><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td>
</tr>
</tbody></table>
<h2 id="迭代器是什么，C-STL迭代器（iterator）用法详解"><a href="#迭代器是什么，C-STL迭代器（iterator）用法详解" class="headerlink" title="迭代器是什么，C++ STL迭代器（iterator）用法详解"></a>迭代器是什么，C++ STL迭代器（iterator）用法详解</h2><p>无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p>
<p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p>
<p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p>
<p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读&#x2F;写操作。</p>
<h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。</p>
<p><code>容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</code></p>
<p>常用的迭代器按功能强弱分为**输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 **5 种。本节主要介绍后面的这 3 种迭代器</p>
<p><code>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。</code></p>
<ol>
<li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p>
</li>
<li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p>
</li>
<li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
</li>
</ol>
<ul>
<li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li>
<li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
<p>C++ 11 标准中不同容器指定使用的迭代器类型。<br>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set &#x2F; multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map &#x2F; multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map &#x2F; unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set &#x2F; unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>容器类名::iterator 迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator 迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator 迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator 迭代器名;</td>
</tr>
</tbody></table>
<p>通过定义以上几种迭代器，就可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<p>注意，&#x3D;&#x3D;以上 4 种定义迭代器的方式，并不是每个容器都适用&#x3D;&#x3D;。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p>
<p>vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历 vector 容器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 vector 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="comment">//创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第二种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第三种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第四种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第二种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第三种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第四种遍历方法：</span></span><br><span class="line"><span class="comment">1 3 5 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>

<p>以下代码是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下代码则不合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用“&lt;”进行比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i];</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用下标随机访问元素：</span></span><br></pre></td></tr></table></figure>

<h2 id="C-序列式容器（STL序列式容器）是什么"><a href="#C-序列式容器（STL序列式容器）是什么" class="headerlink" title="C++序列式容器（STL序列式容器）是什么"></a>C++序列式容器（STL序列式容器）是什么</h2><p>所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p>
<p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p>
<ul>
<li>**array&lt;T,N&gt;**（数组容器）：表示可以存储 N 个 T 类型的元素，是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li>
<li><strong>vector<T>（向量容器）</strong>：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li>
<li><strong>deque<T>（双端队列容器）</strong>：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li>
<li><strong>list<T>（链表容器）</strong>：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li>
<li>**forward_list<T>**（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li>
</ul>
<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911110REB.jpg" alt="img"></p>
<h3 id="容器中常见的函数成员"><a href="#容器中常见的函数成员" class="headerlink" title="容器中常见的函数成员"></a>容器中常见的函数成员</h3><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>array&lt;T,N&gt;</th>
<th>vector<T></th>
<th>deque<T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
<td>-</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator<a href=""></a></td>
<td>使用索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检査的索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。</td>
<td>是</td>
<td>是</td>
<td>-</td>
</tr>
</tbody></table>
<p>list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>list<T></th>
<th>forward_list<T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>before_begin()</td>
<td>返回指向第一个元素前一个位置的迭代器。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的引用。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的引用。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的起始位置添加一个元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定位置直接生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置的后面直接生成一个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cmplacc_front()</td>
<td>在序列的起始位生成一个元索。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置的后面插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除序列尾部的元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除序列头部的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中某一段的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移除指定位置的一个元素或一段元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>erase_after()</td>
<td>移除指定位置后面的一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>remove()</td>
<td>移除所有和参数匹配的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>remove_if()</td>
<td>移除满足一元函数条件的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>unique()</td>
<td>移除所有连续重复的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的元素，容器大小变为 0。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>sort()</td>
<td>对元素进行排序。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个有序容器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>splice()</td>
<td>移动指定位置前面的所有元素到另一个同类型的 list 中。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>splice_after()</td>
<td>移动指定位置后面的所有元素到另一个同类型的 list 中。</td>
<td>-</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="array-STL-array-容器用法详解"><a href="#array-STL-array-容器用法详解" class="headerlink" title="array(STL array)容器用法详解"></a>array(STL array)容器用法详解</h2><p>array 容器是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p>
<p>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">array</span>;</span><br><span class="line">&#125;</span><br><span class="line">在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure>

<p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p>
<p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911150226392.jpg" alt="初始化array容器"></p>
<p>array 容器还提供有很多功能实用的成员函数</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()&#x3D;&#x3D;0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody></table>
<h3 id="STL-array随机访问迭代器"><a href="#STL-array随机访问迭代器" class="headerlink" title="STL array随机访问迭代器"></a>STL array随机访问迭代器</h3><p>在 array 容器的模板类中，和随机访问迭代器相关的成员函数如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Fengzi7.magicalroom.com">封子期</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fengzi7.magicalroom.com/2024/03/18/stl/">https://fengzi7.magicalroom.com/2024/03/18/stl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Fengzi7.magicalroom.com" target="_blank">Fengzi7的奇妙空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.bing.com/images/search?view=detailV2&amp;ccid=kPPTkJNR&amp;id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&amp;thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&amp;mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&amp;exph=2160&amp;expw=3840&amp;q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&amp;simid=608003546881291737&amp;FORM=IRPRST&amp;ck=1F00BD2D7089875D5241D7C9F0EA63E5&amp;selectedIndex=47&amp;itb=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/03/18/socket/" title="socket"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">socket</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://www.bing.com/images/search?q=%E5%A0%80%E4%B8%8E%E5%AE%AB%E6%9D%91%E7%9A%84%E5%A4%B4%E5%83%8F&amp;FORM=IQFRBA&amp;id=6D5841ACED25074E8D26C74E72615F8BAEB23D42" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">封子期</div><div class="author-info__description">这个人很懒，请出门左转</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%9F%BA%E7%A1%80"><span class="toc-text">STL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">C++ STL是什么，有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E8%A6%81%E5%AD%A6%E5%93%AA%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">C++STL要学哪些知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">C++ STL容器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CC-STL%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">迭代器是什么，C++ STL迭代器（iterator）用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">迭代器类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">迭代器的定义方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">C++序列式容器（STL序列式容器）是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-text">容器中常见的函数成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array-STL-array-%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">array(STL array)容器用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-array%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL array随机访问迭代器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/stl/" title="无题"><img src="https://www.bing.com/images/search?view=detailV2&amp;ccid=kPPTkJNR&amp;id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&amp;thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&amp;mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&amp;exph=2160&amp;expw=3840&amp;q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&amp;simid=608003546881291737&amp;FORM=IRPRST&amp;ck=1F00BD2D7089875D5241D7C9F0EA63E5&amp;selectedIndex=47&amp;itb=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/03/18/stl/" title="无题">无题</a><time datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/socket/" title="socket">socket</a><time datetime="2024-03-18T06:45:14.362Z" title="发表于 2024-03-18 14:45:14">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-03-18T06:45:10.276Z" title="发表于 2024-03-18 14:45:10">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++11新特性">C++11新特性</a><time datetime="2024-03-18T06:45:08.161Z" title="发表于 2024-03-18 14:45:08">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/hello-world/" title="Hello World">Hello World</a><time datetime="2024-03-18T02:45:02.016Z" title="发表于 2024-03-18 10:45:02">2024-03-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.bing.com/images/search?view=detailV2&amp;ccid=kPPTkJNR&amp;id=48EF918074DC9DE9F11534A18735B9AF6E0F51AE&amp;thid=OIP.kPPTkJNRsfLiMfpw2QiYUwHaEK&amp;mediaurl=https%3a%2f%2fimg-baofun.zhhainiao.com%2ffs%2f90f3d3909351b1f2e231fa70d9089853.jpg&amp;exph=2160&amp;expw=3840&amp;q=%e5%8a%a8%e6%bc%ab%e9%a3%8e%e6%99%af%e5%a3%81%e7%ba%b84k&amp;simid=608003546881291737&amp;FORM=IRPRST&amp;ck=1F00BD2D7089875D5241D7C9F0EA63E5&amp;selectedIndex=47&amp;itb=0')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 封子期</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>