<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STL | Fengzi7的奇妙空间</title><meta name="author" content="封子期"><meta name="copyright" content="封子期"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:type" content="article">
<meta property="og:title" content="STL">
<meta property="og:url" content="https://fengzi7.magicalroom.com/2024/03/18/stl/index.html">
<meta property="og:site_name" content="Fengzi7的奇妙空间">
<meta property="og:description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg">
<meta property="article:published_time" content="2024-03-18T13:46:47.366Z">
<meta property="article:modified_time" content="2024-03-19T15:15:13.095Z">
<meta property="article:author" content="封子期">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fengzi7.magicalroom.com/2024/03/18/stl/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-19 23:15:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/boqi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Fengzi7的奇妙空间"><span class="site-name">Fengzi7的奇妙空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-19T15:15:13.095Z" title="更新于 2024-03-19 23:15:13">2024-03-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>141分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a>STL基础</h1><h2 id="C-STL是什么，有什么用？"><a href="#C-STL是什么，有什么用？" class="headerlink" title="C++ STL是什么，有什么用？"></a>C++ STL是什么，有什么用？</h2><p>在已有 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？</p>
<p>STL，英文全称 s<a target="_blank" rel="noopener" href="https://c.biancheng.net/ref/tan.html">tan</a>dard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p>
<p><code>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</code></p>
<p>根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p>
<h2 id="C-STL要学哪些知识"><a href="#C-STL要学哪些知识" class="headerlink" title="C++STL要学哪些知识"></a>C++STL要学哪些知识</h2><p>&#x3D;&#x3D;<strong>C++ STL基本组成（6大组件+13个头文件）</strong>&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>STL的组成</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>一些封装<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td>算法</td>
<td>STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。</numeric></algorithm></td>
</tr>
<tr>
<td>迭代器</td>
<td>在 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td>函数对象</td>
<td>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td>适配器</td>
<td>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td>
</tr>
<tr>
<td>内存分配器</td>
<td>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody></table>
<p>在 C++ 标准中，它们被重新组织为 13 个头文件，如表 2 所示。</p>
<p><img src="/2024/03/18/stl/Users/fangyong/AppData/Roaming/Typora/typora-user-images/image-20240318220604552.png" alt="image-20240318220604552"></p>
<p>按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 &lt;vector.h&gt; 为有扩展名的形式。</vector></p>
<p>但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件（例如 Visual C++ 支持的 Dinkumware 版本同时具备 &lt;vector.h&gt; 和 <vector>）；甚至有些 STL 版本同时拥有 3 种形式的头文件（例如 SGI 版本同时拥有 <vector>、&lt;vector.h&gt; 和 &lt;stl_vector.h&gt;）；但也有个别的 STL 版本只存在包含扩展名的头文件（例如 C++ Builder 的 RaugeWare 版本只有 &lt;vector.h&gt;）</vector></vector></p>
<h1 id="STL序列式容器"><a href="#STL序列式容器" class="headerlink" title="STL序列式容器"></a>STL序列式容器</h1><h2 id="C-STL容器是什么？"><a href="#C-STL容器是什么？" class="headerlink" title="C++ STL容器是什么？"></a>C++ STL容器是什么？</h2><p>&#x3D;&#x3D;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&#x3D;&#x3D;STL 提供有 3 类标准容器，分别是<strong>序列容器、排序容器和哈希容器</strong>，其中后两类容器有时也统称为&#x3D;&#x3D;关联容器&#x3D;&#x3D;。</p>
<p>它们各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>容器种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>序列容器</td>
<td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td>
</tr>
<tr>
<td>排序容器</td>
<td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td>
</tr>
<tr>
<td>哈希容器</td>
<td><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td>
</tr>
</tbody></table>
<h2 id="迭代器是什么，C-STL迭代器（iterator）用法详解"><a href="#迭代器是什么，C-STL迭代器（iterator）用法详解" class="headerlink" title="迭代器是什么，C++ STL迭代器（iterator）用法详解"></a>迭代器是什么，C++ STL迭代器（iterator）用法详解</h2><p>无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p>
<p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p>
<p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p>
<p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读&#x2F;写操作。</p>
<h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。</p>
<p><code>容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</code></p>
<p>常用的迭代器按功能强弱分为**输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 **5 种。本节主要介绍后面的这 3 种迭代器</p>
<p><code>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。</code></p>
<ol>
<li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p>
</li>
<li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p>
</li>
<li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
</li>
</ol>
<ul>
<li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li>
<li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
<p>C++ 11 标准中不同容器指定使用的迭代器类型。<br>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set &#x2F; multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map &#x2F; multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map &#x2F; unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set &#x2F; unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>容器类名::iterator 迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator 迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator 迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator 迭代器名;</td>
</tr>
</tbody></table>
<p>通过定义以上几种迭代器，就可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<p>注意，&#x3D;&#x3D;以上 4 种定义迭代器的方式，并不是每个容器都适用&#x3D;&#x3D;。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p>
<p>vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历 vector 容器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 vector 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="comment">//创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第二种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第三种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第四种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第二种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第三种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第四种遍历方法：</span></span><br><span class="line"><span class="comment">1 3 5 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>

<p>以下代码是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下代码则不合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用“&lt;”进行比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i];</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用下标随机访问元素：</span></span><br></pre></td></tr></table></figure>

<h2 id="C-序列式容器（STL序列式容器）是什么"><a href="#C-序列式容器（STL序列式容器）是什么" class="headerlink" title="C++序列式容器（STL序列式容器）是什么"></a>C++序列式容器（STL序列式容器）是什么</h2><p>所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p>
<p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p>
<ul>
<li>**array&lt;T,N&gt;**（数组容器）：表示可以存储 N 个 T 类型的元素，是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li>
<li><strong>vector<T>（向量容器）</T></strong>：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li>
<li><strong>deque<T>（双端队列容器）</T></strong>：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li>
<li><strong>list<T>（链表容器）</T></strong>：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</T></li>
<li>**forward_list<T>**（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</T></li>
</ul>
<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911110REB.jpg" alt="img"></p>
<h3 id="容器中常见的函数成员"><a href="#容器中常见的函数成员" class="headerlink" title="容器中常见的函数成员"></a>容器中常见的函数成员</h3><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>array&lt;T,N&gt;</th>
<th>vector<T></T></th>
<th>deque<T></T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
<td>-</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator<a href></a></td>
<td>使用索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检査的索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。</td>
<td>是</td>
<td>是</td>
<td>-</td>
</tr>
</tbody></table>
<p>list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>list<T></T></th>
<th>forward_list<T></T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>before_begin()</td>
<td>返回指向第一个元素前一个位置的迭代器。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的引用。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的引用。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的起始位置添加一个元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定位置直接生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置的后面直接生成一个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cmplacc_front()</td>
<td>在序列的起始位生成一个元索。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置的后面插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除序列尾部的元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除序列头部的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中某一段的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移除指定位置的一个元素或一段元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>erase_after()</td>
<td>移除指定位置后面的一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>remove()</td>
<td>移除所有和参数匹配的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>remove_if()</td>
<td>移除满足一元函数条件的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>unique()</td>
<td>移除所有连续重复的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的元素，容器大小变为 0。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>sort()</td>
<td>对元素进行排序。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个有序容器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>splice()</td>
<td>移动指定位置前面的所有元素到另一个同类型的 list 中。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>splice_after()</td>
<td>移动指定位置后面的所有元素到另一个同类型的 list 中。</td>
<td>-</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="array-STL-array-容器用法详解"><a href="#array-STL-array-容器用法详解" class="headerlink" title="array(STL array)容器用法详解"></a>array(STL array)容器用法详解</h2><p>array 容器是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p>
<p>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中</array></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">array</span>;</span><br><span class="line">&#125;</span><br><span class="line">在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure>

<p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p>
<p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911150226392.jpg" alt="初始化array容器"></p>
<p>array 容器还提供有很多功能实用的成员函数</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()&#x3D;&#x3D;0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody></table>
<h3 id="STL-array随机访问迭代器"><a href="#STL-array随机访问迭代器" class="headerlink" title="STL array随机访问迭代器"></a>STL array随机访问迭代器</h3><p>在 array 容器的模板类中，和随机访问迭代器相关的成员函数如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="迭代器的具体功能示意图"></p>
<p>它们的功能并结合实际场景的需要，这些成员函数通常是成对使用的，即 begin()&#x2F;end()、rbegin()&#x2F;rend()、cbegin()&#x2F;cend()、crbegin()&#x2F;crend() 各自成对搭配使用。不仅如此，这 4 对中 begin()&#x2F;end() 和 cbegin()&#x2F;cend()、rbegin()&#x2F;rend() 和 crbegin()&#x2F;crend() 的功能大致是相同的（如图 2 所示），唯一的区别就在于其返回的迭代器能否用来修改元素值。</p>
<h4 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()&#x2F;end() 和 cbegin()&#x2F;cend()"></a>begin()&#x2F;end() 和 cbegin()&#x2F;cend()</h4><p>begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p>当操作对象为 array 容器时，它们和 begin()&#x2F;end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure>

<p>array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()&#x2F;end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">cend</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">//*first = 10;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="array容器访问元素的几种方式"><a href="#array容器访问元素的几种方式" class="headerlink" title="array容器访问元素的几种方式"></a>array容器访问元素的几种方式</h2><h3 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h3><p>使用下标寻址符&#x3D;&#x3D;[]&#x3D;&#x3D;,但是可能越界访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>为了避免越界访问，可以使用array的成员函数at()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values.<span class="built_in">at</span> (<span class="number">4</span>) = values.<span class="built_in">at</span>(<span class="number">3</span>) + <span class="number">2.</span>O*values.<span class="built_in">at</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p>
<p>array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 5&gt; words&#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; endl; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; //越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。通过该指针，我们可以获得容器中的各个元素，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; *( words.<span class="built_in">data</span>()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h3><p>我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p>
<p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.<span class="built_in">empty</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has no elements.\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has &quot;</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;elements.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如何获取 array 容器中元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values1;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; values1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.<span class="built_in">at</span>(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="type">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.<span class="built_in">begin</span>(); i &lt; values1.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.<span class="built_in">begin</span>(); i &lt; values2.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.  初始化列表"></a>1.  初始化列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 需注意，C++ 中 vector 即是本文描述的 nums</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1;</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h4><p>本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> num = nums[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3.  插入与删除元素"></a>3.  插入与删除元素</h4><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">nums.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>);      <span class="comment">// 删除索引 3 处的元素</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>(),num.<span class="built_in">begin</span>()+<span class="number">2</span>);<span class="comment">//删除索引0-2区间内的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="4-遍历列表"><a href="#4-遍历列表" class="headerlink" title="4.  遍历列表"></a>4.  遍历列表</h4><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    count += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5.  拼接列表"></a>5.  拼接列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// 将列表 nums1 拼接到 nums 之后</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.  排序列表"></a>6.  排序列表</h4><p>完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure>

<h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。</p>
<p>为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。</p>
<ul>
<li><strong>初始容量</strong>：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。</li>
<li><strong>数量记录</strong>：声明一个变量 <code>size</code> ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li>
<li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *arr;             <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> arrCapacity = <span class="number">10</span>; <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> arrSize = <span class="number">0</span>;      <span class="comment">// 列表长度（当前元素数量）</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>;   <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">MyList</span>() &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[arrCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">MyList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引如果越界，则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        arr[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        arr[<span class="built_in">size</span>()] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= index; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = arr[index];</span><br><span class="line">        <span class="comment">// 将索引 index 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = index; j &lt; <span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize--;</span><br><span class="line">        <span class="comment">// 返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extendCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个长度为原数组 extendRatio 倍的新数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">capacity</span>() * extendRatio;</span><br><span class="line">        <span class="type">int</span> *tmp = arr;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">        <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            arr[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        arrCapacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为 Vector 用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="vector添加元素（push-back-和emplace-back-）详解"><a href="#vector添加元素（push-back-和emplace-back-）详解" class="headerlink" title="vector添加元素（push_back()和emplace_back()）详解"></a>vector添加元素（push_back()和emplace_back()）详解</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p>
<p>emplace_back() 成员函数的用法也很简单，这里直接举个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</p>
<p><strong>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；</strong></p>
<p><strong>而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果为：</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用拷贝构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</code></p>
<h3 id="insert-和emplace-详解"><a href="#insert-和emplace-详解" class="headerlink" title="insert()和emplace()详解"></a>insert()和emplace()详解</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p>
<p><strong><code>再次强调，emplace() 每次只能插入一个元素，而不是多个。</code></strong></p>
<p>该函数的语法格式如下：</p>
<p><code>iterator emplace (const_iterator pos, args...);</code></p>
<p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p>
<p><code>简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure>

<p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.<span class="built_in">insert</span>(demo2.<span class="built_in">begin</span>(), <span class="built_in">testDemo</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;移动构造函数看另一个C++11新特性里的右值引用部分&#x3D;&#x3D;</p>
<hr>
<h3 id="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"><a href="#vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）" class="headerlink" title="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"></a>vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）</h3><h4 id="1、vector数据结构性质"><a href="#1、vector数据结构性质" class="headerlink" title="1、vector数据结构性质"></a>1、vector数据结构性质</h4><p>vector占用一块连续分配的内存，一种可以存储任意类型的动态数组，与array不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</p>
<p>vector数据结构如下，通过三个迭代器start, finish, end_of_storage的系列public接口，可很好地完成数据存储、溢出判断(iter &gt;&#x3D; iv.end())、大小、容量(容量与大小不等，以免不断申请空间耗费资源)、重载操作符[]、判空、最前元素、最后元素等等。<br><img src="https://img-blog.csdnimg.cn/20200822120935792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pNVzE0MDc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">iterator start;               <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line"> iterator finish;              <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage;      <span class="comment">// 表示实际分配内存空间的尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;扩容条件&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size==capacity;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - size:实际所包含的元素个数 </span></span><br><span class="line"><span class="comment"> - capacity:容器的容量,指的是在不分配更多内存的情况下，容器可以保存的最多元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200822120916871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pNVzE0MDc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>vector 容器扩容的整个过程，大致分为以下 4 个步骤：</p>
<p>1、分配一块大小是当前 vector 容量几倍的新存储空间。注意，多数 STL 版本中的 vector 容器，其容器都会以 2<br>的倍数增长，也就是说，每次 vector 容器扩容，它们的容量都会提高到之前的 2 倍；<br>2、将 vector 容器存储的所有元素，依照原有次序从旧的存储空间复制到新的存储空间中；<br>3、析构掉旧存储空间中存储的所有元素；<br>4、释放旧的存储空间。<br>通过以上分析不难看出，vector 容器的扩容过程是非常耗时的，并且当容器进行扩容后，之前和该容器相关的所有指针、迭代器以及引用都会失效。因此在使用 vector 容器过程中，我们应尽量避免执行不必要的扩容操作。</p>
<hr>
<h4 id="2、push-back后iterator失效程序崩溃的原因"><a href="#2、push-back后iterator失效程序崩溃的原因" class="headerlink" title="2、push_back后iterator失效程序崩溃的原因"></a>2、push_back后iterator失效程序崩溃的原因</h4><p>在使用push_back对vector进行构造的时候，vector的容量capacity(与size有区别)会根据压入元素的数量进行内存的自动重新分配，这时候iterator会因为vector存储空间的变化而失效，需要注意iterator的有效性，以免iterator指向未知的内存空间导致程序异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用for进行vector的push_back之后，初始化了一个iterator指向vecInt的begin位置，并打印验证。之后再用push_back在vector的末尾添加了一个元素123，这时候用iter来遍历vecInt。</p>
<p>&#x3D;&#x3D;下面对MAX_NUM进行修改，将其改为8&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8	<span class="comment">//MAX_NUM修改为8，其余地方不做任何修改</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只修改MAX_NUM的值，其他地方保留和code2一样，再次运行的时候，程序崩溃了！</p>
<p>对于vector来说，和数组最大的区别之一，就是不需要在初始化的时候声明vector的大小。如果初始化的时候没有指明vector的大小，那么会根据实际的使用情况，在内存中为vector分配的大小分别 2 -&gt; 4 -&gt; 8 -&gt; 16 … 。<br>MAX_NUM是8，所以在for进行push_back之后，vecInt在内存中的大小为8。 对vecInt再次将元素123进行push_back的时候，新的vector大小将超过当前的vector大小，所以会自动重新分配存储空间。<br>由于vector的存储空间已经被重新分配，在push_back(123)之后，iter自然也就会指向一个未知的空间。所以会导致程序异常。<br>&#x3D;&#x3D;可以使用capacity()验证&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	先注释掉会崩溃的代码</span></span><br><span class="line"><span class="comment">//	while(iter != vecInt.end())&#123;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//		iter++;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity:8</span></span><br><span class="line"><span class="comment">the lst element:0</span></span><br><span class="line"><span class="comment">capacity:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3、reserve（）避免多次不必要的扩容"><a href="#3、reserve（）避免多次不必要的扩容" class="headerlink" title="3、reserve（）避免多次不必要的扩容"></a>3、reserve（）避免多次不必要的扩容</h4><p><img src="/2024/03/18/stl/Users/fangyong/AppData/Roaming/Typora/typora-user-images/image-20240319105542682.png" alt="image-20240319105542682"></p>
<p>reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素。</p>
<ul>
<li>如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间</li>
</ul>
<p>当push_back的元素数量大于n的时候，会重新分配一个大小为2n的新空间，再将原有的n的元素和新的元素放入新开辟的内存空间中。</p>
<p>（注：重新分配内存，并不会在原有的地址之后紧跟着分配的新的空间，一般会重新开辟一段更大的空间，再将原来的数据和新的数据放入新的空间）</p>
<hr>
<h3 id="利用vector的swap-成员收缩内存"><a href="#利用vector的swap-成员收缩内存" class="headerlink" title="利用vector的swap()成员收缩内存"></a>利用vector的swap()成员收缩内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给v重新设定尺寸</span></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;resize后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;resize后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给v收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;收缩内存后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;收缩内存后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以发现，直接用resize()成员只能做到缩小尺寸（size），而实际的容量（capacity）并没有缩小。但是，使用swap()成员就能做到同时收缩v的容量。</p>
<p>原理就是，先利用待收缩的v进行拷贝构造创建出一个匿名对象，这个对象的尺寸和容量大小都是v当前的尺寸大小（上面例子中也就是3）。然后匿名对象调用swao()成员，与v交换指针（容器交换），匿名对象的指针指向之前v的那片内存空间，v的指针指向匿名对象的那片内存空间。这样v的尺寸和容量就都能得到收缩了。（执行完这行语句之后，由于是匿名对象，所以匿名对象所知的那篇内存空间会被释放）</p>
<hr>
<h3 id="vector不是存储bool类型元素的vector容器"><a href="#vector不是存储bool类型元素的vector容器" class="headerlink" title="&#x3D;&#x3D;vector不是存储bool类型元素的vector容器&#x3D;&#x3D;"></a>&#x3D;&#x3D;vector<bool>不是存储bool类型元素的vector容器&#x3D;&#x3D;</bool></h3><p><code>具体来讲，不推荐使用 vector&lt;bool&gt; 的原因有以下 2 个：</code></p>
<ol>
<li><code>严格意义上讲，vector&lt;bool&gt; 并不是一个 STL 容器；</code></li>
<li><code>vector&lt;bool&gt; 底层存储的并不是 bool 类型值。</code></li>
</ol>
<p>值得一提的是，对于是否为 STL 容器，C++ 标准库中有明确的判断条件，其中一个条件是：如果 cont 是包含对象 T 的 STL 容器，且该容器中重载了 [ ] 运算符（即支持 operator[]），则以下代码必须能够被编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>此行代码的含义是，借助 operator[ ] 获取一个 cont<T> 容器中存储的 T 对象，同时将这个对象的地址赋予给一个 T 类型的指针。<br>这就意味着，如果 vector<bool> 是一个 STL 容器，则下面这段代码是可以通过编译的：</bool></T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 vector&lt;bool&gt; 容器</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;cont&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//试图将指针 p 指向 cont 容器中第一个元素</span></span><br><span class="line"><span class="type">bool</span> *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>此段代码不能通过编译。原因在于 vector<bool> 底层采用了独特的存储机制。</bool></p>
<p>实际上，为了节省空间，vector<bool> 底层在存储各个 bool 类型值时，每个 bool 值都只使用一个比特位（二进制位）来存储。也就是说在 vector<bool> 底层，<strong>一个字节可以存储 8 个 bool 类型值。</strong>在这种存储机制的影响下，<strong>operator[ ] 势必就需要返回一个指向单个比特位的引用，但显然这样的引用是不存在的，等号左右两边出现冲突！</strong><br>如果在实际场景中需要使用 vector<bool> 这样的存储结构，该怎么办呢？很简单，可以选择使用 <strong>deque<bool></bool></strong> 或者 <strong>bitset</strong> 来替代 vector<bool>。</bool></bool></bool></bool></p>
<p>deque 容器几乎具有 vecotr 容器全部的功能（拥有的成员方法也仅差 reserve() 和 capacity()），而且更重要的是，deque 容器可以正常存储 bool 类型元素。</p>
<p>还可以考虑用 bitset 代替 vector<bool>，其本质是一个模板类，可以看做是一种类似数组的存储结构。和后者一样，bitset 只能用来存储 bool 类型值，且底层存储机制也采用的是用一个比特位来存储一个 bool 值。</bool></p>
<p>和 vector 容器不同的是，bitset 的大小在一开始就确定了，因此不支持插入和删除元素；另外 bitset 不是容器，所以不支持使用迭代器</p>
<hr>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><p>deque 是 double-ended queue 的缩写，又称双端队列容器。</p>
<p>前面章节中，我们已经系统学习了 vector 容器，值得一提的是，deque 容器和 vecotr 容器有很多相似之处，比如：</p>
<ul>
<li><p>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</p>
</li>
<li><p>deque 容器也可以根据需要修改自身的容量和大小。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png" alt="双向队列的操作"></p>
</li>
</ul>
<p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<p>deque 容器以模板类 deque<T>（T 为存储元素的类型）的形式在 <deque> 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</deque></T></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;deque&gt;using namespace std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h3><ol>
<li>创建一个没有任何元素的空 deque 容器：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d;</span><br></pre></td></tr></table></figure>

<p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p>
<ol start="2">
<li>创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10);</span><br></pre></td></tr></table></figure>

<p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p>
<ol start="3">
<li>创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10, 5)</span><br></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p>
<ol start="4">
<li>在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d1(5);std::deque&lt;int&gt; d2(d1);</span><br></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拷贝普通数组，创建deque容器int a[] = &#123; 1,2,3,4,5 &#125;;std::deque&lt;int&gt;d(a, a + 5);//适用于所有类型的容器std::array&lt;int, 5&gt;arr&#123; 11,12,13,14,15 &#125;;std::deque&lt;int&gt;d(arr.begin()+2, arr.end());//拷贝arr容器中的&#123;13,14,15&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque容器可利用的成员函数"><a href="#deque容器可利用的成员函数" class="headerlink" title="deque容器可利用的成员函数"></a>deque容器可利用的成员函数</h3><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的头部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td>
</tr>
</tbody></table>
<p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
<p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异</p>
<hr>
<h3 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h3><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//添加元素，会导致 first 失效</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。&#x3D;&#x3D;</p>
<blockquote>
<p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p>
</blockquote>
<h3 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> front = deque.<span class="built_in">front</span>(); <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> back = deque.<span class="built_in">back</span>();   <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = deque.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="双向队列实现"><a href="#双向队列实现" class="headerlink" title="双向队列实现"></a>双向队列实现</h3><h4 id="1-基于双向链表的实现¶"><a href="#1-基于双向链表的实现¶" class="headerlink" title="1.  基于双向链表的实现¶"></a>1.  基于双向链表的实现<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#1">¶</a></h4><p>因为它可以方便地删除头节点（对应出队操作）和在尾节点后添加新节点（对应入队操作）。</p>
<p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p>
<p>linkedListDeque</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step1.png" alt="基于链表实现双向队列的入队出队操作"></p>
<p>push_back()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step2_push_last.png" alt="linkedlist_deque_push_last"></p>
<p>push_front()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step3_push_first.png" alt="linkedlist_deque_push_first"></p>
<p>pop_back()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step4_pop_last.png" alt="linkedlist_deque_pop_last"></p>
<p>pop_front()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step5_pop_first.png" alt="linkedlist_deque_pop_first"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;              <span class="comment">// 节点值</span></span><br><span class="line">    DoublyListNode *next; <span class="comment">// 后继节点指针</span></span><br><span class="line">    DoublyListNode *prev; <span class="comment">// 前驱节点指针</span></span><br><span class="line">    <span class="built_in">DoublyListNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize = <span class="number">0</span>;              <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">LinkedListDeque</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">LinkedListDeque</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">        DoublyListNode *pre, *cur = front;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num, <span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = <span class="keyword">new</span> <span class="built_in">DoublyListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front-&gt;prev = node;</span><br><span class="line">            node-&gt;next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            node-&gt;prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front-&gt;val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            DoublyListNode *fNext = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fNext-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> front;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear-&gt;val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            DoublyListNode *rPrev = rear-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                rPrev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                rear-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rear-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组的实现¶"><a href="#2-基于数组的实现¶" class="headerlink" title="2.  基于数组的实现¶"></a>2.  基于数组的实现<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#2">¶</a></h4><p>如图 5-9 所示，与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。</p>
<p>ArrayDeque</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step1.png" alt="基于数组实现双向队列的入队出队操作"></p>
<p>push_last</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step2_push_last.png" alt="array_deque_push_last"></p>
<p>push_first</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step3_push_first.png" alt="array_deque_push_first"></p>
<p>pop_last</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step4_pop_last.png" alt="array_deque_pop_last"></p>
<p>pop_first</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step5_pop_first.png" alt="array_deque_pop_first"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums; <span class="comment">// 用于存储双向队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;        <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;      <span class="comment">// 双向队列长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayDeque</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        nums.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组尾部后，回到头部</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">        <span class="keyword">return</span> (i + <span class="built_in">capacity</span>()) % <span class="built_in">capacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">        <span class="comment">// 通过取余操作实现 front 越过数组头部后回到尾部</span></span><br><span class="line">        front = <span class="built_in">index</span>(front - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 num 添加至队首</span></span><br><span class="line">        nums[front] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="type">int</span> rear = <span class="built_in">index</span>(front + queSize);</span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekFirst</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">        front = <span class="built_in">index</span>(front + <span class="number">1</span>);</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekLast</span>();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算尾元素索引</span></span><br><span class="line">        <span class="type">int</span> last = <span class="built_in">index</span>(front + queSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            res[i] = nums[<span class="built_in">index</span>(j)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="list（STL-list）容器完全攻略（超级详细）"><a href="#list（STL-list）容器完全攻略（超级详细）" class="headerlink" title="list（STL list）容器完全攻略（超级详细）"></a>list（STL list）容器完全攻略（超级详细）</h2><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<p><img src="https://c.biancheng.net/uploads/allimg/180912/2-1P912134314345.jpg" alt="img"></p>
<p>可以看到，list 容器中各个元素的前后顺序是靠<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p>
<p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p>
<p><code>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</code></p>
<p>list 容器以模板类 list<T>（T 为存储元素的类型）的形式在<code>&lt;list&gt;</code>头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h4 id="list容器可用的成员函数"><a href="#list容器可用的成员函数" class="headerlink" title="list容器可用的成员函数"></a>list容器可用的成员函数</h4><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器实际包含的元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert()</td>
<td>在容器中的指定位置插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<h4 id="list迭代器及用法"><a href="#list迭代器及用法" class="headerlink" title="list迭代器及用法"></a>list迭代器及用法</h4><p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="img"></p>
<hr>
<h2 id="STL-forward-list容器完全攻略"><a href="#STL-forward-list容器完全攻略" class="headerlink" title="STL forward_list容器完全攻略"></a>STL forward_list容器完全攻略</h2><p>forward_list 是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表</p>
<p><img src="https://c.biancheng.net/uploads/allimg/191219/2-191219135239561.gif" alt="单链表和双向链表"></p>
<p> 不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>来维持。</p>
<p>因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p>
<p>另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p>
<h4 id="forward-list容器的创建"><a href="#forward-list容器的创建" class="headerlink" title="forward_list容器的创建"></a>forward_list容器的创建</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;<span class="comment">//在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器</span></span><br></pre></td></tr></table></figure>

<h4 id="forward-list容器支持的成员函数"><a href="#forward-list容器支持的成员函数" class="headerlink" title="forward_list容器支持的成员函数"></a>forward_list容器支持的成员函数</h4><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>before_begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td>
</tr>
<tr>
<td>begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td>
</tr>
<tr>
<td>end()</td>
<td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td>
</tr>
<tr>
<td>erase_after()</td>
<td>删除容器中某个指定位置或区域内的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice_after()</td>
<td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<p>C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_front</span>(<span class="number">4</span>);<span class="comment">//&#123;4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">emplace_after</span>(values.<span class="built_in">before_begin</span>(), <span class="number">5</span>); <span class="comment">//&#123;5,4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">reverse</span>();<span class="comment">//&#123;3,2,1,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 2 1 4 5</span></span><br></pre></td></tr></table></figure>

<h4 id="和使用forward-list容器相关的函数"><a href="#和使用forward-list容器相关的函数" class="headerlink" title="和使用forward_list容器相关的函数"></a>和使用forward_list容器相关的函数</h4><p>forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 dis<a target="_blank" rel="noopener" href="https://c.biancheng.net/ref/tan.html">tan</a>ce() 函数。举个例子：</iterator></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">distance</span>(std::<span class="built_in">begin</span>(my_words), std::<span class="built_in">end</span>(my_words));</span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STL关联式容器"><a href="#STL关联式容器" class="headerlink" title="STL关联式容器"></a>STL关联式容器</h1><h2 id="STL关联式容器是什么"><a href="#STL关联式容器是什么" class="headerlink" title="STL关联式容器是什么"></a>STL关联式容器是什么</h2><p>通过学习所有的序列式容器不难发现，无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体自定义类型的元素。</p>
<p>关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p>
<blockquote>
<p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p>
</blockquote>
<p>使用关联式容器存储的元素，都是一个一个的“键值对”（ &lt;key,value&gt; ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。</p>
<p>关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>来组织和存储各个键值对。有关红黑树组织和存储数据的方式，我们已经在数据结构中做了详细的介绍，读者可猛击《<a target="_blank" rel="noopener" href="https://c.biancheng.net/view/vip_3433.html">红黑树</a>》一文做详细了解。</p>
<hr>
<h2 id="C-STL关联式容器种类"><a href="#C-STL关联式容器种类" class="headerlink" title="C++ STL关联式容器种类"></a>C++ STL关联式容器种类</h2><table>
<thead>
<tr>
<th>关联式容器名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</T></map></td>
</tr>
<tr>
<td>set</td>
<td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</T></set></td>
</tr>
<tr>
<td>multimap</td>
<td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</map></td>
</tr>
<tr>
<td>multiset</td>
<td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</set></td>
</tr>
</tbody></table>
<p>这里为 map 容器为例，编写了一个样例（如下所示）。对于该程序，读者只需体会关联式容器的特性即可，无需纠结 map 容器的具体用法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map 容器在存储元素时，会根据各个元素键的大小自动调整元素的顺序（默认按照升序排序）</p>
<h2 id="STL-pair用法"><a href="#STL-pair用法" class="headerlink" title="STL pair用法"></a>STL pair用法</h2><p>关联式容器存储的是“键值对”形式的数据，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&gt;;</span><br><span class="line">&lt;<span class="string">&quot;b&quot;</span>,<span class="number">214</span>&gt;</span><br></pre></td></tr></table></figure>

<p>每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）</p>
<p>基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。</p>
<p>虑到“键值对”并不是普通类型数据，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p>
<p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="type">const</span> first_type&amp; a, <span class="type">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(<span class="type">const</span> pair&lt;U,V&gt;&amp; pr)</span></span>;</span><br><span class="line"><span class="comment">//C++11引入右值引用</span></span><br><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(pair&lt;U,V&gt;&amp;&amp; pr)</span></span>;<span class="comment">//一般使用make_pair(U u,T t)作为移动构造函数返回</span></span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(U&amp;&amp; a, V&amp;&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++ 11 还允许我们手动为 pair1 对象赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pairl.first=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">pairl.second=<span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小</p>
<p>注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。也就是说相同类型的pair</p>
<p>pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p>
<hr>
<h2 id="STL-map"><a href="#STL-map" class="headerlink" title="STL map"></a>STL map</h2><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p>
<blockquote>
<p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p>
</blockquote>
<p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p>
<p>另外需要注意的是，&#x3D;&#x3D;<strong>使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</strong>&#x3D;&#x3D;换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>
<blockquote>
<p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair&lt;const K, T&gt; 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p>
</blockquote>
<h3 id="创建C-map容器的几种方法"><a href="#创建C-map容器的几种方法" class="headerlink" title="创建C++ map容器的几种方法"></a>创建C++ map容器的几种方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap;</span><br><span class="line"><span class="comment">// 当然在创建 map 容器的同时，也可以进行初始化</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;              </span><br><span class="line"><span class="comment">//在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(myMap);                   <span class="comment">//C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。 #创建一个会返回临时 map 对象的函数</span></span><br><span class="line"><span class="function">std::map&lt;std::string,<span class="type">int</span>&gt; <span class="title">disMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br><span class="line"><span class="comment">//map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less&lt;T&gt; 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。*/</span>                     </span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//手动修改了 myMap 容器的排序规则，令其作降序排序</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;               </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-map容器包含的成员方法"><a href="#C-map容器包含的成员方法" class="headerlink" title="C++ map容器包含的成员方法"></a>C++ map容器包含的成员方法</h3><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<h3 id="STL-map容器迭代器"><a href="#STL-map容器迭代器" class="headerlink" title="STL map容器迭代器"></a>STL map容器迭代器</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符进行比较。</p>
<p>相比序列式容器，map 容器提供了更多的成员方法（如表 1 所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
</tbody></table>
<p><img src="/./stl.assets/2-19112Q14QE40.gif" alt="C++ STL map部分成员方法示意图"></p>
<p>map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p>
<ul>
<li>&#x3D;&#x3D;lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；&#x3D;&#x3D;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</code></p>
<p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p>
<p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="map获取键对应值的几种方法"><a href="#map获取键对应值的几种方法" class="headerlink" title="map获取键对应值的几种方法"></a>map获取键对应值的几种方法</h3><p>map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p>
<blockquote>
<p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p>
</blockquote>
<ol>
<li>map 类模板中对<code>[ ]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li>
</ol>
<p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</p>
<ol start="2">
<li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</li>
</ol>
<p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p>
<hr>
<h3 id="map-insert-插入数据的4种方式"><a href="#map-insert-插入数据的4种方式" class="headerlink" title="map insert()插入数据的4种方式"></a>map insert()插入数据的4种方式</h3><p>除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p>
<p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p>
<p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p>
<ol>
<li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">  <span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li>
<li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li>
</ul>
<ol start="2">
<li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p>
<ul>
<li><p>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</p>
</li>
<li><p>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p>
<ol start="3">
<li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java教程 http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序中，&lt;first,last&gt; 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</p>
<ol start="4">
<li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，vali 都表示的是键值对变量。</p>
<hr>
<h3 id="map容器operator-和insert-效率对比"><a href="#map容器operator-和insert-效率对比" class="headerlink" title="map容器operator[]和insert()效率对比"></a>map容器operator[]和insert()效率对比</h3><p>通过前面的学习我们知道，map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。 举个例子（程序一）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::map&lt;string, string&gt; mymap;</span><br><span class="line">  <span class="comment">//借用 operator[] 添加新键值对</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Bear\&quot;,\&quot;deviceid\&quot;:\&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;old mymap：&quot;</span>) &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 operator[] 更新某个键对应的值</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new mymap：&quot;</span> &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//借用insert()添加新键值对</span></span><br><span class="line">  std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;Javaplayer_02&quot;</span>,<span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;C++\&quot;,\&quot;deviceid\&quot;:\&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span> &#125;;</span><br><span class="line">  std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret;</span><br><span class="line">  ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;old ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 insert() 更新键值对</span></span><br><span class="line">  mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;node js&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new ret.iter = &lt;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">old mymap：&#123;&quot;username&quot;:&quot;Bear&quot;,&quot;deviceid&quot;:&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">new mymap：&#123;&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">old ret.iter = &lt;&#123;Javaplayer_02, &#123;&quot;username&quot;:&quot;C++&quot;,&quot;deviceid&quot;:&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">new ret.iter = &lt;Javaplayer_02, node js&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;**当实现“向 map <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。 **&#x3D;&#x3D;</p>
<h4 id="向map容器中增添元素，insert-效率更高"><a href="#向map容器中增添元素，insert-效率更高" class="headerlink" title="向map容器中增添元素，insert()效率更高"></a>向map容器中增添元素，insert()效率更高</h4><p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>mymap[“player_01”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。 但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “{&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;}” 赋值给这个 string 对象。 也就是说，上面这行代码的执行流程，可以等效为如下程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="type">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;player_01&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这里的 value_type(K,T) 指的是 map 容器中存储元素的类型，其实际上就等同于 pair&lt;K,T&gt;。</p>
<p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，<strong>先构造一个有默认值的键值对，然后再为其 value 赋值</strong>。 那么，为什么不直接构造一个要添加的键值对元素呢，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;脱发严重&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高。</p>
<h4 id="更新map容器中的键值对，operator-效率更高"><a href="#更新map容器中的键值对，operator-效率更高" class="headerlink" title="更新map容器中的键值对，operator[]效率更高"></a>更新map容器中的键值对，operator[]效率更高</h4><p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//operator[]</span></span><br><span class="line">mymap[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;脱发&quot;</span>;</span><br><span class="line"><span class="comment">//insert()</span></span><br><span class="line">std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;node&quot;</span>,<span class="string">&quot;霸王洗发水&quot;</span> &#125;;</span><br><span class="line">mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;还是霸王洗发水好&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</code></p>
<h3 id="map-emplace-和emplace-hint-方法详解"><a href="#map-emplace-和emplace-hint-方法详解" class="headerlink" title="map emplace()和emplace_hint()方法详解"></a>map emplace()和emplace_hint()方法详解</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。本节就来讲解这 2 个成员方法的用法。</p>
<p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高（后续章节会详细讲解）。</p>
<p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p>
<p>template &lt;class… Args&gt;<br> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;… args);</p>
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li>
<li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">2、ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">3、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 0&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p>
<ol>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ol>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//指定在 map 容器插入键值对</span></span><br><span class="line">    map&lt;string, string&gt;::iterator iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(),<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">C语言教程 http://c.biancheng.net/c/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p>
<p>那么，为什么 emplace() 和 emplace_hint() 方法的执行效率，比 insert() 高呢？</p>
<p><strong>C++11新增的emplace() 和 emplace_hint()都比insert效率高</strong></p>
<p>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</p>
<p>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">emplace_hint():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在map 容器内部直接构造的键值对。</strong></p>
<p>因此，<strong>在实现向 map 容器中插入键值对时，应优先考虑使用 emplace() 或者 emplace_hint()。</strong></p>
<hr>
<h2 id="multimap容器用法完全攻略"><a href="#multimap容器用法完全攻略" class="headerlink" title="multimap容器用法完全攻略"></a>multimap容器用法完全攻略</h2><p>掌握 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> map 容器的基础上，本节再讲一个和 map 相似的关联式容器，即 multimap 容器。</p>
<p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，<strong>multimap 容器中可以同时存储多（≥2）个键相同的键值对。</strong></p>
<p>和 map 容器一样，实现 multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>multimap 容器类模板的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br></pre></td></tr></table></figure>

<h3 id="创建C-multimap容器的方法"><a href="#创建C-multimap容器的方法" class="headerlink" title="创建C++ multimap容器的方法"></a>创建C++ multimap容器的方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multimap&lt;std::string, std::string&gt;mymultimap;</span><br><span class="line"><span class="comment">//通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="comment">/*使用此方式初始化 multimap 容器时，其底层会先将每一个&#123;key, value&#125;创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：*/</span></span><br><span class="line"><span class="comment">//借助 pair 类模板的构造函数来生成各个pair类型的键值对</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    pair&lt;string,string&gt;&#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 make_pair() 函数，生成键值对元素</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(mymultimap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。*/</span></span><br><span class="line"><span class="comment">//创建一个会返回临时 multimap 对象的函数</span></span><br><span class="line"><span class="function">multimap&lt;string, string&gt; <span class="title">dismultimap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    multimap&lt;string, string&gt;tempmultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,&#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 multimap 类模板的移动构造函数创建 newMultimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(<span class="built_in">dismultimap</span>());</span><br><span class="line"><span class="comment">/*上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</span></span><br><span class="line"><span class="comment">注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。*/</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(++mymultimap.<span class="built_in">begin</span>(), mymultimap.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为std::less&lt;T&gt;，这意味着以下 2 种创建 multimap 容器的方式是等价的：*/</span></span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>, std::less&lt;<span class="type">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-multimap容器包含的成员方法"><a href="#C-multimap容器包含的成员方法" class="headerlink" title="C++ multimap容器包含的成员方法"></a>C++ multimap容器包含的成员方法</h3><p>列出了 multimap 类模板提供的常用成员方法及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multimap 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multimap 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。&#x3D;&#x3D;这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p>
<p><code>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">count</span>(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.<span class="built_in">begin</span>(); iter != mymultimap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">a 10</span></span><br><span class="line"><span class="comment">b 20</span></span><br><span class="line"><span class="comment">b 15</span></span><br><span class="line"><span class="comment">c 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="STL-set"><a href="#STL-set" class="headerlink" title="STL set"></a>STL set</h2><p>前面章节讲解了 map 容器和 multimap 容器的用法，类似地，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联式容器。不过，本节先讲解 set 容器，后续章节再讲解 multiset 容器。</p>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p>
<p>举个例子，如下有 2 组键值对数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>&gt;&#125;</span><br><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p>
<p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p>
<p>通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p>
<p>另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</p>
<p><code>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</code></p>
<h3 id="创建C-set容器的几种方法"><a href="#创建C-set容器的几种方法" class="headerlink" title="创建C++ set容器的几种方法"></a>创建C++ set容器的几种方法</h3><ol>
<li>调用默认构造函数，创建空的 set 容器。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p>
<ol start="2">
<li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</T></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。</li>
</ol>
<p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;<span class="comment">//等同于//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure>

<p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p>
<p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;    <span class="keyword">return</span> myset;&#125;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;<span class="comment">//或者//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure>

<p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<ol start="4">
<li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</string></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-STL-set容器包含的成员方法"><a href="#C-STL-set容器包含的成员方法" class="headerlink" title="C++ STL set容器包含的成员方法"></a>C++ STL set容器包含的成员方法</h3><p> 列出了 set 容器提供的常用成员方法以及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、myset size = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/java/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="set容器迭代器"><a href="#set容器迭代器" class="headerlink" title="set容器迭代器"></a>set容器迭代器</h3><p>和 map 容器不同，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</p>
<p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符。</p>
<p>在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p>
</blockquote>
<p>图 2 演示了表 1 中除最后 4 个成员函数外，其它几个成员函数的具体功能。</p>
<p><img src="/./stl.assets/2-19112Q14QE40-1710858859716-3.gif" alt="img"></p>
<p>下面程序以 begin()&#x2F;end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>

<p><code>如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。</code></p>
<p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p>
<p>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">find</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;iter != myset.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure>

<p><code>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</code></p>
<hr>
<h3 id="set-insert-方法"><a href="#set-insert-方法" class="headerlink" title="set insert()方法"></a>set insert()方法</h3><p>我们已经学会如何创建一个 set 容器。在此基础上，如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。</p>
<p>为满足不同场景的需要，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p>
<ol>
<li>只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。</p>
<p>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li>
<li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="type">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/stl/ bool = 1</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/python/ bool = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p>
<ul>
<li><p>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</p>
</li>
<li><p>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*myset size =1</span></span><br><span class="line"><span class="comment">myset size =2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</code></p>
<ol start="3">
<li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p>
<ol start="4">
<li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">( &#123;E1, E2,...,En&#125; )</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//向 myset 中添加多个元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>即为 set 类模板中 insert() 成员方法的全部用法。指的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。</p>
<hr>
<h3 id="set-emplace-和emplace-hint"><a href="#set-emplace-和emplace-hint" class="headerlink" title="set emplace()和emplace_hint()"></a>set emplace()和emplace_hint()</h3><p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">ret.iter = &lt;http://c.biancheng.net/stl/, 1&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似</p>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的，这里不再赘述。</p>
<h3 id="set删除数据：erase-和clear"><a href="#set删除数据：erase-和clear" class="headerlink" title="set删除数据：erase()和clear()"></a>set删除数据：erase()和clear()</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p>
<p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</p>
<blockquote>
<p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="type">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">5</span></span><br><span class="line"><span class="number">1</span>、myset size = <span class="number">4</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">iter-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>、myset size = <span class="number">1</span></span><br><span class="line">iter2-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Fengzi7.magicalroom.com">封子期</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fengzi7.magicalroom.com/2024/03/18/stl/">https://fengzi7.magicalroom.com/2024/03/18/stl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Fengzi7.magicalroom.com" target="_blank">Fengzi7的奇妙空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/03/18/socket/" title="socket"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">socket</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/boqi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">封子期</div><div class="author-info__description">这个人很懒，请出门左转</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%9F%BA%E7%A1%80"><span class="toc-text">STL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">C++ STL是什么，有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E8%A6%81%E5%AD%A6%E5%93%AA%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">C++STL要学哪些知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">C++ STL容器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CC-STL%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">迭代器是什么，C++ STL迭代器（iterator）用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">迭代器类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">迭代器的定义方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">C++序列式容器（STL序列式容器）是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-text">容器中常见的函数成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array-STL-array-%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">array(STL array)容器用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-array%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL array随机访问迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#begin-end-%E5%92%8C-cbegin-cend"><span class="toc-text">begin()&#x2F;end() 和 cbegin()&#x2F;cend()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">array容器访问元素的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">访问array容器中单个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">访问array容器中多个元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">1.  初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text">2.  访问元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">3.  插入与删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-text">4.  遍历列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8B%BC%E6%8E%A5%E5%88%97%E8%A1%A8"><span class="toc-text">5.  拼接列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-text">6.  排序列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">原理实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88push-back-%E5%92%8Cemplace-back-%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">vector添加元素（push_back()和emplace_back()）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#push-back"><span class="toc-text">push_back()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace-back"><span class="toc-text">emplace_back()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace-back-%E5%92%8Cpush-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">emplace_back()和push_back()的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-%E5%92%8Cemplace-%E8%AF%A6%E8%A7%A3"><span class="toc-text">insert()和emplace()详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert"><span class="toc-text">insert()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace"><span class="toc-text">emplace()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%89%A9%E5%AE%B9%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E6%8D%9F%E5%A4%B1%EF%BC%88reserve%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-text">vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81vector%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="toc-text">1、vector数据结构性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81push-back%E5%90%8Eiterator%E5%A4%B1%E6%95%88%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">2、push_back后iterator失效程序崩溃的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81reserve%EF%BC%88%EF%BC%89%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-text">3、reserve（）避免多次不必要的扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8vector%E7%9A%84swap-%E6%88%90%E5%91%98%E6%94%B6%E7%BC%A9%E5%86%85%E5%AD%98"><span class="toc-text">利用vector的swap()成员收缩内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E4%B8%8D%E6%98%AF%E5%AD%98%E5%82%A8bool%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0%E7%9A%84vector%E5%AE%B9%E5%99%A8"><span class="toc-text">&#x3D;&#x3D;vector不是存储bool类型元素的vector容器&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAdeque%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建deque容器的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">deque容器可利用的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">deque容器迭代器的使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">双向队列常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">双向队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%B6"><span class="toc-text">1.  基于双向链表的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%B6"><span class="toc-text">2.  基于数组的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%EF%BC%88STL-list%EF%BC%89%E5%AE%B9%E5%99%A8%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5%EF%BC%88%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-text">list（STL list）容器完全攻略（超级详细）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E5%8F%AF%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">list容器可用的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-text">list迭代器及用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-forward-list%E5%AE%B9%E5%99%A8%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">STL forward_list容器完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">forward_list容器的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">forward_list容器支持的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E4%BD%BF%E7%94%A8forward-list%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">和使用forward_list容器相关的函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">STL关联式容器是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-text">C++ STL关联式容器种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-pair%E7%94%A8%E6%B3%95"><span class="toc-text">STL pair用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-map"><span class="toc-text">STL map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-map%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ map容器的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-map%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ map容器包含的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-map%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL map容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E8%8E%B7%E5%8F%96%E9%94%AE%E5%AF%B9%E5%BA%94%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">map获取键对应值的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-insert-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">map insert()插入数据的4种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8operator-%E5%92%8Cinsert-%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-text">map容器operator[]和insert()效率对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91map%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A2%9E%E6%B7%BB%E5%85%83%E7%B4%A0%EF%BC%8Cinsert-%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-text">向map容器中增添元素，insert()效率更高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0map%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8Coperator-%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-text">更新map容器中的键值对，operator[]效率更高</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-emplace-%E5%92%8Cemplace-hint-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">map emplace()和emplace_hint()方法详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multimap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">multimap容器用法完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-multimap%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ multimap容器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-multimap%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ multimap容器包含的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-set"><span class="toc-text">STL set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-set%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ set容器的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-STL-set%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ STL set容器包含的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">set容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-insert-%E6%96%B9%E6%B3%95"><span class="toc-text">set insert()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-emplace-%E5%92%8Cemplace-hint"><span class="toc-text">set emplace()和emplace_hint()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%9Aerase-%E5%92%8Cclear"><span class="toc-text">set删除数据：erase()和clear()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/stl/" title="STL"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL"/></a><div class="content"><a class="title" href="/2024/03/18/stl/" title="STL">STL</a><time datetime="2024-03-18T13:46:47.366Z" title="发表于 2024-03-18 21:46:47">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/socket/" title="socket"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="socket"/></a><div class="content"><a class="title" href="/2024/03/18/socket/" title="socket">socket</a><time datetime="2024-03-18T06:45:14.362Z" title="发表于 2024-03-18 14:45:14">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++多线程"/></a><div class="content"><a class="title" href="/2024/03/18/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="C++多线程">C++多线程</a><time datetime="2024-03-18T06:45:10.276Z" title="发表于 2024-03-18 14:45:10">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++11新特性"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++11新特性"/></a><div class="content"><a class="title" href="/2024/03/18/C++11%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++11新特性">C++11新特性</a><time datetime="2024-03-18T06:45:08.161Z" title="发表于 2024-03-18 14:45:08">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/hello-world/" title="Hello World"><img src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/03/18/hello-world/" title="Hello World">Hello World</a><time datetime="2024-03-18T02:45:02.016Z" title="发表于 2024-03-18 10:45:02">2024-03-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 封子期</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1957725779" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>