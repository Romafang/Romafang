<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STL | Fengzi7的奇妙空间</title><meta name="author" content="封子期"><meta name="copyright" content="封子期"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:type" content="article">
<meta property="og:title" content="STL">
<meta property="og:url" content="https://fengzi7.magicalroom.com/2024/09/26/stl/index.html">
<meta property="og:site_name" content="Fengzi7的奇妙空间">
<meta property="og:description" content="STL基础C++ STL是什么，有什么用？在已有 C++ 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 STL 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？ STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg">
<meta property="article:published_time" content="2024-09-26T13:24:03.625Z">
<meta property="article:modified_time" content="2024-03-20T15:26:06.000Z">
<meta property="article:author" content="封子期">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://fengzi7.magicalroom.com/2024/09/26/stl/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-20 23:26:06'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/boqi.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Fengzi7的奇妙空间"><span class="site-name">Fengzi7的奇妙空间</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-26T13:24:03.625Z" title="发表于 2024-09-26 21:24:03">2024-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-20T15:26:06.000Z" title="更新于 2024-03-20 23:26:06">2024-03-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">53k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>195分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a>STL基础</h1><h2 id="C-STL是什么，有什么用？"><a href="#C-STL是什么，有什么用？" class="headerlink" title="C++ STL是什么，有什么用？"></a>C++ STL是什么，有什么用？</h2><p>在已有 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？</p>
<p>STL，英文全称 s<a target="_blank" rel="noopener" href="https://c.biancheng.net/ref/tan.html">tan</a>dard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p>
<p><code>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</code></p>
<p>根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p>
<h2 id="C-STL要学哪些知识"><a href="#C-STL要学哪些知识" class="headerlink" title="C++STL要学哪些知识"></a>C++STL要学哪些知识</h2><p>&#x3D;&#x3D;<strong>C++ STL基本组成（6大组件+13个头文件）</strong>&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>STL的组成</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>一些封装<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td>算法</td>
<td>STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。</numeric></algorithm></td>
</tr>
<tr>
<td>迭代器</td>
<td>在 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td>函数对象</td>
<td>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td>适配器</td>
<td>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td>
</tr>
<tr>
<td>内存分配器</td>
<td>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody></table>
<p>在 C++ 标准中，它们被重新组织为 13 个头文件，如表 2 所示。</p>
<p><img src="/../typora-user-images/13head.png" alt="image-20240318220604552"></p>
<p>按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 &lt;vector.h&gt; 为有扩展名的形式。</vector></p>
<p>但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件（例如 Visual C++ 支持的 Dinkumware 版本同时具备 &lt;vector.h&gt; 和 <vector>）；甚至有些 STL 版本同时拥有 3 种形式的头文件（例如 SGI 版本同时拥有 <vector>、&lt;vector.h&gt; 和 &lt;stl_vector.h&gt;）；但也有个别的 STL 版本只存在包含扩展名的头文件（例如 C++ Builder 的 RaugeWare 版本只有 &lt;vector.h&gt;）</vector></vector></p>
<h1 id="STL序列式容器"><a href="#STL序列式容器" class="headerlink" title="STL序列式容器"></a>STL序列式容器</h1><h2 id="C-STL容器是什么？"><a href="#C-STL容器是什么？" class="headerlink" title="C++ STL容器是什么？"></a>C++ STL容器是什么？</h2><p>&#x3D;&#x3D;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&#x3D;&#x3D;STL 提供有 3 类标准容器，分别是<strong>序列容器、排序容器和哈希容器</strong>，其中后两类容器有时也统称为&#x3D;&#x3D;关联容器&#x3D;&#x3D;。</p>
<p>它们各自的含义如表 1 所示。</p>
<table>
<thead>
<tr>
<th>容器种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>序列容器</td>
<td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td>
</tr>
<tr>
<td>排序容器</td>
<td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td>
</tr>
<tr>
<td>哈希容器</td>
<td><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td>
</tr>
</tbody></table>
<h2 id="迭代器是什么，C-STL迭代器（iterator）用法详解"><a href="#迭代器是什么，C-STL迭代器（iterator）用法详解" class="headerlink" title="迭代器是什么，C++ STL迭代器（iterator）用法详解"></a>迭代器是什么，C++ STL迭代器（iterator）用法详解</h2><p>无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p>
<p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p>
<p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p>
<p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读&#x2F;写操作。</p>
<h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。</p>
<p><code>容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</code></p>
<p>常用的迭代器按功能强弱分为**输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 **5 种。本节主要介绍后面的这 3 种迭代器</p>
<p><code>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。</code></p>
<ol>
<li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p>
</li>
<li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p>
</li>
<li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
</li>
</ol>
<ul>
<li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li>
<li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
<p>C++ 11 标准中不同容器指定使用的迭代器类型。<br>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应的迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set &#x2F; multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map &#x2F; multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map &#x2F; unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set &#x2F; unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>容器类名::iterator 迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>容器类名::const_iterator 迭代器名;</td>
</tr>
<tr>
<td>反向迭代器</td>
<td>容器类名::reverse_iterator 迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>容器类名::const_reverse_iterator 迭代器名;</td>
</tr>
</tbody></table>
<p>通过定义以上几种迭代器，就可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<p>注意，&#x3D;&#x3D;以上 4 种定义迭代器的方式，并不是每个容器都适用&#x3D;&#x3D;。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p>
<p>vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历 vector 容器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 vector 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="comment">//创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第二种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第三种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第四种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第二种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第三种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第四种遍历方法：</span></span><br><span class="line"><span class="comment">1 3 5 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>

<p>以下代码是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下代码则不合法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用“&lt;”进行比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i];</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用下标随机访问元素：</span></span><br></pre></td></tr></table></figure>

<h2 id="C-序列式容器（STL序列式容器）是什么"><a href="#C-序列式容器（STL序列式容器）是什么" class="headerlink" title="C++序列式容器（STL序列式容器）是什么"></a>C++序列式容器（STL序列式容器）是什么</h2><p>所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p>
<p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p>
<ul>
<li>**array&lt;T,N&gt;**（数组容器）：表示可以存储 N 个 T 类型的元素，是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li>
<li><strong>vector<T>（向量容器）</T></strong>：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li>
<li><strong>deque<T>（双端队列容器）</T></strong>：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li>
<li><strong>list<T>（链表容器）</T></strong>：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</T></li>
<li>**forward_list<T>**（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</T></li>
</ul>
<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911110REB.jpg" alt="img"></p>
<h3 id="容器中常见的函数成员"><a href="#容器中常见的函数成员" class="headerlink" title="容器中常见的函数成员"></a>容器中常见的函数成员</h3><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>array&lt;T,N&gt;</th>
<th>vector<T></T></th>
<th>deque<T></T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
<td>-</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator<a href></a></td>
<td>使用索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检査的索引访问元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
<td>-</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。</td>
<td>是</td>
<td>是</td>
<td>-</td>
</tr>
</tbody></table>
<p>list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
<th>list<T></T></th>
<th>forward_list<T></T></th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>before_begin()</td>
<td>返回指向第一个元素前一个位置的迭代器。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>operator&#x3D;()</td>
<td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的引用。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的引用。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的起始位置添加一个元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定位置直接生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置的后面直接生成一个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>cmplacc_front()</td>
<td>在序列的起始位生成一个元索。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置的后面插入一个或多个元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除序列尾部的元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除序列头部的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中某一段的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>erase()</td>
<td>移除指定位置的一个元素或一段元素。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>erase_after()</td>
<td>移除指定位置后面的一个元素或一段元素。</td>
<td>-</td>
<td>是</td>
</tr>
<tr>
<td>remove()</td>
<td>移除所有和参数匹配的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>remove_if()</td>
<td>移除满足一元函数条件的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>unique()</td>
<td>移除所有连续重复的元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的元素，容器大小变为 0。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>sort()</td>
<td>对元素进行排序。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个有序容器。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>splice()</td>
<td>移动指定位置前面的所有元素到另一个同类型的 list 中。</td>
<td>是</td>
<td>-</td>
</tr>
<tr>
<td>splice_after()</td>
<td>移动指定位置后面的所有元素到另一个同类型的 list 中。</td>
<td>-</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="array-STL-array-容器用法详解"><a href="#array-STL-array-容器用法详解" class="headerlink" title="array(STL array)容器用法详解"></a>array(STL array)容器用法详解</h2><p>array 容器是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p>
<p>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中</array></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">array</span>;</span><br><span class="line">&#125;</span><br><span class="line">在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure>

<p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p>
<p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911150226392.jpg" alt="初始化array容器"></p>
<p>array 容器还提供有很多功能实用的成员函数</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的随机访问迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的随机访问迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()&#x3D;&#x3D;0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody></table>
<h3 id="STL-array随机访问迭代器"><a href="#STL-array随机访问迭代器" class="headerlink" title="STL array随机访问迭代器"></a>STL array随机访问迭代器</h3><p>在 array 容器的模板类中，和随机访问迭代器相关的成员函数如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="迭代器的具体功能示意图"></p>
<p>它们的功能并结合实际场景的需要，这些成员函数通常是成对使用的，即 begin()&#x2F;end()、rbegin()&#x2F;rend()、cbegin()&#x2F;cend()、crbegin()&#x2F;crend() 各自成对搭配使用。不仅如此，这 4 对中 begin()&#x2F;end() 和 cbegin()&#x2F;cend()、rbegin()&#x2F;rend() 和 crbegin()&#x2F;crend() 的功能大致是相同的（如图 2 所示），唯一的区别就在于其返回的迭代器能否用来修改元素值。</p>
<h4 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()&#x2F;end() 和 cbegin()&#x2F;cend()"></a>begin()&#x2F;end() 和 cbegin()&#x2F;cend()</h4><p>begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p>
<p>当操作对象为 array 容器时，它们和 begin()&#x2F;end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure>

<p>array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()&#x2F;end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">cend</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">//*first = 10;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="array容器访问元素的几种方式"><a href="#array容器访问元素的几种方式" class="headerlink" title="array容器访问元素的几种方式"></a>array容器访问元素的几种方式</h2><h3 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h3><p>使用下标寻址符&#x3D;&#x3D;[]&#x3D;&#x3D;,但是可能越界访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>为了避免越界访问，可以使用array的成员函数at()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values.<span class="built_in">at</span> (<span class="number">4</span>) = values.<span class="built_in">at</span>(<span class="number">3</span>) + <span class="number">2.</span>O*values.<span class="built_in">at</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p>
<p>array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 5&gt; words&#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; endl; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; //越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>。通过该指针，我们可以获得容器中的各个元素，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; *( words.<span class="built_in">data</span>()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h3><p>我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p>
<p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.<span class="built_in">empty</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has no elements.\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has &quot;</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;elements.\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如何获取 array 容器中元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values1;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; values1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.<span class="built_in">at</span>(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="type">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.<span class="built_in">begin</span>(); i &lt; values1.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.<span class="built_in">begin</span>(); i &lt; values2.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.  初始化列表"></a>1.  初始化列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 需注意，C++ 中 vector 即是本文描述的 nums</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1;</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h4><p>本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> num = nums[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3.  插入与删除元素"></a>3.  插入与删除元素</h4><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">nums.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>);      <span class="comment">// 删除索引 3 处的元素</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>(),num.<span class="built_in">begin</span>()+<span class="number">2</span>);<span class="comment">//删除索引0-2区间内的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="4-遍历列表"><a href="#4-遍历列表" class="headerlink" title="4.  遍历列表"></a>4.  遍历列表</h4><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    count += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5.  拼接列表"></a>5.  拼接列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// 将列表 nums1 拼接到 nums 之后</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.  排序列表"></a>6.  排序列表</h4><p>完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure>

<h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。</p>
<p>为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。</p>
<ul>
<li><strong>初始容量</strong>：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。</li>
<li><strong>数量记录</strong>：声明一个变量 <code>size</code> ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li>
<li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *arr;             <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> arrCapacity = <span class="number">10</span>; <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> arrSize = <span class="number">0</span>;      <span class="comment">// 列表长度（当前元素数量）</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>;   <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">MyList</span>() &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[arrCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">MyList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引如果越界，则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        arr[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        arr[<span class="built_in">size</span>()] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= index; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = arr[index];</span><br><span class="line">        <span class="comment">// 将索引 index 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = index; j &lt; <span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize--;</span><br><span class="line">        <span class="comment">// 返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extendCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个长度为原数组 extendRatio 倍的新数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">capacity</span>() * extendRatio;</span><br><span class="line">        <span class="type">int</span> *tmp = arr;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">        <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            arr[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        arrCapacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为 Vector 用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="vector添加元素（push-back-和emplace-back-）详解"><a href="#vector添加元素（push-back-和emplace-back-）详解" class="headerlink" title="vector添加元素（push_back()和emplace_back()）详解"></a>vector添加元素（push_back()和emplace_back()）详解</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p>
<p>emplace_back() 成员函数的用法也很简单，这里直接举个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</p>
<p><strong>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；</strong></p>
<p><strong>而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果为：</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用拷贝构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</code></p>
<h3 id="insert-和emplace-详解"><a href="#insert-和emplace-详解" class="headerlink" title="insert()和emplace()详解"></a>insert()和emplace()详解</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p>
<p><strong><code>再次强调，emplace() 每次只能插入一个元素，而不是多个。</code></strong></p>
<p>该函数的语法格式如下：</p>
<p><code>iterator emplace (const_iterator pos, args...);</code></p>
<p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p>
<p><code>简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure>

<p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.<span class="built_in">insert</span>(demo2.<span class="built_in">begin</span>(), <span class="built_in">testDemo</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;移动构造函数看另一个C++11新特性里的右值引用部分&#x3D;&#x3D;</p>
<hr>
<h3 id="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"><a href="#vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）" class="headerlink" title="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"></a>vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）</h3><h4 id="1、vector数据结构性质"><a href="#1、vector数据结构性质" class="headerlink" title="1、vector数据结构性质"></a>1、vector数据结构性质</h4><p>vector占用一块连续分配的内存，一种可以存储任意类型的动态数组，与array不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</p>
<p>vector数据结构如下，通过三个迭代器start, finish, end_of_storage的系列public接口，可很好地完成数据存储、溢出判断(iter &gt;&#x3D; iv.end())、大小、容量(容量与大小不等，以免不断申请空间耗费资源)、重载操作符[]、判空、最前元素、最后元素等等。<br><img src="/../typora-user-images/vector.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">iterator start;               <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line"> iterator finish;              <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage;      <span class="comment">// 表示实际分配内存空间的尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;扩容条件&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size==capacity;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - size:实际所包含的元素个数 </span></span><br><span class="line"><span class="comment"> - capacity:容器的容量,指的是在不分配更多内存的情况下，容器可以保存的最多元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/../typora-user-images/kuorong.png" alt="在这里插入图片描述"></p>
<p>vector 容器扩容的整个过程，大致分为以下 4 个步骤：</p>
<p>1、分配一块大小是当前 vector 容量几倍的新存储空间。注意，多数 STL 版本中的 vector 容器，其容器都会以 2<br>的倍数增长，也就是说，每次 vector 容器扩容，它们的容量都会提高到之前的 2 倍；<br>2、将 vector 容器存储的所有元素，依照原有次序从旧的存储空间复制到新的存储空间中；<br>3、析构掉旧存储空间中存储的所有元素；<br>4、释放旧的存储空间。<br>通过以上分析不难看出，vector 容器的扩容过程是非常耗时的，并且当容器进行扩容后，之前和该容器相关的所有指针、迭代器以及引用都会失效。因此在使用 vector 容器过程中，我们应尽量避免执行不必要的扩容操作。</p>
<hr>
<h4 id="2、push-back后iterator失效程序崩溃的原因"><a href="#2、push-back后iterator失效程序崩溃的原因" class="headerlink" title="2、push_back后iterator失效程序崩溃的原因"></a>2、push_back后iterator失效程序崩溃的原因</h4><p>在使用push_back对vector进行构造的时候，vector的容量capacity(与size有区别)会根据压入元素的数量进行内存的自动重新分配，这时候iterator会因为vector存储空间的变化而失效，需要注意iterator的有效性，以免iterator指向未知的内存空间导致程序异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用for进行vector的push_back之后，初始化了一个iterator指向vecInt的begin位置，并打印验证。之后再用push_back在vector的末尾添加了一个元素123，这时候用iter来遍历vecInt。</p>
<p>&#x3D;&#x3D;下面对MAX_NUM进行修改，将其改为8&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8	<span class="comment">//MAX_NUM修改为8，其余地方不做任何修改</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只修改MAX_NUM的值，其他地方保留和code2一样，再次运行的时候，程序崩溃了！</p>
<p>对于vector来说，和数组最大的区别之一，就是不需要在初始化的时候声明vector的大小。如果初始化的时候没有指明vector的大小，那么会根据实际的使用情况，在内存中为vector分配的大小分别 2 -&gt; 4 -&gt; 8 -&gt; 16 … 。<br>MAX_NUM是8，所以在for进行push_back之后，vecInt在内存中的大小为8。 对vecInt再次将元素123进行push_back的时候，新的vector大小将超过当前的vector大小，所以会自动重新分配存储空间。<br>由于vector的存储空间已经被重新分配，在push_back(123)之后，iter自然也就会指向一个未知的空间。所以会导致程序异常。<br>&#x3D;&#x3D;可以使用capacity()验证&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">		vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">	cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	先注释掉会崩溃的代码</span></span><br><span class="line"><span class="comment">//	while(iter != vecInt.end())&#123;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//		iter++;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity:8</span></span><br><span class="line"><span class="comment">the lst element:0</span></span><br><span class="line"><span class="comment">capacity:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="3、reserve（）避免多次不必要的扩容"><a href="#3、reserve（）避免多次不必要的扩容" class="headerlink" title="3、reserve（）避免多次不必要的扩容"></a>3、reserve（）避免多次不必要的扩容</h4><p><img src="/../typora-user-images/res.png" alt="image-20240319105542682"></p>
<p>reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素。</p>
<ul>
<li>如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间</li>
</ul>
<p>当push_back的元素数量大于n的时候，会重新分配一个大小为2n的新空间，再将原有的n的元素和新的元素放入新开辟的内存空间中。</p>
<p>（注：重新分配内存，并不会在原有的地址之后紧跟着分配的新的空间，一般会重新开辟一段更大的空间，再将原来的数据和新的数据放入新的空间）</p>
<hr>
<h3 id="利用vector的swap-成员收缩内存"><a href="#利用vector的swap-成员收缩内存" class="headerlink" title="利用vector的swap()成员收缩内存"></a>利用vector的swap()成员收缩内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给v重新设定尺寸</span></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;resize后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;resize后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给v收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;收缩内存后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;收缩内存后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以发现，直接用resize()成员只能做到缩小尺寸（size），而实际的容量（capacity）并没有缩小。但是，使用swap()成员就能做到同时收缩v的容量。</p>
<p>原理就是，先利用待收缩的v进行拷贝构造创建出一个匿名对象，这个对象的尺寸和容量大小都是v当前的尺寸大小（上面例子中也就是3）。然后匿名对象调用swao()成员，与v交换指针（容器交换），匿名对象的指针指向之前v的那片内存空间，v的指针指向匿名对象的那片内存空间。这样v的尺寸和容量就都能得到收缩了。（执行完这行语句之后，由于是匿名对象，所以匿名对象所知的那篇内存空间会被释放）</p>
<hr>
<h3 id="vector不是存储bool类型元素的vector容器"><a href="#vector不是存储bool类型元素的vector容器" class="headerlink" title="&#x3D;&#x3D;vector不是存储bool类型元素的vector容器&#x3D;&#x3D;"></a>&#x3D;&#x3D;vector<bool>不是存储bool类型元素的vector容器&#x3D;&#x3D;</bool></h3><p><code>具体来讲，不推荐使用 vector&lt;bool&gt; 的原因有以下 2 个：</code></p>
<ol>
<li><code>严格意义上讲，vector&lt;bool&gt; 并不是一个 STL 容器；</code></li>
<li><code>vector&lt;bool&gt; 底层存储的并不是 bool 类型值。</code></li>
</ol>
<p>值得一提的是，对于是否为 STL 容器，C++ 标准库中有明确的判断条件，其中一个条件是：如果 cont 是包含对象 T 的 STL 容器，且该容器中重载了 [ ] 运算符（即支持 operator[]），则以下代码必须能够被编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>此行代码的含义是，借助 operator[ ] 获取一个 cont<T> 容器中存储的 T 对象，同时将这个对象的地址赋予给一个 T 类型的指针。<br>这就意味着，如果 vector<bool> 是一个 STL 容器，则下面这段代码是可以通过编译的：</bool></T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 vector&lt;bool&gt; 容器</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;cont&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//试图将指针 p 指向 cont 容器中第一个元素</span></span><br><span class="line"><span class="type">bool</span> *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>此段代码不能通过编译。原因在于 vector<bool> 底层采用了独特的存储机制。</bool></p>
<p>实际上，为了节省空间，vector<bool> 底层在存储各个 bool 类型值时，每个 bool 值都只使用一个比特位（二进制位）来存储。也就是说在 vector<bool> 底层，<strong>一个字节可以存储 8 个 bool 类型值。</strong>在这种存储机制的影响下，<strong>operator[ ] 势必就需要返回一个指向单个比特位的引用，但显然这样的引用是不存在的，等号左右两边出现冲突！</strong><br>如果在实际场景中需要使用 vector<bool> 这样的存储结构，该怎么办呢？很简单，可以选择使用 <strong>deque<bool></bool></strong> 或者 <strong>bitset</strong> 来替代 vector<bool>。</bool></bool></bool></bool></p>
<p>deque 容器几乎具有 vecotr 容器全部的功能（拥有的成员方法也仅差 reserve() 和 capacity()），而且更重要的是，deque 容器可以正常存储 bool 类型元素。</p>
<p>还可以考虑用 bitset 代替 vector<bool>，其本质是一个模板类，可以看做是一种类似数组的存储结构。和后者一样，bitset 只能用来存储 bool 类型值，且底层存储机制也采用的是用一个比特位来存储一个 bool 值。</bool></p>
<p>和 vector 容器不同的是，bitset 的大小在一开始就确定了，因此不支持插入和删除元素；另外 bitset 不是容器，所以不支持使用迭代器</p>
<hr>
<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><p>deque 是 double-ended queue 的缩写，又称双端队列容器。</p>
<p>前面章节中，我们已经系统学习了 vector 容器，值得一提的是，deque 容器和 vecotr 容器有很多相似之处，比如：</p>
<ul>
<li><p>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</p>
</li>
<li><p>deque 容器也可以根据需要修改自身的容量和大小。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png" alt="双向队列的操作"></p>
</li>
</ul>
<p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p>
<blockquote>
<p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p>
</blockquote>
<p>deque 容器以模板类 deque<T>（T 为存储元素的类型）的形式在 <deque> 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</deque></T></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;deque&gt;using namespace std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h3 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h3><ol>
<li>创建一个没有任何元素的空 deque 容器：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d;</span><br></pre></td></tr></table></figure>

<p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p>
<ol start="2">
<li>创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10);</span><br></pre></td></tr></table></figure>

<p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p>
<ol start="3">
<li>创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10, 5)</span><br></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p>
<ol start="4">
<li>在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d1(5);std::deque&lt;int&gt; d2(d1);</span><br></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拷贝普通数组，创建deque容器int a[] = &#123; 1,2,3,4,5 &#125;;std::deque&lt;int&gt;d(a, a + 5);//适用于所有类型的容器std::array&lt;int, 5&gt;arr&#123; 11,12,13,14,15 &#125;;std::deque&lt;int&gt;d(arr.begin()+2, arr.end());//拷贝arr容器中的&#123;13,14,15&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque容器可利用的成员函数"><a href="#deque容器可利用的成员函数" class="headerlink" title="deque容器可利用的成员函数"></a>deque容器可利用的成员函数</h3><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的头部添加一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素。</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td>
</tr>
</tbody></table>
<p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
<p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异</p>
<hr>
<h3 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h3><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//添加元素，会导致 first 失效</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。&#x3D;&#x3D;</p>
<blockquote>
<p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p>
</blockquote>
<h3 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> front = deque.<span class="built_in">front</span>(); <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> back = deque.<span class="built_in">back</span>();   <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = deque.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="双向队列实现"><a href="#双向队列实现" class="headerlink" title="双向队列实现"></a>双向队列实现</h3><h4 id="1-基于双向链表的实现¶"><a href="#1-基于双向链表的实现¶" class="headerlink" title="1.  基于双向链表的实现¶"></a>1.  基于双向链表的实现<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#1">¶</a></h4><p>因为它可以方便地删除头节点（对应出队操作）和在尾节点后添加新节点（对应入队操作）。</p>
<p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p>
<p>linkedListDeque</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step1.png" alt="基于链表实现双向队列的入队出队操作"></p>
<p>push_back()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step2_push_last.png" alt="linkedlist_deque_push_last"></p>
<p>push_front()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step3_push_first.png" alt="linkedlist_deque_push_first"></p>
<p>pop_back()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step4_pop_last.png" alt="linkedlist_deque_pop_last"></p>
<p>pop_front()</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step5_pop_first.png" alt="linkedlist_deque_pop_first"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;              <span class="comment">// 节点值</span></span><br><span class="line">    DoublyListNode *next; <span class="comment">// 后继节点指针</span></span><br><span class="line">    DoublyListNode *prev; <span class="comment">// 前驱节点指针</span></span><br><span class="line">    <span class="built_in">DoublyListNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize = <span class="number">0</span>;              <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">LinkedListDeque</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">LinkedListDeque</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">        DoublyListNode *pre, *cur = front;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num, <span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = <span class="keyword">new</span> <span class="built_in">DoublyListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front-&gt;prev = node;</span><br><span class="line">            node-&gt;next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            node-&gt;prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front-&gt;val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            DoublyListNode *fNext = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fNext-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> front;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear-&gt;val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            DoublyListNode *rPrev = rear-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                rPrev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                rear-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rear-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组的实现¶"><a href="#2-基于数组的实现¶" class="headerlink" title="2.  基于数组的实现¶"></a>2.  基于数组的实现<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#2">¶</a></h4><p>如图 5-9 所示，与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。</p>
<p>ArrayDeque</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step1.png" alt="基于数组实现双向队列的入队出队操作"></p>
<p>push_last</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step2_push_last.png" alt="array_deque_push_last"></p>
<p>push_first</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step3_push_first.png" alt="array_deque_push_first"></p>
<p>pop_last</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step4_pop_last.png" alt="array_deque_pop_last"></p>
<p>pop_first</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step5_pop_first.png" alt="array_deque_pop_first"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums; <span class="comment">// 用于存储双向队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;        <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;      <span class="comment">// 双向队列长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayDeque</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        nums.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组尾部后，回到头部</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">        <span class="keyword">return</span> (i + <span class="built_in">capacity</span>()) % <span class="built_in">capacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">        <span class="comment">// 通过取余操作实现 front 越过数组头部后回到尾部</span></span><br><span class="line">        front = <span class="built_in">index</span>(front - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 num 添加至队首</span></span><br><span class="line">        nums[front] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="type">int</span> rear = <span class="built_in">index</span>(front + queSize);</span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekFirst</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">        front = <span class="built_in">index</span>(front + <span class="number">1</span>);</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekLast</span>();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算尾元素索引</span></span><br><span class="line">        <span class="type">int</span> last = <span class="built_in">index</span>(front + queSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            res[i] = nums[<span class="built_in">index</span>(j)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="list（STL-list）容器完全攻略（超级详细）"><a href="#list（STL-list）容器完全攻略（超级详细）" class="headerlink" title="list（STL list）容器完全攻略（超级详细）"></a>list（STL list）容器完全攻略（超级详细）</h2><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<p><img src="https://c.biancheng.net/uploads/allimg/180912/2-1P912134314345.jpg" alt="img"></p>
<p>可以看到，list 容器中各个元素的前后顺序是靠<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p>
<p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p>
<p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p>
<p><code>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</code></p>
<p>list 容器以模板类 list<T>（T 为存储元素的类型）的形式在<code>&lt;list&gt;</code>头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p>
</blockquote>
<h4 id="list容器可用的成员函数"><a href="#list容器可用的成员函数" class="headerlink" title="list容器可用的成员函数"></a>list容器可用的成员函数</h4><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器实际包含的元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert()</td>
<td>在容器中的指定位置插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<h4 id="list迭代器及用法"><a href="#list迭代器及用法" class="headerlink" title="list迭代器及用法"></a>list迭代器及用法</h4><p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="img"></p>
<hr>
<h2 id="STL-forward-list容器完全攻略"><a href="#STL-forward-list容器完全攻略" class="headerlink" title="STL forward_list容器完全攻略"></a>STL forward_list容器完全攻略</h2><p>forward_list 是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表</p>
<p><img src="https://c.biancheng.net/uploads/allimg/191219/2-191219135239561.gif" alt="单链表和双向链表"></p>
<p> 不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过<a target="_blank" rel="noopener" href="https://c.biancheng.net/c/80/">指针</a>来维持。</p>
<p>因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p>
<p>另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p>
<h4 id="forward-list容器的创建"><a href="#forward-list容器的创建" class="headerlink" title="forward_list容器的创建"></a>forward_list容器的创建</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;<span class="comment">//在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器</span></span><br></pre></td></tr></table></figure>

<h4 id="forward-list容器支持的成员函数"><a href="#forward-list容器支持的成员函数" class="headerlink" title="forward_list容器支持的成员函数"></a>forward_list容器支持的成员函数</h4><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>before_begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td>
</tr>
<tr>
<td>begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td>
</tr>
<tr>
<td>end()</td>
<td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td>
</tr>
<tr>
<td>erase_after()</td>
<td>删除容器中某个指定位置或区域内的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice_after()</td>
<td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody></table>
<p>C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p>
<p>forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_front</span>(<span class="number">4</span>);<span class="comment">//&#123;4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">emplace_after</span>(values.<span class="built_in">before_begin</span>(), <span class="number">5</span>); <span class="comment">//&#123;5,4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">reverse</span>();<span class="comment">//&#123;3,2,1,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 2 1 4 5</span></span><br></pre></td></tr></table></figure>

<h4 id="和使用forward-list容器相关的函数"><a href="#和使用forward-list容器相关的函数" class="headerlink" title="和使用forward_list容器相关的函数"></a>和使用forward_list容器相关的函数</h4><p>forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 dis<a target="_blank" rel="noopener" href="https://c.biancheng.net/ref/tan.html">tan</a>ce() 函数。举个例子：</iterator></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">distance</span>(std::<span class="built_in">begin</span>(my_words), std::<span class="built_in">end</span>(my_words));</span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="STL关联式容器"><a href="#STL关联式容器" class="headerlink" title="STL关联式容器"></a>STL关联式容器</h1><h2 id="STL关联式容器是什么"><a href="#STL关联式容器是什么" class="headerlink" title="STL关联式容器是什么"></a>STL关联式容器是什么</h2><p>通过学习所有的序列式容器不难发现，无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体自定义类型的元素。</p>
<p>关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p>
<blockquote>
<p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p>
</blockquote>
<p>使用关联式容器存储的元素，都是一个一个的“键值对”（ &lt;key,value&gt; ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。</p>
<p>关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>来组织和存储各个键值对。有关红黑树组织和存储数据的方式，我们已经在数据结构中做了详细的介绍，读者可猛击《<a target="_blank" rel="noopener" href="https://c.biancheng.net/view/vip_3433.html">红黑树</a>》一文做详细了解。</p>
<hr>
<h2 id="C-STL关联式容器种类"><a href="#C-STL关联式容器种类" class="headerlink" title="C++ STL关联式容器种类"></a>C++ STL关联式容器种类</h2><table>
<thead>
<tr>
<th>关联式容器名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</T></map></td>
</tr>
<tr>
<td>set</td>
<td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</T></set></td>
</tr>
<tr>
<td>multimap</td>
<td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</map></td>
</tr>
<tr>
<td>multiset</td>
<td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</set></td>
</tr>
</tbody></table>
<p>这里为 map 容器为例，编写了一个样例（如下所示）。对于该程序，读者只需体会关联式容器的特性即可，无需纠结 map 容器的具体用法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map 容器在存储元素时，会根据各个元素键的大小自动调整元素的顺序（默认按照升序排序）</p>
<h2 id="STL-pair用法"><a href="#STL-pair用法" class="headerlink" title="STL pair用法"></a>STL pair用法</h2><p>关联式容器存储的是“键值对”形式的数据，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&gt;;</span><br><span class="line">&lt;<span class="string">&quot;b&quot;</span>,<span class="number">214</span>&gt;</span><br></pre></td></tr></table></figure>

<p>每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）</p>
<p>基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。</p>
<p>虑到“键值对”并不是普通类型数据，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p>
<p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="type">const</span> first_type&amp; a, <span class="type">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(<span class="type">const</span> pair&lt;U,V&gt;&amp; pr)</span></span>;</span><br><span class="line"><span class="comment">//C++11引入右值引用</span></span><br><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(pair&lt;U,V&gt;&amp;&amp; pr)</span></span>;<span class="comment">//一般使用make_pair(U u,T t)作为移动构造函数返回</span></span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(U&amp;&amp; a, V&amp;&amp; b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++ 11 还允许我们手动为 pair1 对象赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pairl.first=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">pairl.second=<span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小</p>
<p>注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。也就是说相同类型的pair</p>
<p>pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p>
<hr>
<h2 id="STL-map"><a href="#STL-map" class="headerlink" title="STL map"></a>STL map</h2><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p>
<blockquote>
<p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p>
</blockquote>
<p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p>
<p>另外需要注意的是，&#x3D;&#x3D;<strong>使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</strong>&#x3D;&#x3D;换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>
<blockquote>
<p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair&lt;const K, T&gt; 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p>
</blockquote>
<h3 id="创建C-map容器的几种方法"><a href="#创建C-map容器的几种方法" class="headerlink" title="创建C++ map容器的几种方法"></a>创建C++ map容器的几种方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap;</span><br><span class="line"><span class="comment">// 当然在创建 map 容器的同时，也可以进行初始化</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;              </span><br><span class="line"><span class="comment">//在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(myMap);                   <span class="comment">//C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。 #创建一个会返回临时 map 对象的函数</span></span><br><span class="line"><span class="function">std::map&lt;std::string,<span class="type">int</span>&gt; <span class="title">disMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br><span class="line"><span class="comment">//map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less&lt;T&gt; 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。*/</span>                     </span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//手动修改了 myMap 容器的排序规则，令其作降序排序</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;               </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-map容器包含的成员方法"><a href="#C-map容器包含的成员方法" class="headerlink" title="C++ map容器包含的成员方法"></a>C++ map容器包含的成员方法</h3><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<h3 id="STL-map容器迭代器"><a href="#STL-map容器迭代器" class="headerlink" title="STL map容器迭代器"></a>STL map容器迭代器</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符进行比较。</p>
<p>相比序列式容器，map 容器提供了更多的成员方法（如表 1 所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
</tbody></table>
<p><img src="/../typora-user-images/2-19112Q14QE40.png" alt="C++ STL map部分成员方法示意图"></p>
<p>map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p>
<ul>
<li>&#x3D;&#x3D;lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；&#x3D;&#x3D;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</code></p>
<p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p>
<p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="map获取键对应值的几种方法"><a href="#map获取键对应值的几种方法" class="headerlink" title="map获取键对应值的几种方法"></a>map获取键对应值的几种方法</h3><p>map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p>
<blockquote>
<p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p>
</blockquote>
<ol>
<li>map 类模板中对<code>[ ]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li>
</ol>
<p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</p>
<ol start="2">
<li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</li>
</ol>
<p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p>
<hr>
<h3 id="map-insert-插入数据的4种方式"><a href="#map-insert-插入数据的4种方式" class="headerlink" title="map insert()插入数据的4种方式"></a>map insert()插入数据的4种方式</h3><p>除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p>
<p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p>
<p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p>
<ol>
<li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">  <span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li>
<li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li>
</ul>
<ol start="2">
<li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p>
<ul>
<li><p>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</p>
</li>
<li><p>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p>
<ol start="3">
<li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java教程 http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序中，&lt;first,last&gt; 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</p>
<ol start="4">
<li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，vali 都表示的是键值对变量。</p>
<hr>
<h3 id="map容器operator-和insert-效率对比"><a href="#map容器operator-和insert-效率对比" class="headerlink" title="map容器operator[]和insert()效率对比"></a>map容器operator[]和insert()效率对比</h3><p>通过前面的学习我们知道，map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。 举个例子（程序一）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::map&lt;string, string&gt; mymap;</span><br><span class="line">  <span class="comment">//借用 operator[] 添加新键值对</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Bear\&quot;,\&quot;deviceid\&quot;:\&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;old mymap：&quot;</span>) &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 operator[] 更新某个键对应的值</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new mymap：&quot;</span> &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//借用insert()添加新键值对</span></span><br><span class="line">  std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;Javaplayer_02&quot;</span>,<span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;C++\&quot;,\&quot;deviceid\&quot;:\&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span> &#125;;</span><br><span class="line">  std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret;</span><br><span class="line">  ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;old ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 insert() 更新键值对</span></span><br><span class="line">  mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;node js&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new ret.iter = &lt;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">old mymap：&#123;&quot;username&quot;:&quot;Bear&quot;,&quot;deviceid&quot;:&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">new mymap：&#123;&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">old ret.iter = &lt;&#123;Javaplayer_02, &#123;&quot;username&quot;:&quot;C++&quot;,&quot;deviceid&quot;:&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">new ret.iter = &lt;Javaplayer_02, node js&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;**当实现“向 map <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。 **&#x3D;&#x3D;</p>
<h4 id="向map容器中增添元素，insert-效率更高"><a href="#向map容器中增添元素，insert-效率更高" class="headerlink" title="向map容器中增添元素，insert()效率更高"></a>向map容器中增添元素，insert()效率更高</h4><p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>mymap[“player_01”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。 但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “{&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;}” 赋值给这个 string 对象。 也就是说，上面这行代码的执行流程，可以等效为如下程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="type">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;player_01&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这里的 value_type(K,T) 指的是 map 容器中存储元素的类型，其实际上就等同于 pair&lt;K,T&gt;。</p>
<p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，<strong>先构造一个有默认值的键值对，然后再为其 value 赋值</strong>。 那么，为什么不直接构造一个要添加的键值对元素呢，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;脱发严重&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高。</p>
<h4 id="更新map容器中的键值对，operator-效率更高"><a href="#更新map容器中的键值对，operator-效率更高" class="headerlink" title="更新map容器中的键值对，operator[]效率更高"></a>更新map容器中的键值对，operator[]效率更高</h4><p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//operator[]</span></span><br><span class="line">mymap[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;脱发&quot;</span>;</span><br><span class="line"><span class="comment">//insert()</span></span><br><span class="line">std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;node&quot;</span>,<span class="string">&quot;霸王洗发水&quot;</span> &#125;;</span><br><span class="line">mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;还是霸王洗发水好&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</code></p>
<h3 id="map-emplace-和emplace-hint-方法详解"><a href="#map-emplace-和emplace-hint-方法详解" class="headerlink" title="map emplace()和emplace_hint()方法详解"></a>map emplace()和emplace_hint()方法详解</h3><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。本节就来讲解这 2 个成员方法的用法。</p>
<p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高（后续章节会详细讲解）。</p>
<p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p>
<p>template &lt;class… Args&gt;<br> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;… args);</p>
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li>
<li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">2、ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">3、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 0&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p>
<ol>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ol>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//指定在 map 容器插入键值对</span></span><br><span class="line">    map&lt;string, string&gt;::iterator iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(),<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">C语言教程 http://c.biancheng.net/c/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p>
<p>那么，为什么 emplace() 和 emplace_hint() 方法的执行效率，比 insert() 高呢？</p>
<p><strong>C++11新增的emplace() 和 emplace_hint()都比insert效率高</strong></p>
<p>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</p>
<p>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">emplace_hint():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在map 容器内部直接构造的键值对。</strong></p>
<p>因此，<strong>在实现向 map 容器中插入键值对时，应优先考虑使用 emplace() 或者 emplace_hint()。</strong></p>
<hr>
<h2 id="multimap容器用法完全攻略"><a href="#multimap容器用法完全攻略" class="headerlink" title="multimap容器用法完全攻略"></a>multimap容器用法完全攻略</h2><p>掌握 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> map 容器的基础上，本节再讲一个和 map 相似的关联式容器，即 multimap 容器。</p>
<p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，<strong>multimap 容器中可以同时存储多（≥2）个键相同的键值对。</strong></p>
<p>和 map 容器一样，实现 multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>multimap 容器类模板的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br></pre></td></tr></table></figure>

<h3 id="创建C-multimap容器的方法"><a href="#创建C-multimap容器的方法" class="headerlink" title="创建C++ multimap容器的方法"></a>创建C++ multimap容器的方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multimap&lt;std::string, std::string&gt;mymultimap;</span><br><span class="line"><span class="comment">//通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="comment">/*使用此方式初始化 multimap 容器时，其底层会先将每一个&#123;key, value&#125;创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：*/</span></span><br><span class="line"><span class="comment">//借助 pair 类模板的构造函数来生成各个pair类型的键值对</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    pair&lt;string,string&gt;&#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 make_pair() 函数，生成键值对元素</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(mymultimap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。*/</span></span><br><span class="line"><span class="comment">//创建一个会返回临时 multimap 对象的函数</span></span><br><span class="line"><span class="function">multimap&lt;string, string&gt; <span class="title">dismultimap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    multimap&lt;string, string&gt;tempmultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,&#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 multimap 类模板的移动构造函数创建 newMultimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(<span class="built_in">dismultimap</span>());</span><br><span class="line"><span class="comment">/*上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</span></span><br><span class="line"><span class="comment">注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。*/</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(++mymultimap.<span class="built_in">begin</span>(), mymultimap.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为std::less&lt;T&gt;，这意味着以下 2 种创建 multimap 容器的方式是等价的：*/</span></span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>, std::less&lt;<span class="type">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-multimap容器包含的成员方法"><a href="#C-multimap容器包含的成员方法" class="headerlink" title="C++ multimap容器包含的成员方法"></a>C++ multimap容器包含的成员方法</h3><p>列出了 multimap 类模板提供的常用成员方法及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multimap 容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multimap 容器中插入键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。&#x3D;&#x3D;这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p>
<p><code>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">count</span>(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.<span class="built_in">begin</span>(); iter != mymultimap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">a 10</span></span><br><span class="line"><span class="comment">b 20</span></span><br><span class="line"><span class="comment">b 15</span></span><br><span class="line"><span class="comment">c 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="STL-set"><a href="#STL-set" class="headerlink" title="STL set"></a>STL set</h2><p>前面章节讲解了 map 容器和 multimap 容器的用法，类似地，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联式容器。不过，本节先讲解 set 容器，后续章节再讲解 multiset 容器。</p>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p>
<p>举个例子，如下有 2 组键值对数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>&gt;&#125;</span><br><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p>
<p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p>
<p>通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p>
<p>另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</p>
<p><code>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</code></p>
<h3 id="创建C-set容器的几种方法"><a href="#创建C-set容器的几种方法" class="headerlink" title="创建C++ set容器的几种方法"></a>创建C++ set容器的几种方法</h3><ol>
<li>调用默认构造函数，创建空的 set 容器。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p>
<ol start="2">
<li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</T></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。</li>
</ol>
<p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;<span class="comment">//等同于//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure>

<p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p>
<p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;    <span class="keyword">return</span> myset;&#125;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;<span class="comment">//或者//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure>

<p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<ol start="4">
<li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</string></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-STL-set容器包含的成员方法"><a href="#C-STL-set容器包含的成员方法" class="headerlink" title="C++ STL set容器包含的成员方法"></a>C++ STL set容器包含的成员方法</h3><p> 列出了 set 容器提供的常用成员方法以及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、myset size = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/java/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="set容器迭代器"><a href="#set容器迭代器" class="headerlink" title="set容器迭代器"></a>set容器迭代器</h3><p>和 map 容器不同，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</p>
<p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符。</p>
<p>在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p>
</blockquote>
<p>图 2 演示了表 1 中除最后 4 个成员函数外，其它几个成员函数的具体功能。</p>
<p><img src="/../typora-user-images/set.png" alt="2-19112Q14QE40-1710858859716-3"></p>
<p>下面程序以 begin()&#x2F;end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure>

<p><code>如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。</code></p>
<p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p>
<p>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">find</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;iter != myset.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure>

<p><code>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</code></p>
<hr>
<h3 id="set-insert-方法"><a href="#set-insert-方法" class="headerlink" title="set insert()方法"></a>set insert()方法</h3><p>我们已经学会如何创建一个 set 容器。在此基础上，如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。</p>
<p>为满足不同场景的需要，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p>
<ol>
<li>只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。</p>
<p>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p>
<ul>
<li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li>
<li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="type">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/stl/ bool = 1</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/python/ bool = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p>
<ul>
<li><p>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</p>
</li>
<li><p>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*myset size =1</span></span><br><span class="line"><span class="comment">myset size =2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</code></p>
<ol start="3">
<li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p>
<ol start="4">
<li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">( &#123;E1, E2,...,En&#125; )</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//向 myset 中添加多个元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>即为 set 类模板中 insert() 成员方法的全部用法。指的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。</p>
<hr>
<h3 id="set-emplace-和emplace-hint"><a href="#set-emplace-和emplace-hint" class="headerlink" title="set emplace()和emplace_hint()"></a>set emplace()和emplace_hint()</h3><p>下面程序演示 emplace() 方法的具体用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">ret.iter = &lt;http://c.biancheng.net/stl/, 1&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p>
<p>emplace_hint() 方法的功能和 emplace() 类似</p>
<p>下面程序演示 emplace_hint() 方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的，这里不再赘述。</p>
<h3 id="set删除数据：erase-和clear"><a href="#set删除数据：erase-和clear" class="headerlink" title="set删除数据：erase()和clear()"></a>set删除数据：erase()和clear()</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p>
<p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</p>
<blockquote>
<p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="type">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">5</span></span><br><span class="line"><span class="number">1</span>、myset size = <span class="number">4</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">iter-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>、myset size = <span class="number">1</span></span><br><span class="line">iter2-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h2><p>对 set 容器做了详细的讲解。回忆一下，set 容器具有以下几个特性：</p>
<ul>
<li>不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；</li>
<li>set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；</li>
<li>存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；</li>
<li>set 容器存储的元素必须互不相等。</li>
</ul>
<p>在此基础上，<a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。</p>
<p><code>也就是说，multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。</code></p>
<h3 id="创建C-multiset容器的方法"><a href="#创建C-multiset容器的方法" class="headerlink" title="创建C++ multiset容器的方法"></a>创建C++ multiset容器的方法</h3><p>multiset 类模板中提供了 5 种构造函数，也就代表有 5 种创建 multiset 容器的方式</p>
<ol>
<li>调用默认构造函数，创建空的 multiset 容器。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p>
</blockquote>
<p>由此就创建好了一个 mymultiset 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。</p>
<blockquote>
<p>注意，由于 multiset 容器支持随时向内部添加新的元素，因此创建空 multiset 容器的方法比较常用。</p>
</blockquote>
<ol start="2">
<li>除此之外，multiset 类模板还支持在创建 multiset 容器的同时，对其进行初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>由此即创建好了包含 3 个 string 元素的 mymultiset 容器。由于其采用默认的<code>std::less&lt;T&gt;</code>规则，因此其内部存储 string 元素的顺序如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/java/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>multiset 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 multiset 容器的同时，将已有 multiset 容器中存储的所有元素全部复制到新 multiset 容器中。</li>
</ol>
<p>例如，在第 2 种方式创建的 mymultiset 容器的基础上，执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::multiset&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(mymultiset)</span></span>;<span class="comment">//等同于//std::multiset&lt;std::string&gt; copymultiset = mymultiset;</span></span><br></pre></td></tr></table></figure>

<p>该行代码在创建 copymultiset 容器的基础上，还会将 mymultiset 容器中存储的所有元素，全部复制给 copymultiset 容器一份。</p>
<p>另外，C++ 11 标准还为 multiset 类模板新增了移动构造函数，其功能是实现创建新 multiset 容器的同时，利用临时的 multiset 容器为其初始化。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">multiset&lt;string&gt; <span class="title">retMultiset</span><span class="params">()</span> </span>&#123;    std::multiset&lt;std::string&gt; tempmultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;    <span class="keyword">return</span> tempmultiset;&#125;<span class="function">std::multiset&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(retMultiset())</span></span>;<span class="comment">//等同于//std::multiset&lt;std::string&gt; copymultiset = retMultiset();</span></span><br></pre></td></tr></table></figure>

<p>注意，由于 retMultiset() 函数的返回值是一个临时 multiset 容器，因此在初始化 copymultiset 容器时，其内部调用的是 multiset 类模板中的移动构造函数，而非拷贝构造函数。</p>
<blockquote>
<p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p>
</blockquote>
<ol start="4">
<li>在第 3 种方式的基础上，multiset 类模板还支持取已有 multiset 容器中的部分元素，来初始化新 multiset 容器。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;<span class="function">std::set&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(++mymultiset.begin(), mymultiset.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br></pre></td></tr></table></figure>



<ol start="5">
<li>以上几种方式创建的 multiset 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 multiset 类模板定义中的第 2 个参数，我们完全可以手动修改 multiset 容器中的排序规则。</li>
</ol>
<p>下面样例中，使用了 STL 标准库提供的 std::greater<T> 排序方法，作为 multiset 容器内部的排序规则：</T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string, std::greater&lt;string&gt; &gt; mymultiset&#123;    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>通过选用<code>std::greater&lt;string&gt;</code>降序规则，mymultiset 容器中元素的存储顺序为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/java/&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="C-multiset容器提供的成员方法"><a href="#C-multiset容器提供的成员方法" class="headerlink" title="C++ multiset容器提供的成员方法"></a>C++ multiset容器提供的成员方法</h3><p>multiset 容器提供的成员方法，和 set 容器提供的完全一样.</p>
<p><code>注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; mymultiset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset size = &quot;</span> &lt;&lt; mymultiset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset count(2) =&quot;</span> &lt;&lt; mymultiset.<span class="built_in">count</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向容器中添加元素 8</span></span><br><span class="line">    mymultiset.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//删除容器中所有值为 2 的元素</span></span><br><span class="line">    <span class="type">int</span> num = mymultiset.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除了 &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 个元素 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出容器中存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultiset.<span class="built_in">begin</span>(); iter != mymultiset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiset size = <span class="number">7</span></span><br><span class="line">multiset <span class="built_in">count</span>(<span class="number">2</span>) =<span class="number">3</span></span><br><span class="line">删除了 <span class="number">3</span> 个元素 <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="STL关联式容器自定义排序规则【函数对象】"><a href="#STL关联式容器自定义排序规则【函数对象】" class="headerlink" title="STL关联式容器自定义排序规则【函数对象】"></a>STL关联式容器自定义排序规则【函数对象】</h2><h3 id="1-使用函数对象"><a href="#1-使用函数对象" class="headerlink" title="1 - 使用函数对象"></a>1 - 使用函数对象</h3><p>无论关联式容器中存储的是基础类型（如 int、double、float 等）数据，还是自定义的结构体变量或类对象（包括 string 类），都可以使用<strong>函数对象</strong>的方式为该容器自定义排序规则。</p>
<p>如果一个类将<code>()</code>运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/354.html">C++函数对象详解（附带实例）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAverage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">average</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>()</code>是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</p>
<p><img src="/../typora-user-images/class.png" alt="函数对象类模板"></p>
<p>例如，如果要求两个 double 型变量 x、y 的乘积，可以写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiplies</span>&lt;<span class="type">double</span>&gt; () (x, y)<span class="comment">//首先用multiplies实例化了一个暂时的对象，构造该对象时传入参数x y</span></span><br></pre></td></tr></table></figure>

<p>less 是 STL 中最常用的函数对象类模板，其定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(const_Tp &amp; __x, const_Tp &amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：</span></span><br><span class="line"><span class="comment">//if( less&lt;int&gt;()(x, y) ) &#123; 操作 &#125;</span></span><br></pre></td></tr></table></figure>

<p>常用的可供关联容器使用的排序规则为</p>
<p><img src="/../typora-user-images/so.png" alt="在这里插入图片描述"></p>
<h3 id="2-重载关系运算符实现自定义排序"><a href="#2-重载关系运算符实现自定义排序" class="headerlink" title="2 - 重载关系运算符实现自定义排序"></a>2 - 重载<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">关系运算符</a>实现自定义排序</h3><p>当关联式容器中存储的数据类型为自定义的结构体变量或者类对象时，通过对现有排序规则中所用的关系运算符进行重载，也能实现自定义排序规则的目的。</p>
<blockquote>
<p>注意，当关联式容器中存储的元素类型为<strong>结构体指针变量或者类的指针对象</strong>时，只能使用函数对象的方式自定义排序规则，此方法不再适用。</p>
</blockquote>
<hr>
<h2 id="如何修改关联式容器中键值对的键"><a href="#如何修改关联式容器中键值对的键" class="headerlink" title="如何修改关联式容器中键值对的键"></a>如何修改关联式容器中键值对的键</h2><p>首先可以明确的是，map 和 multimap 容器只能采用“先删除，再添加”的方式修改某个键值对的键。原因很简单，C++ STL 标准中明确规定，map 和 multimap 容器用于存储类型为 pair 的键值对。显然，只要目标键值对存储在当前容器中，键的值就无法被修改。</p>
<p>直接修改 map 或 multimap 容器中某个键值对的键是行不通的。但对于 set 或者 multiset 容器来说，却是可行的。</p>
<p>和 map、multimap 不同，C++ STL 标准中并没有用 const 限定 set 和 multiset 容器中存储元素的类型。换句话说，对于 set 或者 multiset 类型的容器，其存储元素的类型是 T 而不是 const T。</p>
<p>对 set 和 multiset 容器中的元素类型作 const 修饰，是违背常理的。举个例子，假设我们使用 set 容器存储多个学生信息，如下是一个表示学生的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">student</span>(string name, <span class="type">int</span> id, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">id</span>(id), <span class="built_in">age</span>(age) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(<span class="type">const</span> string name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getname</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setage</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建 set 容器之前，我们还需要为其设计一个排序规则，这里假定以每个学生的 id 做升序排序，其排序规则如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> student &amp;stua, <span class="type">const</span> student &amp;stub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符串的长度，做升序排序(即存储的字符串从短到长)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stua.<span class="built_in">getid</span>() &lt; stub.<span class="built_in">getid</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>做完以上所有的准备工作后，就可以创建一个可存储 student 对象的 set 容器了，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set myset&#123; &#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>,<span class="number">21</span>&#125;,&#123;<span class="string">&quot;wangwu&quot;</span>,<span class="number">15</span>,<span class="number">19</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>由此创建的 myset 容器中，存储的数据依次为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>,<span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;wangwu&quot;</span>,<span class="number">15</span>,<span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>,<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意，set 容器中每个元素也可以看做是键和值相等的键值对，但对于这里的 myset 容器来说，其实每个 student 对象的 id 才是真正的键，其它信息(name 和 age)只不过是和 id 绑定在一起而已。因此，在不破坏 myset 容器中元素的有序性的前提下(即不修改每个学生的 id)，学生的其它信息是应该允许修改的，但有一个前提，即 myset 容器中存储的各个 student 对象不能被 const 修饰(这也是 set 容器中的元素类型不能被 const 修饰的原因)。</p>
<p>总之，set 和 multiset 容器的元素类型没有用 const 修饰。所以从语法的角度分析，&#x3D;&#x3D;我们可以直接修改容器中元素的值，但一定不要修改元素的键。&#x3D;&#x3D;</p>
<p>在已创建好的 myset 容器的基础上，如下代码尝试修改 myset 容器中某个学生的 name 名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set::iterator iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">(*iter).<span class="built_in">setname</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它也是无法通过编译的。</p>
<p>虽然 C++ STL 标准没有用 const 修饰 set 或者 multiset 容器中元素的类型，但也做了其它工作来限制用户修改容器的元素。例如上面代码中，***iter 会调用 *operator，其返回的是一个 const T&amp; 类型元素。**这意味着，C++ STL 标准不允许用户借助迭代器来直接修改 set 或者 multiset 容器中的元素。<br>如何才能正确修改 set 或 multiset 容器中的元素呢？最直接的方式就是借助 const_cast运算符，该运算符可以去掉指针或者引用的 const 限定符。</p>
<p>比如，我们只需要借助 const_cast 运算符对上面程序稍作修改，就可以运行成功：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set::iterator iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">const_cast</span>(*iter).<span class="built_in">setname</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此，mymap 容器中的 {“zhangsan”,10,20} 就变成了 {“xiaoming”,10,20}。</p>
<p>再次强调，&#x3D;&#x3D;虽然使用 const_cast 能直接修改 set 或者 multiset 容器中的元素，但一定不要修改元素的键！&#x3D;&#x3D;如果要修改，只能采用“先删除，再添加”的方式。另外，不要试图以同样的方式修改 map 或者 multimap 容器中键值对的键，这违反了 C++ STL 标准的规定。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，map 和 multimap 容器中元素的键是无法直接修改的，但借助 const_cast，我们可以直接修改 set 和 multiset 容器中元素的非键部分。</p>
<hr>
<h1 id="STL无序关联式容器"><a href="#STL无序关联式容器" class="headerlink" title="STL无序关联式容器"></a>STL无序关联式容器</h1><p>除了序列式容器和关联式容器之外，C++ 11 标准库又引入了一类容器，即无序关联式容器。</p>
<p>无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。</p>
<p>和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。</p>
<h2 id="STL无序容器（哈希容器）是什么？"><a href="#STL无序容器（哈希容器）是什么？" class="headerlink" title="STL无序容器（哈希容器）是什么？"></a>STL无序容器（哈希容器）是什么？</h2><p>继 <strong>map、multimap、set、multiset</strong> 关联式容器之后，从本节开始，再讲解一类“特殊”的关联式容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。</p>
<p>&#x3D;&#x3D;注意，无序容器是 <a target="_blank" rel="noopener" href="https://c.biancheng.net/cplus/">C++</a> 11 标准才正式引入到 <a target="_blank" rel="noopener" href="https://c.biancheng.net/stl/">STL</a> 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。&#x3D;&#x3D;</p>
<p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，因为它们有本质上的不同：</p>
<ul>
<li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li>
<li>无序容器的底层实现采用的是哈希表的存储结构。</li>
</ul>
<p><code>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。</code></p>
<p>基于底层实现采用了不同的<a target="_blank" rel="noopener" href="https://c.biancheng.net/data_structure/">数据结构</a>，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>
<ol>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ol>
<h3 id="C-STL无序容器种类"><a href="#C-STL无序容器种类" class="headerlink" title="C++ STL无序容器种类"></a>C++ STL无序容器种类</h3><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为<strong>unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</strong></p>
<table>
<thead>
<tr>
<th>无序容器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>unordered_map</td>
<td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td>unordered_set</td>
<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
<p>以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。</p>
<p>既然无序容器和之前所学的关联式容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p>
<h2 id="unordered-map容器"><a href="#unordered-map容器" class="headerlink" title="unordered_map容器"></a>unordered_map容器</h2><p>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<p>unordered_map 容器模板的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                        <span class="comment">//键值对中键的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                          <span class="comment">//键值对中值的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;Key&gt;,           <span class="comment">//容器内部存储键值对所用的哈希函数</span></span><br><span class="line">           <span class="keyword">class</span> Pred = equal_to&lt;Key&gt;,       <span class="comment">//判断各个键值对键相同的规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> unordered_map;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;key,T&gt;</td>
<td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td>
</tr>
<tr>
<td>Hash &#x3D; hash<Key></Key></td>
<td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</key></td>
</tr>
<tr>
<td>Pred &#x3D; equal_to<Key></Key></td>
<td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 &#x3D;&#x3D; 运算符做比较的数据类型。</key></td>
</tr>
</tbody></table>
<blockquote>
<p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。至于如何实现自定义，后续章节会做详细讲解。</p>
</blockquote>
<h3 id="创建C-unordered-map容器的方法"><a href="#创建C-unordered-map容器的方法" class="headerlink" title="创建C++ unordered_map容器的方法"></a>创建C++ unordered_map容器的方法</h3><ol>
<li>通过调用 unordered_map 模板类的默认构造函数，可以创建空的 unordered_map 容器。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap;</span><br></pre></td></tr></table></figure>

<p>由此，就创建好了一个可存储 &lt;string,string&gt; 类型键值对的 unordered_map 容器。</p>
<ol start="2">
<li>当然，在创建 unordered_map 容器的同时，可以完成初始化操作。比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap&#123;    &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,    &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,    &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>通过此方法创建的 umap 容器中，就包含有 3 个键值对元素。</p>
<ol start="3">
<li>另外，还可以调用 unordered_map 模板中提供的复制（拷贝）构造函数，将现有 unordered_map 容器中存储的键值对，复制给新建 unordered_map 容器。</li>
</ol>
<p>例如，在第二种方式创建好 umap 容器的基础上，再创建并初始化一个 umap2 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unordered_map&lt;std::string, std::string&gt; <span class="title">umap2</span><span class="params">(umap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由此，umap2 容器中就包含有 umap 容器中所有的键值对。</p>
<p>除此之外，C++ 11 标准中还向 unordered_map 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_map 容器中存储的所有键值对，全部复制给新建容器。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回临时 unordered_map 容器的函数</span></span><br><span class="line">std::unordered_map &lt;std::string, std::string &gt; <span class="built_in">retUmap</span>()&#123;    std::unordered_map&lt;std::string, std::string&gt;tempUmap&#123;        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;    <span class="keyword">return</span> tempUmap;&#125;<span class="comment">//调用移动构造函数，创建 umap2 容器std::unordered_map&lt;std::string, std::string&gt; umap2(retUmap());</span></span><br></pre></td></tr></table></figure>

<p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p>
<ol start="4">
<li>当然，如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入 2 个迭代器，</span></span><br><span class="line"><span class="function">std::unordered_map&lt;std::string, std::string&gt; <span class="title">umap2</span><span class="params">(++umap.begin(),umap.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</p>
<h3 id="C-unordered-map容器的成员方法"><a href="#C-unordered-map容器的成员方法" class="headerlink" title="C++ unordered_map容器的成员方法"></a>C++ unordered_map容器的成员方法</h3><p>unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。因此在该容器模板类中，既包含一些在学习关联式容器时常见的成员方法，还有一些属于无序容器特有的成员方法。</p>
<p>表 2 列出了 unordered_map 类模板提供的所有常用的成员方法以及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>operator[key]</td>
<td>该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td>
</tr>
<tr>
<td>at(key)</td>
<td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找以 key 键的键值对的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储键值对的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回以 key 为键的键值对所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_map 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody></table>
<p>注意，对于实现互换 2 个相同类型 unordered_map 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="C-无序容器的底层实现机制"><a href="#C-无序容器的底层实现机制" class="headerlink" title="C++无序容器的底层实现机制"></a>C++无序容器的底层实现机制</h2><p>我们先考虑最简单的情况，<strong>仅用一个数组来实现哈希表</strong>。在哈希表中，我们将数组中的每个空位称为「桶 bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 <code>key</code> 对应的桶，并在桶中获取 <code>value</code> 。</p>
<p>那么，如何基于 <code>key</code> 定位对应的桶呢？这是通过「哈希函数 hash function」实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code> ，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code> ，<strong>我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置</strong>。</p>
<p>输入一个 <code>key</code> ，哈希函数的计算过程分为以下两步。</p>
<ol>
<li>通过某种哈希算法 <code>hash()</code> 计算得到哈希值。</li>
<li>将哈希值对桶数量（数组长度）<code>capacity</code> 取模，从而获取该 <code>key</code> 对应的数组索引 <code>index</code> 。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">index = <span class="built_in">hash</span>(key) % capacity</span><br></pre></td></tr></table></figure>

<p>随后，我们就可以利用 <code>index</code> 在哈希表中访问对应的桶，从而获取 <code>value</code> 。</p>
<p>设数组长度 <code>capacity = 100</code>、哈希算法 <code>hash(key) = key</code> ，易得哈希函数为 <code>key % 100</code> 。图 6-2 以 <code>key</code> 学号和 <code>value</code> 姓名为例，展示了哈希函数的工作原理。</p>
<p><img src="/../typora-user-images/hash_function.png" alt="哈希函数工作原理"></p>
<p>以下代码实现了一个简单哈希表。其中，我们将 <code>key</code> 和 <code>value</code> 封装成一个类 <code>Pair</code> ，以表示键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 键值对 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">int</span> key, string val) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于数组实现的哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Pair *&gt; buckets;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化数组，包含 100 个桶</span></span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">delete</span> bucket;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = key % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        Pair *pair = buckets[index];</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        Pair *pair = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        buckets[index] = pair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 释放内存并置为 nullptr</span></span><br><span class="line">        <span class="keyword">delete</span> buckets[index];</span><br><span class="line">        buckets[index] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键值对 */</span></span><br><span class="line">    <span class="function">vector&lt;Pair *&gt; <span class="title">pairSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;Pair *&gt; pairSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pairSet.<span class="built_in">push_back</span>(pair);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keySet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                keySet.<span class="built_in">push_back</span>(pair-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有值 */</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">valueSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; valueSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                valueSet.<span class="built_in">push_back</span>(pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *kv : <span class="built_in">pairSet</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h3><p>从本质上看，哈希函数的作用是将所有 <code>key</code> 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，<strong>理论上一定存在“多个输入对应相同输出”的情况</strong>。</p>
<p>对于上述示例中的哈希函数，当输入的 <code>key</code> 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12836 % 100 = 36</span><br><span class="line">20336 % 100 = 36</span><br></pre></td></tr></table></figure>

<p>如图 6-3 所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为「哈希冲突 hash collision」。</p>
<p><img src="/../typora-user-images/hash_collision.png" alt="哈希冲突示例"></p>
<p>容易想到，哈希表容量 n 越大，多个 <code>key</code> 被分配到同一个桶中的概率就越低，冲突就越少。因此，<strong>我们可以通过扩容哈希表来减少哈希冲突</strong>。</p>
<p>扩容前键值对 <code>(136, A)</code> 和 <code>(236, D)</code> 发生冲突，扩容后冲突消失。</p>
<p><img src="/../typora-user-images/hash_table_reshash.png" alt="哈希表扩容"></p>
<p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 <code>capacity</code> 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p>
<p>「负载因子 load factor」是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，<strong>也常作为哈希表扩容的触发条件</strong>。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表扩容至原先的 2 倍。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p><strong>通常情况下哈希函数的输入空间远大于输出空间</strong>，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</p>
<p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p>
<ol>
<li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
</ol>
<p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</p>
<h4 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h4><p>在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图 6-5 展示了一个链式地址哈希表的例子。</p>
<p><img src="/../typora-user-images/hash_table_chaining.png" alt="链式地址哈希表"></p>
<p>基于链式地址实现的哈希表的操作方法发生了以下变化。</p>
<ul>
<li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li>
<li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li>
<li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li>
</ul>
<p>链式地址存在以下局限性。</p>
<ul>
<li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li>
</ul>
<p>以下代码给出了链式地址哈希表的简单实现，需要注意两点。</p>
<ul>
<li>使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</li>
<li>以下实现包含哈希表扩容方法。当负载因子超过 2&#x2F;3 时，我们将哈希表扩容至原先的 2 倍。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3.0</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapChaining</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key) &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，当链表很长时，查询效率 O(n) 很差。<strong>此时可以将链表转换为“AVL 树”或“红黑树”</strong>，从而将查询操作的时间复杂度优化至 O(log⁡n) 。</p>
<h4 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h4><p>「开放寻址 open addressing」不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p>
<p>下面以线性探测为例，介绍开放寻址哈希表的工作机制。</p>
<h5 id="1-线性探测¶"><a href="#1-线性探测¶" class="headerlink" title="1.  线性探测¶"></a>1.  线性探测<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision/#1">¶</a></h5><p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p>
<ul>
<li><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。</li>
<li><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</li>
</ul>
<p>图 6-6 展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 <code>key</code> 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。</p>
<p><img src="/../typora-user-images/hash_table_linear_probing.png" alt="开放寻址（线性探测）哈希表的键值对分布"></p>
<p>然而，<strong>线性探测容易产生“聚集现象”</strong>。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p>
<p>值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如图 6-7 所示。</p>
<p><img src="/../typora-user-images/hash_table_open_addressing_deletion.png" alt="在开放寻址中删除元素导致的查询问题"></p>
<p>为了解决该问题，我们可以采用「懒删除 lazy deletion」机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p>
<p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p>
<p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p>
<p>以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                             <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                     <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;     <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> extendRatio = <span class="number">2</span>;            <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets;               <span class="comment">// 桶数组</span></span><br><span class="line">    Pair *TOMBSTONE = <span class="keyword">new</span> <span class="built_in">Pair</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapOpenAddressing</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">buckets</span>(capacity, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapOpenAddressing</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> TOMBSTONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBucket</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="type">int</span> firstTombstone = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index]-&gt;key == key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != <span class="number">-1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == <span class="number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == <span class="number">-1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index]-&gt;val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">delete</span> buckets[index];</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;Pair *&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="literal">nullptr</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;TOMBSTONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-平方探测¶"><a href="#2-平方探测¶" class="headerlink" title="2.  平方探测¶"></a>2.  平方探测<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision/#2">¶</a></h5><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。</p>
<p>平方探测主要具有以下优势。</p>
<ul>
<li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li>
<li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li>
</ul>
<p>然而，平方探测并不是完美的。</p>
<ul>
<li>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</li>
<li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</li>
</ul>
<h5 id="3-多次哈希¶"><a href="#3-多次哈希¶" class="headerlink" title="3.  多次哈希¶"></a>3.  多次哈希<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision/#3">¶</a></h5><p>顾名思义，多次哈希方法使用多个哈希函数 f1(x)、f2(x)、f3(x)、… 进行探测。</p>
<ul>
<li><strong>插入元素</strong>：若哈希函数 f1(x) 出现冲突，则尝试 f2(x) ，以此类推，直到找到空位后插入元素。</li>
<li><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</li>
</ul>
<p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p>
<p>&#x3D;&#x3D;请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题.&#x3D;&#x3D;</p>
<hr>
<p>各种编程语言采取了不同的哈希表实现策略，下面举几个例子。</p>
<ul>
<li>Python 采用开放寻址。字典 <code>dict</code> 使用伪随机数进行探测。</li>
<li>Java 采用链式地址。自 JDK 1.8 以来，当 <code>HashMap</code> 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。</li>
<li>Go 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。</li>
</ul>
<hr>
<h2 id="unordered-map迭代器的用法"><a href="#unordered-map迭代器的用法" class="headerlink" title="unordered_map迭代器的用法"></a>unordered_map迭代器的用法</h2><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
</tbody></table>
<p>值得一提的是，equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 存储的键值对包括：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历输出 umap 容器中所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指向指定键值对的前向迭代器</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;umap.find(\&quot;Java教程\&quot;) = &quot;</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行结果为：</span></span><br><span class="line">umap 存储的键值对包括：</span><br><span class="line">&lt;Python教程, http:<span class="comment">//c.biancheng.net/python/&gt;</span></span><br><span class="line">&lt;Linux教程, http:<span class="comment">//c.biancheng.net/linux/&gt;</span></span><br><span class="line">&lt;Java教程, http:<span class="comment">//c.biancheng.net/java/&gt;</span></span><br><span class="line">umap.<span class="built_in">find</span>(<span class="string">&quot;Java教程&quot;</span>) = &lt;Java教程, http:<span class="comment">//c.biancheng.net/java/&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。</p>
<blockquote>
<p>所谓迭代器失效，针对的是那些用于表示容器内某个范围的迭代器，由于重哈希会重新调整每个键值对的存储位置，所以容器重哈希之后，之前表示特定范围的迭代器很可能无法再正确表示该范围。但是，重哈希并不会影响那些指向单个键值对元素的迭代器。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加 50 个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        umap.<span class="built_in">emplace</span>(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取键为 49 的键值对所在的范围</span></span><br><span class="line">    <span class="keyword">auto</span> pair = umap.<span class="built_in">equal_range</span>(<span class="number">49</span>);</span><br><span class="line">    <span class="comment">//输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//手动调整最大负载因子数</span></span><br><span class="line">    umap.<span class="built_in">max_load_factor</span>(<span class="number">3.0</span>);</span><br><span class="line">    <span class="comment">//手动调用 rehash() 函数重哈希</span></span><br><span class="line">    umap.<span class="built_in">rehash</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//重哈希之后，pair 的范围可能会发生变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">49</span></span><br><span class="line"><span class="comment">49 17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>经测试，用于遍历整个容器的 begin()/end() 和 cbegin()/cend() 迭代器对，重哈希只会影响遍历容器内键值对的顺序，整个遍历的操作仍然可以顺利完成。</code></p>
<h2 id="unordered-map获取元素的4种方法"><a href="#unordered-map获取元素的4种方法" class="headerlink" title="unordered_map获取元素的4种方法"></a>unordered_map获取元素的4种方法</h2><ol>
<li>unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//获取 &quot;Java教程&quot; 对应的值</span></span><br><span class="line">    string str = umap[<span class="string">&quot;Java教程&quot;</span>];</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。</p>
<ol start="2">
<li>unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出<code>out_of_range</code>异常。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//获取指定键对应的值</span></span><br><span class="line">    string str = umap.<span class="built_in">at</span>(<span class="string">&quot;Python教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//执行此语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; umap.at(&quot;GO教程&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><input disabled type="checkbox"> 运算符和 at() 成员方法基本能满足大多数场景的需要。除此之外，还可以借助 unordered_map 模板中提供的 find() 成员方法。</li>
</ol>
<p>和前面方法不同的是，通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p>
<p>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</p>
<p>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">&quot;Python教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//查找失败</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter2 = umap.<span class="built_in">find</span>(<span class="string">&quot;GO教程&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter2 == umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前容器中没有以\&quot;GO教程\&quot;为键的键值对&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>除了 find() 成员方法之外，甚至可以借助 begin()&#x2F;end() 或者 cbegin()&#x2F;cend()，通过遍历整个容器中的键值对来找到目标键值对。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//遍历整个容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="comment">//判断当前的键值对是否就是要找的</span></span><br><span class="line">        <span class="keyword">if</span> (!iter-&gt;first.<span class="built_in">compare</span>(<span class="string">&quot;Java教程&quot;</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="unordered-multimap容器"><a href="#unordered-multimap容器" class="headerlink" title="unordered_multimap容器"></a>unordered_multimap容器</h2><p>unordered_multimap 类模板提供的成员方法如表 2 所示。 </p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个键值对的正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有键值对的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找以 key 键的键值对的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新键值对，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新键值对。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有键值对。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储键值对的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回以 key 为键的键值对所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_multimap 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody></table>
<hr>
<h2 id="unordered-set容器"><a href="#unordered-set容器" class="headerlink" title="unordered_set容器"></a>unordered_set容器</h2><p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p>
<p>总的来说，unordered_set 容器具有以下几个特性：</p>
<ol>
<li><p>不再以键值对的形式存储数据，而是直接存储数据的值；</p>
</li>
<li><p>容器内部存储的各个元素的值都互不相等，且不能被修改。</p>
</li>
<li><p>不会对内部存储的数据进行排序</p>
<h4 id="C-unordered-set容器的成员方法"><a href="#C-unordered-set容器的成员方法" class="headerlink" title="C++ unordered_set容器的成员方法"></a>C++ unordered_set容器的成员方法</h4></li>
</ol>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器。</td>
</tr>
<tr>
<td>end();</td>
<td>返回指向容器中最后一个元素之后位置的正向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>find(key)</td>
<td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在容器中查找值为 key 的元素的个数。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td>
</tr>
<tr>
<td>emplace()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>向容器中添加新元素，效率比 insert() 方法高。</td>
</tr>
<tr>
<td>insert()</td>
<td>向容器中添加新元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除指定元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空容器，即删除容器中存储的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 unordered_set 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td>
</tr>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_set 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储元素的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回值为 key 的元素所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_set 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_set 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳 count 个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的unordered_set容器</span></span><br><span class="line">    std::unordered_set&lt;std::string&gt; uset;</span><br><span class="line">    <span class="comment">//给 uset 容器添加数据</span></span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    <span class="comment">//查看当前 uset 容器存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;uset size = &quot;</span> &lt;&lt; uset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历输出 uset 容器存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = uset.<span class="built_in">begin</span>(); iter != uset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="unordered-multiset容器"><a href="#unordered-multiset容器" class="headerlink" title="unordered_multiset容器"></a>unordered_multiset容器</h2><p>前面章节详细地介绍了 unordered_set 容器的特定和用法，在此基础上，本节再介绍一个类似的 C++ STL 无序容器，即 unordered_multiset 容器。</p>
<p>所谓“类似”，指的是 unordered_multiset 容器大部分的特性都和 unordered_set 容器相同，包括：</p>
<ol>
<li>unordered_multiset 不以键值对的形式存储数据，而是直接存储数据的值；</li>
<li>该类型容器底层采用的也是哈希表存储结构（可阅读《<a target="_blank" rel="noopener" href="https://c.biancheng.net/view/7235.html">C++ STL无序容器底层实现原理</a>》一文做详细了解），它不会对内部存储的数据进行排序；</li>
<li>unordered_multiset 容器内部存储的元素，其值不能被修改。</li>
</ol>
<p>和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。</p>
<blockquote>
<p>读者可以这样认为，unordered_multiset 除了能存储相同值的元素外，它和 unordered_set 容器完全相同。</p>
</blockquote>
<p>值得一提的是，unordered_multiset 模板类中提供的成员方法，无论是种类还是数量，都和 unordered_set 类模板一样</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Fengzi7.magicalroom.com">封子期</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://fengzi7.magicalroom.com/2024/09/26/stl/">https://fengzi7.magicalroom.com/2024/09/26/stl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Fengzi7.magicalroom.com" target="_blank">Fengzi7的奇妙空间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/26/TinyWebServer_day1/" title="Tiny Web Server学习笔记"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tiny Web Server学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/26/socket/" title="socket"><img class="cover" src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">socket</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/boqi.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">封子期</div><div class="author-info__description">这个人很懒，请出门左转</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:1976083684@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%9F%BA%E7%A1%80"><span class="toc-text">STL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">C++ STL是什么，有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E8%A6%81%E5%AD%A6%E5%93%AA%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">C++STL要学哪些知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL序列式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">C++ STL容器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CC-STL%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">迭代器是什么，C++ STL迭代器（iterator）用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">迭代器类别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">迭代器的定义方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88STL%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">C++序列式容器（STL序列式容器）是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="toc-text">容器中常见的函数成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array-STL-array-%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">array(STL array)容器用法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-array%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL array随机访问迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#begin-end-%E5%92%8C-cbegin-cend"><span class="toc-text">begin()&#x2F;end() 和 cbegin()&#x2F;cend()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">array容器访问元素的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">访问array容器中单个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEarray%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">访问array容器中多个元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">1.  初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text">2.  访问元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">3.  插入与删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8"><span class="toc-text">4.  遍历列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8B%BC%E6%8E%A5%E5%88%97%E8%A1%A8"><span class="toc-text">5.  拼接列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-text">6.  排序列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">原理实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88push-back-%E5%92%8Cemplace-back-%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-text">vector添加元素（push_back()和emplace_back()）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#push-back"><span class="toc-text">push_back()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace-back"><span class="toc-text">emplace_back()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace-back-%E5%92%8Cpush-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">emplace_back()和push_back()的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-%E5%92%8Cemplace-%E8%AF%A6%E8%A7%A3"><span class="toc-text">insert()和emplace()详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert"><span class="toc-text">insert()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emplace"><span class="toc-text">emplace()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%89%A9%E5%AE%B9%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E6%8D%9F%E5%A4%B1%EF%BC%88reserve%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-text">vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81vector%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="toc-text">1、vector数据结构性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81push-back%E5%90%8Eiterator%E5%A4%B1%E6%95%88%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">2、push_back后iterator失效程序崩溃的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81reserve%EF%BC%88%EF%BC%89%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-text">3、reserve（）避免多次不必要的扩容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8vector%E7%9A%84swap-%E6%88%90%E5%91%98%E6%94%B6%E7%BC%A9%E5%86%85%E5%AD%98"><span class="toc-text">利用vector的swap()成员收缩内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E4%B8%8D%E6%98%AF%E5%AD%98%E5%82%A8bool%E7%B1%BB%E5%9E%8B%E5%85%83%E7%B4%A0%E7%9A%84vector%E5%AE%B9%E5%99%A8"><span class="toc-text">&#x3D;&#x3D;vector不是存储bool类型元素的vector容器&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAdeque%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">创建deque容器的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">deque容器可利用的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">deque容器迭代器的使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">双向队列常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">双向队列实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%B6"><span class="toc-text">1.  基于双向链表的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%B6"><span class="toc-text">2.  基于数组的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%EF%BC%88STL-list%EF%BC%89%E5%AE%B9%E5%99%A8%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5%EF%BC%88%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-text">list（STL list）容器完全攻略（超级详细）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E5%8F%AF%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">list容器可用的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-text">list迭代器及用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-forward-list%E5%AE%B9%E5%99%A8%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">STL forward_list容器完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">forward_list容器的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">forward_list容器支持的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C%E4%BD%BF%E7%94%A8forward-list%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">和使用forward_list容器相关的函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">STL关联式容器是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-text">C++ STL关联式容器种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-pair%E7%94%A8%E6%B3%95"><span class="toc-text">STL pair用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-map"><span class="toc-text">STL map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-map%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ map容器的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-map%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ map容器包含的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-map%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL map容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E8%8E%B7%E5%8F%96%E9%94%AE%E5%AF%B9%E5%BA%94%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">map获取键对应值的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-insert-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">map insert()插入数据的4种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8operator-%E5%92%8Cinsert-%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-text">map容器operator[]和insert()效率对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91map%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%A2%9E%E6%B7%BB%E5%85%83%E7%B4%A0%EF%BC%8Cinsert-%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-text">向map容器中增添元素，insert()效率更高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0map%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8Coperator-%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98"><span class="toc-text">更新map容器中的键值对，operator[]效率更高</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-emplace-%E5%92%8Cemplace-hint-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">map emplace()和emplace_hint()方法详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multimap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">multimap容器用法完全攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-multimap%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ multimap容器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-multimap%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ multimap容器包含的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-set"><span class="toc-text">STL set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-set%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ set容器的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-STL-set%E5%AE%B9%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ STL set容器包含的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">set容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-insert-%E6%96%B9%E6%B3%95"><span class="toc-text">set insert()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-emplace-%E5%92%8Cemplace-hint"><span class="toc-text">set emplace()和emplace_hint()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%9Aerase-%E5%92%8Cclear"><span class="toc-text">set删除数据：erase()和clear()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiset%E5%AE%B9%E5%99%A8"><span class="toc-text">multiset容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-multiset%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ multiset容器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-multiset%E5%AE%B9%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ multiset容器提供的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E3%80%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%91"><span class="toc-text">STL关联式容器自定义排序规则【函数对象】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">1 - 使用函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F"><span class="toc-text">2 - 重载关系运算符实现自定义排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E4%B8%AD%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E9%94%AE"><span class="toc-text">如何修改关联式容器中键值对的键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">STL无序关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88%E5%93%88%E5%B8%8C%E5%AE%B9%E5%99%A8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">STL无序容器（哈希容器）是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-STL%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-text">C++ STL无序容器种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map%E5%AE%B9%E5%99%A8"><span class="toc-text">unordered_map容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAC-unordered-map%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">创建C++ unordered_map容器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-unordered-map%E5%AE%B9%E5%99%A8%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ unordered_map容器的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">C++无序容器的底层实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-text">哈希冲突与扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%9C%B0%E5%9D%80"><span class="toc-text">链式地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80"><span class="toc-text">开放寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%C2%B6"><span class="toc-text">1.  线性探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%C2%B6"><span class="toc-text">2.  平方探测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%A4%9A%E6%AC%A1%E5%93%88%E5%B8%8C%C2%B6"><span class="toc-text">3.  多次哈希</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">unordered_map迭代器的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">unordered_map获取元素的4种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-multimap%E5%AE%B9%E5%99%A8"><span class="toc-text">unordered_multimap容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-set%E5%AE%B9%E5%99%A8"><span class="toc-text">unordered_set容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-unordered-set%E5%AE%B9%E5%99%A8%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">C++ unordered_set容器的成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-multiset%E5%AE%B9%E5%99%A8"><span class="toc-text">unordered_multiset容器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/WebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="WebBench压力测试"><img src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebBench压力测试"/></a><div class="content"><a class="title" href="/2024/09/26/WebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/" title="WebBench压力测试">WebBench压力测试</a><time datetime="2024-09-26T13:33:55.000Z" title="发表于 2024-09-26 21:33:55">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E9%80%A0%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-创造性模式"><img src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-创造性模式"/></a><div class="content"><a class="title" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E9%80%A0%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式-创造性模式">设计模式-创造性模式</a><time datetime="2024-09-26T13:24:03.629Z" title="发表于 2024-09-26 21:24:03">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" title="虚拟地址与文件描述符"><img src="https://www.4kbizhi.com/d/file/2023/04/23/small085241B2SIA1682211161.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟地址与文件描述符"/></a><div class="content"><a class="title" href="/2024/09/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/" title="虚拟地址与文件描述符">虚拟地址与文件描述符</a><time datetime="2024-09-26T13:24:03.629Z" title="发表于 2024-09-26 21:24:03">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式-结构型模式+行为模式"><img src="https://www.4kbizhi.com/d/file/2023/03/30/small10210526dzK1680142866.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式-结构型模式+行为模式"/></a><div class="content"><a class="title" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式-结构型模式+行为模式">设计模式-结构型模式+行为模式</a><time datetime="2024-09-26T13:24:03.629Z" title="发表于 2024-09-26 21:24:03">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="STL查漏补缺"><img src="https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL查漏补缺"/></a><div class="content"><a class="title" href="/2024/09/26/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="STL查漏补缺">STL查漏补缺</a><time datetime="2024-09-26T13:24:03.627Z" title="发表于 2024-09-26 21:24:03">2024-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://www.4kbizhi.com/d/file/2023/06/14/small171014uQgXb1686733814.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 封子期</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1957725779" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>