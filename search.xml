<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebBench压力测试</title>
      <link href="/2024/09/26/WebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/09/26/WebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创造性模式</title>
      <link href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E9%80%A0%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E9%80%A0%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="类的UML画法"><a href="#类的UML画法" class="headerlink" title="类的UML画法"></a>类的UML画法</h1><p><img src="https://subingwen.cn/design-patterns/UML-class-diagrams/image-20220828154250384.png" alt="image-20220828154250384"></p><p>可见性：+ 表示public、# 表示protected、- 表示private、__(下划线)表示static</p><p>属性的表示方式：【可见性】【属性名称】:【类型】&#x3D; { 缺省值，可选 }</p><p>方法的表示方式：【可见性】【方法名称】(【参数名 : 参数类型，……】）:【返回值类型】</p><p>在使用UML画类图的时候，虚函数的表示方跟随类名，也就是使用斜体，如果是纯虚函数则需要在最后给函数指定&#x3D;0。</p><h1 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h1><p>继承关系、关联关系、聚合关系、组合关系、依赖关系</p><p><strong>继承关系：</strong> 最普通的父类子类</p><p><strong>关联关系：</strong> 平等地位，但是类内有另一类做成员变量。</p><p>​只有一方有另一方做类内成员，就是单向关联关系</p><p>​都有对方做自己的类内成员对象，他们就是双向关联关系</p><p>​自己类存在自己类对象的指针就是自关联关系，链表就是一种典型</p><p><strong>聚合关系：</strong> 植物 土壤 水 动物 阳光在一起才能组成森林。但是植物这些类可以单独出现</p><p><strong>组合关系：</strong> 头是有嘴鼻口眉组成的，但是嘴鼻子这些不可能单独实现，必须在头这个类内</p><p><strong>依赖关系：</strong> 干一件事需要另一个类对象，开枪需要枪这个对象，人对枪就存在依赖关系</p><p>依赖关系通常通过三种方式来实现：</p><p>将一个类的对象作为另一个类中方法的参数</p><p>在一个类的方法中将另一个类的对象作为其对象的局部变量</p><p>在一个类的方法中调用另一个类的静态方法</p><p>类之间的关系强弱顺序是这样的：继承（泛化） &gt;  组合  &gt;  聚合  &gt;  关联  &gt;  依赖。</p><h1 id="关联关系、聚合关系、组合关系之间的区别"><a href="#关联关系、聚合关系、组合关系之间的区别" class="headerlink" title="关联关系、聚合关系、组合关系之间的区别"></a>关联关系、聚合关系、组合关系之间的区别</h1><p>关联和聚合的区别主要在于语义上：关联的两个对象之间一般是平等的，聚合则一般是不平等的。</p><p>聚合和组合的区别则在语义和实现上都有差别：</p><p>组合的两个对象之间生命周期有很大的关联，被组合的对象在组合对象创建的同时或者创建之后创建在组合对象销毁之前销毁，聚合则无需考虑这些事情。<br>一般来说被组合对象不能脱离组合对象独立存在，而且也只能属于一个组合对象，聚合则不一样，被聚合的对象可以属于多个聚合对象。<br>最后，再举例子来描述一下这三种关系：</p><p>朋友之间属于关联关系，因为这种关系是平等的，关联关系只是用于表示两个对象之间的一种简单的联系而已。<br>图书馆看书的时候，人和书属于聚合关系。书是可以独立存在的，而且书不仅可以属于自己，也可以属于别人。<br>人和自己的心脏属于组合关系，因为心脏不能脱离人体而独自存在。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。<strong>类似账本记录了所有订单</strong></p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403272120644.png" alt="单例模式"></p><p>如果使用单例模式，首先要保证这个类的实例有且仅有一个，也就是说这个对象是独生子女，如果我们实施计划生育只生一个孩子，不需要也不能给再他增加兄弟姐妹。因此，就必须采取一系列的防护措施。对于类来说以上描述同样适用。涉及一个类多对象操作的函数有以下几个：</p><p>构造函数：创建一个新的对象<br>拷贝构造函数：根据已有对象拷贝出一个新的对象<br>拷贝赋值操作符重载函数：两个对象之间的赋值</p><p>为了把一个类可以实例化多个对象的路堵死，可以做如下处理：</p><p>构造函数私有化，在类内部只调用一次，这个是可控的。</p><p>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是静态的，这样就可以通过类名来访问了，为了不破坏类的封装，我们都会把这个静态对象的访问权限设置为私有的。<br>在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象。<br>拷贝构造函数私有化或者禁用（使用 &#x3D; delete）</p><p>拷贝赋值操作符重载函数私有化或者禁用（从单例的语义上讲这个函数已经毫无意义，所以在类中不再提供这样一个函数，故将它也一并处理一下。）</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403272122011.png" alt="image-20220901082949746"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个单例模式的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> Singleton* m_obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现一个单例模式的类的时候，有两种处理模式：</p><p>饿汉模式<br>懒汉模式</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象。关于这个饿汉模式的类的定义如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态成员初始化放到类外部处理</span></span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* obj = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在第17行，定义这个单例类的时候，就把这个静态的单例对象创建出来了。当使用者通过getInstance()获取这个单例对象的时候，它已经被准备好了。</p><p><strong>注意事项：类的静态成员变量在使用之前必须在类的外部进行初始化才能使用。</strong></p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>在调用getInstance()函数获取单例对象的时候，如果在单线程情况下是没有什么问题的，如果是多个线程，调用这个函数去访问单例对象就有问题了。假设有三个线程同时执行了getInstance()函数，在这个函数内部每个线程都会new出一个实例对象。此时，这个任务队列类的实例对象不是一个而是3个，很显然这与单例模式的定义是相悖的。</p><p><strong>线程安全问题</strong></p><h4 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h4><p>对于饿汉模式是没有线程安全问题的，在这种模式下访问单例对象的时候，这个对象已经被创建出来了。要解决懒汉模式的线程安全问题，最常用的解决方案就是使用互斥锁。可以将创建单例对象的代码使用互斥锁锁住，处理代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>这个代码块被互斥锁锁住了，也就意味着不论有多少个线程，同时执行这个代码块的线程只能是一个（相当于是严重限行了，在重负载情况下，可能导致响应缓慢）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>改进的思路就是在加锁、解锁的代码块外层有添加了一个if判断（第9行），这样当任务队列的实例被创建出来之后，访问这个对象的线程就不会再执行加锁和解锁操作了（只要有了单例类的实例对象，限行就解除了），对于第一次创建单例对象的时候线程之间还是具有竞争关系，被互斥锁阻塞。上面这种<strong>通过两个嵌套的 if 来判断单例对象是否为空的操作就叫做双重检查锁定。</strong></p><h4 id="双重检查锁定的问题"><a href="#双重检查锁定的问题" class="headerlink" title="双重检查锁定的问题"></a>双重检查锁定的问题</h4><p>假设有两个线程A、B，当线程A 执行到第 8 行时在线程A中 TaskQueue 实例对象 被创建，并赋值给 m_taskQ。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_taskQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上 m_taskQ &#x3D; new TaskQueue; 在执行过程中对应的机器指令可能会被重新排序。正常过程如下：</p><p>第一步：分配内存用于保存 TaskQueue 对象。</p><p>第二步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p><p>第三步：使用 m_taskQ 指针指向分配的内存。</p><p>但是被重新排序以后执行顺序可能会变成这样：</p><p>第一步：分配内存用于保存 TaskQueue 对象。</p><p>第二步：使用 m_taskQ 指针指向分配的内存。</p><p>第三步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p><p>这样重排序并不影响单线程的执行结果，但是在多线程中就会出问题。如果线程A按照第二种顺序执行机器指令，执行完前两步之后失去CPU时间片被挂起了，<strong>此时线程B在第3行处进行指针判断的时候m_taskQ 指针是不为空的，但这个指针指向的内存却没有被初始化，最后线程 B 使用了一个没有被初始化的队列对象就出问题了（出现这种情况是概率问题，需要反复的大量测试问题才可能会出现）。</strong></p><p>在C++11中引入了原子变量atomic，通过原子变量可以实现一种更安全的懒汉模式的单例，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TaskQueue* queue = m_taskQ.<span class="built_in">load</span>();  </span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// m_mutex.lock();  // 加锁: 方式1</span></span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;  <span class="comment">// 加锁: 方式2</span></span><br><span class="line">            queue = m_taskQ.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span> (queue == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">                m_taskQ.<span class="built_in">store</span>(queue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// m_mutex.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> atomic&lt;TaskQueue*&gt; m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line">atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* queue = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    queue-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原子变量atomic的store() 方法来存储单例对象，使用load() 方法来加载单例对象。在原子变量中这两个函数在处理指令的时候默认的原子顺序是memory_order_seq_cst（顺序原子操作 - sequentially consistent），使用顺序约束原子操作库，整个函数执行都将保证顺序执行，并且不会出现数据竞态（data races），不足之处就是使用这种方法实现的懒汉模式的单例执行效率更低一些。</p><h4 id="静态局部对象"><a href="#静态局部对象" class="headerlink" title="静态局部对象"></a>静态局部对象</h4><p>在实现懒汉模式的单例的时候，相较于双重检查锁定模式有一种更简单的实现方法并且不会出现线程安全问题，那就是使用静态局部局部对象，对应的代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> TaskQueue taskQ;</span><br><span class="line">        <span class="keyword">return</span> &amp;taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* queue = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    queue-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>义了一个静态局部队列对象，并且将这个对象作为了唯一的单例实例。使用这种方式之所以是线程安全的，是因为在C++11标准中有如下规定，并且这个操作是在编译时由编译器保证的：</p><p><strong>&#x3D;&#x3D;如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。&#x3D;&#x3D;</strong></p><p>懒汉模式的缺点是在创建实例对象的时候有安全问题，但这样可以减少内存的浪费（如果用不到就不去申请内存了）。饿汉模式则相反，在我们不需要这个实例对象的时候，它已经被创建出来，占用了一块内存。对于现在的计算机而言，内存容量都是足够大的，这个缺陷可以被无视。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="type">bool</span> flag = m_taskQ.<span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_taskQ.<span class="built_in">push</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出一个任务</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_taskQ.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_taskQ.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除一个任务</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">popTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_taskQ.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_taskQ.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue m_obj;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; m_taskQ;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue TaskQueue::m_obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        TaskQueue* taskQ = TaskQueue::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            taskQ-&gt;addTask(i + <span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;+++push task: &quot;</span> &lt;&lt; i + <span class="number">100</span> &lt;&lt; <span class="string">&quot;, threadID: &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            this_thread::sleep_for(chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        TaskQueue* taskQ = TaskQueue::getInstance();</span></span></span><br><span class="line"><span class="params"><span class="function">        this_thread::sleep_for(chrono::milliseconds(<span class="number">100</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!taskQ-&gt;isEmpty())</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> data = taskQ-&gt;takeTask();</span></span></span><br><span class="line"><span class="params"><span class="function">            cout &lt;&lt; <span class="string">&quot;---take task: &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;, threadID: &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            taskQ-&gt;popTask();</span></span></span><br><span class="line"><span class="params"><span class="function">            this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式（Simple Factory Pattern）是一种创建型设计模式，它提供了一个单独的工厂类来负责创建多种类型的对象，而客户端只需要知道要创建的对象的类型即可。</p><p>在简单工厂模式中，通常包含以下几个角色：</p><ol><li><strong>工厂类（Factory）</strong>：负责创建具体产品的类。它包含一个静态方法或非静态方法，根据客户端传入的参数来决定创建哪种具体产品对象。</li><li><strong>抽象产品类（Abstract Product）</strong>：定义了产品的接口或抽象类，描述了具体产品所具有的共同特征。</li><li><strong>具体产品类（Concrete Product）</strong>：实现了抽象产品类定义的接口或抽象类，是工厂类所创建的对象。</li></ol><p>简单工厂模式的工作原理如下：</p><ul><li>客户端通过工厂类来创建产品对象，而不直接实例化具体产品对象。</li><li>工厂类根据客户端传入的参数，选择并创建相应的具体产品对象。</li><li>客户端只需要知道要创建的产品类型，而不需要了解具体产品的创建细节。</li></ul><p>简单工厂模式的优点是简单易懂，客户端不需要知道具体产品的创建细节，只需关心产品类型即可。但缺点是如果要新增或修改产品，<strong>需要修改工厂类的代码，违反了开闭原则。</strong></p><p>总的来说，简单工厂模式适用于产品种类较少且变化不频繁的情况，能够帮助客户端通过统一的接口创建不同类型的对象。</p><p>好的，让我们通过一个简单的示例来说明简单工厂模式。</p><p>假设我们有一个形状（Shape）类及其子类：圆形（Circle）、矩形（Rectangle）和正方形（Square）。我们希望通过一个工厂类来创建这些形状对象。</p><p>首先，我们定义一个抽象形状类 Shape：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象形状类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们定义具体的形状类：圆形、矩形和正方形。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体圆形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体正方形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Draw a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们创建一个简单工厂类 ShapeFactory，用于根据客户端传入的参数创建不同类型的形状对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Shape* <span class="title">createShape</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;Circle&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;Rectangle&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;Square&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，通过简单工厂模式，我们可以在客户端代码中通过工厂类来创建不同类型的形状对象，而无需直接实例化具体的形状类。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h2><p>在上一节简单工厂模式中，创建了一个工厂类，用于生产需要的对象，但是这种方式有一个弊端，它违反了设计模式中的开放-封闭原则.</p><p>现在如果想要生成更多，那么就需要在工厂函数的switch语句中添加更多的case，很明显这违背了封闭原则，也就意味着需要基于开放原则来解决这个问题。</p><p>使用工厂模式可以很完美的解决上述的问题，简单工厂模式是只有一个工厂类，而工厂模式是有很多的工厂类：</p><p><strong>一个基类，包含一个虚工厂函数，用于实现多态。</strong><br><strong>多个子类，重写父类的工厂函数。每个子工厂类负责生产一种恶魔果实，这相当于再次解耦，将工厂类的职责再次拆分、细化，如果要生产新品种的恶魔果实，那么只需要添加对应的工厂类，无需修改原有的代码。</strong></p><p>修改一下上述工厂类代码，设置为纯虚函数.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Shape* <span class="title">createShape</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们定义具体的工厂类：圆形工厂、矩形工厂和三角形工厂，分别用于创建对应的图形对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TriangleFactory</span> : <span class="keyword">public</span> ShapeFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Shape* <span class="title">createShape</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Triangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们可以在客户端代码中使用工厂方法模式来创建图形对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建圆形</span></span><br><span class="line">    ShapeFactory* circleFactory = <span class="keyword">new</span> <span class="built_in">CircleFactory</span>();</span><br><span class="line">    Shape* circle = circleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    circle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    <span class="keyword">delete</span> circle;</span><br><span class="line">    <span class="keyword">delete</span> circleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建矩形</span></span><br><span class="line">    ShapeFactory* rectangleFactory = <span class="keyword">new</span> <span class="built_in">RectangleFactory</span>();</span><br><span class="line">    Shape* rectangle = rectangleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    rectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    <span class="keyword">delete</span> rectangle;</span><br><span class="line">    <span class="keyword">delete</span> rectangleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建三角形</span></span><br><span class="line">    ShapeFactory* triangleFactory = <span class="keyword">new</span> <span class="built_in">TriangleFactory</span>();</span><br><span class="line">    Shape* triangle = triangleFactory-&gt;<span class="built_in">createShape</span>();</span><br><span class="line">    triangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    <span class="keyword">delete</span> triangle;</span><br><span class="line">    <span class="keyword">delete</span> triangleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，通过工厂方法模式，我们可以灵活地创建不同类型的图形对象，而不需要直接依赖具体的图形类。这样的设计符合开闭原则，可以方便地扩展新的图形类型，而不会影响已有的代码。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或依赖对象的家族，而不需要指定具体的类。抽象工厂模式通过引入抽象工厂和具体工厂来实现对象的创建，从而使得客户端代码与具体创建逻辑解耦。</p><p>抽象工厂模式通常包含以下几个角色：</p><ol><li><strong>抽象工厂类（Abstract Factory）</strong>：定义了一个用于创建一系列产品的接口，包含多个创建产品的抽象方法。</li><li><strong>具体工厂类（Concrete Factory）</strong>：实现了抽象工厂接口的具体类，负责创建一系列相关的产品。</li><li><strong>抽象产品类（Abstract Product）</strong>：定义了产品的接口或抽象类，描述了具体产品所具有的共同特征。</li><li><strong>具体产品类（Concrete Product）</strong>：实现了抽象产品类定义的接口或抽象类，是具体工厂所创建的对象。</li></ol><p>抽象工厂模式的关键是在抽象工厂类中定义多个抽象方法来创建一系列相关的产品，然后具体工厂类实现这些抽象方法来创建具体的产品对象。这样客户端代码在使用工厂时，只需通过抽象工厂接口来创建产品对象，而无需关心具体产品的实现细节。</p><p>接下来，让我们通过一个简单的例子来说明抽象工厂模式的应用。</p><p>假设我们有一个汽车制造厂，它可以生产不同种类的汽车零件，包括发动机和轮胎。我们希望使用抽象工厂模式来创建不同种类的汽车零件。</p><p>首先，我们定义两个抽象产品类：发动机和轮胎。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象发动机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Engine</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象轮胎类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tire</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">roll</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Tire</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们定义两个具体产品类：高性能发动机和耐磨轮胎</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体高性能发动机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HighPerformanceEngine</span> : <span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;High performance engine starts.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体耐磨轮胎类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DurableTire</span> : <span class="keyword">public</span> Tire &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">roll</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Durable tire rolls.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们定义抽象工厂类 <code>CarPartsFactory</code>，它包含两个抽象方法用于创建发动机和轮胎。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象汽车零件工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarPartsFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Engine* <span class="title">createEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Tire* <span class="title">createTire</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CarPartsFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们定义两个具体工厂类：高性能汽车零件工厂和经济型汽车零件工厂，分别用于生产高性能和经济型汽车零件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体高性能汽车零件工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HighPerformanceCarPartsFactory</span> : <span class="keyword">public</span> CarPartsFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Engine* <span class="title">createEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HighPerformanceEngine</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tire* <span class="title">createTire</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DurableTire</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体经济型汽车零件工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EconomyCarPartsFactory</span> : <span class="keyword">public</span> CarPartsFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Engine* <span class="title">createEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Engine</span>(); <span class="comment">// 假设经济型车使用普通发动机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tire* <span class="title">createTire</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tire</span>(); <span class="comment">// 假设经济型车使用普通轮胎</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们可以在客户端代码中使用抽象工厂模式来创建不同类型的汽车零件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生产高性能汽车零件</span></span><br><span class="line">    CarPartsFactory* highPerformanceFactory = <span class="keyword">new</span> <span class="built_in">HighPerformanceCarPartsFactory</span>();</span><br><span class="line">    Engine* highPerformanceEngine = highPerformanceFactory-&gt;<span class="built_in">createEngine</span>();</span><br><span class="line">    Tire* highPerformanceTire = highPerformanceFactory-&gt;<span class="built_in">createTire</span>();</span><br><span class="line">    highPerformanceEngine-&gt;<span class="built_in">start</span>();</span><br><span class="line">    highPerformanceTire-&gt;<span class="built_in">roll</span>();</span><br><span class="line">    <span class="keyword">delete</span> highPerformanceEngine;</span><br><span class="line">    <span class="keyword">delete</span> highPerformanceTire;</span><br><span class="line">    <span class="keyword">delete</span> highPerformanceFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产经济型汽车零件</span></span><br><span class="line">    CarPartsFactory* economyFactory = <span class="keyword">new</span> <span class="built_in">EconomyCarPartsFactory</span>();</span><br><span class="line">    Engine* economyEngine = economyFactory-&gt;<span class="built_in">createEngine</span>();</span><br><span class="line">    Tire* economyTire = economyFactory-&gt;<span class="built_in">createTire</span>();</span><br><span class="line">    economyEngine-&gt;<span class="built_in">start</span>();</span><br><span class="line">    economyTire-&gt;<span class="built_in">roll</span>();</span><br><span class="line">    <span class="keyword">delete</span> economyEngine;</span><br><span class="line">    <span class="keyword">delete</span> economyTire;</span><br><span class="line">    <span class="keyword">delete</span> economyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过抽象工厂模式，我们可以灵活地创建不同类型的汽车零件，而不需要直接依赖具体的零件类。这样的设计使得系统更加可扩展和灵活。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式（Builder Pattern）是一种创建型设计模式，旨在将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。该模式主要包含以下几个角色：</p><ol><li><strong>产品（Product）</strong>：要创建的复杂对象，通常由多个部件组成。</li><li><strong>抽象建造者（Builder）</strong>：定义了创建产品各个部件的抽象接口，以及组装这些部件的方法。</li><li><strong>具体建造者（Concrete Builder）</strong>：实现了抽象建造者接口，负责具体部件的创建和组装，通常每个具体建造者对应一种产品构建过程。</li><li><strong>指挥者（Director）</strong>：负责使用建造者接口构建产品的对象，它不直接创建产品，而是通过调用建造者的方法来构建产品。</li></ol><p>下面通过一个简单的例子来说明建造者模式的应用。</p><p>假设我们有一个电脑类 <code>Computer</code>，它包含 CPU、内存、硬盘等部件。我们希望使用建造者模式来构建不同配置的电脑对象。</p><p>首先，我们定义电脑类及其部件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getModel</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Intel Core i7&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;16GB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getCapacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;512GB SSD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCPU</span><span class="params">(<span class="type">const</span> CPU&amp; cpu)</span> </span>&#123;</span><br><span class="line">        m_cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMemory</span><span class="params">(<span class="type">const</span> Memory&amp; memory)</span> </span>&#123;</span><br><span class="line">        m_memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHardDisk</span><span class="params">(<span class="type">const</span> HardDisk&amp; hardDisk)</span> </span>&#123;</span><br><span class="line">        m_hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showSpecs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CPU: &quot;</span> &lt;&lt; m_cpu.<span class="built_in">getModel</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory: &quot;</span> &lt;&lt; m_memory.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hard Disk: &quot;</span> &lt;&lt; m_hardDisk.<span class="built_in">getCapacity</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CPU m_cpu;</span><br><span class="line">    Memory m_memory;</span><br><span class="line">    HardDisk m_hardDisk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们定义抽象建造者类 <code>ComputerBuilder</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Computer <span class="title">getResult</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ComputerBuilder</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们定义具体建造者类，例如高性能电脑建造者和普通电脑建造者。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HighPerformanceComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setCPU</span>(<span class="built_in">CPU</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setMemory</span>(<span class="built_in">Memory</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setHardDisk</span>(<span class="built_in">HardDisk</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Computer <span class="title">getResult</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Computer m_computer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardComputerBuilder</span> : <span class="keyword">public</span> ComputerBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildCPU</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setCPU</span>(<span class="built_in">CPU</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMemory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setMemory</span>(<span class="built_in">Memory</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHardDisk</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_computer.<span class="built_in">setHardDisk</span>(<span class="built_in">HardDisk</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Computer <span class="title">getResult</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Computer m_computer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们定义指挥者类 <code>ComputerDirector</code>，负责构建具体的电脑对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerDirector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Computer <span class="title">buildComputer</span><span class="params">(ComputerBuilder&amp; builder)</span> </span>&#123;</span><br><span class="line">        builder.<span class="built_in">buildCPU</span>();</span><br><span class="line">        builder.<span class="built_in">buildMemory</span>();</span><br><span class="line">        builder.<span class="built_in">buildHardDisk</span>();</span><br><span class="line">        <span class="keyword">return</span> builder.<span class="built_in">getResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用建造者模式来构建不同配置的电脑对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComputerDirector director;</span><br><span class="line">    HighPerformanceComputerBuilder highPerformanceBuilder;</span><br><span class="line">    StandardComputerBuilder standardBuilder;</span><br><span class="line"></span><br><span class="line">    Computer highPerformanceComputer = director.<span class="built_in">buildComputer</span>(highPerformanceBuilder);</span><br><span class="line">    Computer standardComputer = director.<span class="built_in">buildComputer</span>(standardBuilder);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;High Performance Computer Specs:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    highPerformanceComputer.<span class="built_in">showSpecs</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nStandard Computer Specs:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    standardComputer.<span class="built_in">showSpecs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而无需知道其具体类型。这种模式涉及实现一个原型接口，该接口用于创建当前对象的副本。通常情况下，原型模式适用于创建成本较高或复杂的对象，因为复制已有对象比创建新对象更有效率。</p><p>原型模式主要包含以下几个角色：</p><ol><li><strong>原型接口（Prototype）</strong>：声明了用于克隆自身的方法。</li><li><strong>具体原型类（Concrete Prototype）</strong>：实现了原型接口，提供了克隆自身的方法。</li><li><strong>客户端（Client）</strong>：使用原型对象的客户端代码，在需要创建新对象时，通过克隆现有的原型对象来得到新对象。</li></ol><p>下面通过一个简单的例子来说明原型模式的应用。</p><p>假设我们有一个图形类 <code>Shape</code>，它包含一些基本属性和方法。我们希望能够通过克隆现有的图形对象来创建新的图形对象。</p><p>首先，我们定义原型接口 <code>ShapePrototype</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapePrototype</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ShapePrototype* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapePrototype</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们定义具体原型类，例如矩形和圆形。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> ShapePrototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ShapePrototype* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Rectangle</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> ShapePrototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ShapePrototype* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Circle</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用原型模式来创建新的图形对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rectangle rectangle;</span><br><span class="line">    Circle circle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clone existing shapes to create new ones</span></span><br><span class="line">    ShapePrototype* clonedRectangle = rectangle.<span class="built_in">clone</span>();</span><br><span class="line">    ShapePrototype* clonedCircle = circle.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cloned objects</span></span><br><span class="line">    clonedRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    clonedCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t forget to clean up the memory</span></span><br><span class="line">    <span class="keyword">delete</span> clonedRectangle;</span><br><span class="line">    <span class="keyword">delete</span> clonedCircle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过原型模式，我们可以在运行时动态创建新的对象，而无需提前知道对象的具体类型，使得客户端代码更加灵活和可维护。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟地址与文件描述符</title>
      <link href="/2024/09/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
      <url>/2024/09/26/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="1-虚拟地址空间"><a href="#1-虚拟地址空间" class="headerlink" title="1. 虚拟地址空间"></a>1. 虚拟地址空间</h1><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><p>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）<br>它对应着一段连续的内存地址，起始位置为 0。<br>之所以说虚拟是因为这个起始的0地址是被虚拟出来的， 不是物理内存的 0地址。</p><p>虚拟地址空间的<strong>大小也由操作系统决定</strong>，32位的操作系统虚拟地址空间的大小为 2^32 字节，也就是4G，64位的操作系统虚拟地址空间大小为2^64 字节，这是一个非常大的数。<strong>当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</strong></p><p>进程在运行过程中，程序内部所有的指令都是通过CPU处理完成的，CPU只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过CPU中的内存管理单元MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403261732435.png" alt="img"></p><h2 id="1-1-存在的意义"><a href="#1-1-存在的意义" class="headerlink" title="1.1 存在的意义"></a>1.1 存在的意义</h2><p>为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过CPU的MMU映射到物理内存中呢？</p><p>如果直接将数据加载到物理内存会发生什么事情</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403261733507.png" alt="img"></p><p>假设计算机的物理内存大小为1G, 进程A需要100M内存因此直接在物理内存上从0地址开始分配100M, 进程B启动需要250M内存, 因此继续在物理内存上为其分配250M内存, 并且进程A和进程B占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。。。</p><p>使用这种方式分配内存会有如下几个问题：</p><p><strong>每个进程的地址不隔离，有安全风险。</strong></p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p><strong>内存效率低。</strong></p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p><strong>进程中数据的地址不确定，每次都会发生变化。</strong></p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了</span><br><span class="line"></span><br><span class="line">虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。</span><br><span class="line"></span><br><span class="line">这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</span><br></pre></td></tr></table></figure><h2 id="1-2-分区"><a href="#1-2-分区" class="headerlink" title="1.2 分区"></a>1.2 分区</h2><p>从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区。</p><p>&#x3D;&#x3D;内核区：&#x3D;&#x3D;<br>内核空间为内核保留，<strong>不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</strong><br>内核总是驻留在内存中，是操作系统的一部分。<br><strong>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</strong><br>用户区：存储用户程序运行中用到的各种数据。<br>我们先来看一下进程对应的虚拟地址空间的各个分区，再来详细介绍用户区的组成（以32位系统的虚拟地址空间为例）。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403261755722.png" alt="img"></p><p>每个进程的虚拟地址空间都是从0地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><p>**保留区: **位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p><p>**.text段: **代码段也称正文段或文本段，通常用于存放程序的执行代码(即CPU执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p><p>**.data段: **数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态变量。数据段属于静态内存分配(静态存储区)，可读可写。</p><p>**.bss段: **未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0</p><p><strong>堆(heap)：</strong>用于存放进程运行时动态分配的内存。<br>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。<br>堆向高地址扩展(即“向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p><p><strong>内存映射区(mmap)：作</strong>为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</p><p>**栈(stack): **存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址“向下生长”，分配的内存是连续的。</p><p><strong>命令行参数：</strong>存储进程执行的时候传递给main()函数的参数，argc，argv[]</p><p>**环境变量: **存储和进程相关的环境变量, 比如: 工作路径, 进程所有者等信息</p><h1 id="2-文件描述符"><a href="#2-文件描述符" class="headerlink" title="2. 文件描述符"></a>2. 文件描述符</h1><h2 id="2-1-文件描述符"><a href="#2-1-文件描述符" class="headerlink" title="2.1 文件描述符"></a>2.1 文件描述符</h2><p>在Linux操作系统中的一切都被抽象成了文件，那么一个打开的文件是如何与应用程序进行对应呢？解决方案是使用<strong>文件描述符（file descriptor，简称fd），当在进程中打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符，用于对应这个打开&#x2F;新建的文件。</strong>这些文件描述符都存储在内核为每个进程维护的一个文件描述符表中。</p><p>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><p>在Linux系统中一切皆文件，系统中一切都被抽象成了文件。对这些文件的读写都需要通过文件描述符来完成。标准C库的文件IO函数使用的文件指针FILE*在Linux中也需要通过文件描述符的辅助才能完成读写操作。FILE其实是一个结构体，其内部有一个成员就是文件描述符（下面结构体的第25行）。</p><p><strong>FILE结构体在Linux头文件中的定义</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linux c FILE结构体定义： /usr/include/libio.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> &#123;</span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_marker</span> *_markers;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> *_chain;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> _fileno;<span class="comment">// 文件描述符</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"> </span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件: /usr/include/stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> FILE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-文件描述符表"><a href="#2-2-文件描述符表" class="headerlink" title="2.2 文件描述符表"></a>2.2 文件描述符表</h2><p>前面讲到启动一个进程就会得到一个对应的虚拟地址空间，这个虚拟地址空间分为两大部分，在内核区有专门用于进程管理的模块。Linux的进程控制块PCB（process control block）本质是一个叫做<strong>task_struct</strong>的结构体，里边包括管理进程所需的各种信息，其中有一个结构体叫做<strong>file</strong> ，我们将它叫做文件描述符表，里边有一个整形索引表,用于存储文件描述符。</p><p>内核为每一个进程维护了一个文件描述符表，索引表中的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，但是它们指向的不一定是同一个磁盘文件。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403261806729.png" alt="img"></p><p><strong>Linux中用户操作的每个终端都被视作一个设备文件, 当前操作的终端文件可以使用 &#x2F;dev&#x2F;tty表示。</strong></p><p><strong>打开的最大文件数</strong></p><p>每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的, 默认为1024个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。</p><p><strong>默认分配的文件描述符</strong></p><p>当一个进程被启动之后，内核PCB的文件描述符表中就已经分配了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux中一切皆文件，终端就是一个设备文件，在 &#x2F;dev 目录中）</p><p>STDIN_FILENO：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为0。<br>STDOUT_FILENO：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为1。<br>STDERR_FILENO：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为2。<br>这三个默认分配的文件描述符是可以通过close()函数关闭掉，但是<strong>关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。</strong></p><p><strong>给新打开的文件分配文件描述符</strong></p><p>因为进程启动之后，文件描述符表中的0,1,2就被分配出去了，因此从3开始分配<br>在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符，比如：<br>通过open()函数打开 &#x2F;hello.txt，文件描述符 3 被分配给了这个文件，保持这个打开状态，再次通过open()函数打开 &#x2F;hello.txt，文件描述符 4 被分配给了这个文件，也就是说一个进程中<strong>不同的文件描述符打开的磁盘文件可能是同一个。</strong><br>通过open()函数打开 &#x2F;hello.txt，文件描述符 3 被分配给了这个文件，将打开的文件关闭，此时文件描述符3就被释放了。再次通过open()函数打开 &#x2F;hello.txt，文件描述符 3 被分配给了这个文件，也就是说<strong>打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>每个进程对应的文件描述符表默认支持打开的最大文件数为 1024，可以修改<br>每个进程的文件描述符表中都已经默认分配了三个文件描述符，对应的都是当前终端文件（&#x2F;dev&#x2F;tty）<br>每打开新的文件，内核会从进程的文件描述符表中找到一个空闲的没有别占用的文件描述符与其进行关联<br>文件描述符表中不同的文件描述符可以对应同一个磁盘文件<br>每个进程文件描述符表中的文件描述符值是唯一的，不会重复</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型模式+行为模式</title>
      <link href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它允许接口不兼容的类之间进行合作。适配器模式通过创建一个包装类来将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而无法在一起工作的类可以一起工作。</p><p>适配器模式通常包括以下几个角色：</p><ol><li><strong>目标接口（Target）</strong>：客户端期望的接口，适配器模式通过实现这个接口来使得适配器类能够与客户端交互。</li><li><strong>适配器类（Adapter）</strong>：包装了被适配者对象，并实现了目标接口。适配器类将客户端的请求委派给被适配者对象。</li><li><strong>被适配者类（Adaptee）</strong>：需要被适配的类，它拥有不兼容的接口。</li></ol><p>下面通过一个简单的例子来说明适配器模式的应用。</p><p>假设我们有一个新型的手机充电器，它使用 USB-C 接口进行充电，但是我们的家里还有一些旧型号的手机充电器，它们使用 Micro USB 接口。我们希望能够使用旧型号的充电器来给新型手机充电，这时就可以使用适配器模式。</p><p>首先，我们定义目标接口 <code>Charger</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Charger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">charge</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Charger</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建适配器类 <code>USBCToMicroUSBAdapter</code>，它将新型手机充电器接口转换成旧型号充电器接口。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USBCToMicroUSBAdapter</span> : <span class="keyword">public</span> Charger &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_usbCCharger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">USBCToMicroUSBAdapter</span>(<span class="type">const</span> std::string&amp; usbCCharger) : <span class="built_in">m_usbCCharger</span>(usbCCharger) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">charge</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using Micro USB charger to charge phone with USB-C port&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Charger information: &quot;</span> &lt;&lt; m_usbCCharger &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们可以在客户端代码中使用适配器来给新型手机使用旧型号的充电器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用旧型号充电器</span></span><br><span class="line">    Charger* oldCharger = <span class="keyword">new</span> <span class="built_in">USBCToMicroUSBAdapter</span>(<span class="string">&quot;Old Micro USB Charger&quot;</span>);</span><br><span class="line">    oldCharger-&gt;<span class="built_in">charge</span>();</span><br><span class="line">    <span class="keyword">delete</span> oldCharger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它通过将抽象部分与实现部分分离，使它们可以独立地变化。桥接模式的核心思想是将一个大类或一组类分成两个独立的层次结构，从而可以在两个层次之间建立一个桥接，使它们可以独立地变化。</p><p>桥接模式主要包括以下几个角色：</p><ol><li><strong>抽象类（Abstraction）</strong>：定义了抽象部分的接口，并维护一个指向实现部分对象的引用。</li><li><strong>扩展抽象类（Refined Abstraction）</strong>：扩展了抽象类，通常是为了增加更多的功能。</li><li><strong>实现接口（Implementor）</strong>：定义了实现部分的接口，该接口不一定和抽象部分完全一致。</li><li><strong>具体实现类（Concrete Implementor）</strong>：实现了实现部分的接口，提供具体的功能。</li></ol><p>下面通过一个简单的例子来说明桥接模式的应用。</p><p>假设我们有一个形状（Shape）类和一个颜色（Color）类，我们希望能够以不同的颜色绘制不同形状的图形。这时就可以使用桥接模式。</p><p>首先，我们定义抽象类 <code>Shape</code> 和实现接口 <code>Color</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getColor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Color</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Color* m_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(Color* color) : <span class="built_in">m_color</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建具体的实现类 <code>RedColor</code> 和 <code>BlueColor</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlueColor</span> : <span class="keyword">public</span> Color &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">getColor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，我们创建具体的形状类 <code>Circle</code> 和 <code>Rectangle</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(Color* color) : <span class="built_in">Shape</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle with color &quot;</span> &lt;&lt; m_color-&gt;<span class="built_in">getColor</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(Color* color) : <span class="built_in">Shape</span>(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle with color &quot;</span> &lt;&lt; m_color-&gt;<span class="built_in">getColor</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用桥接模式来绘制不同颜色的不同形状的图形。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color* red = <span class="keyword">new</span> <span class="built_in">RedColor</span>();</span><br><span class="line">    Color* blue = <span class="keyword">new</span> <span class="built_in">BlueColor</span>();</span><br><span class="line"></span><br><span class="line">    Shape* redCircle = <span class="keyword">new</span> <span class="built_in">Circle</span>(red);</span><br><span class="line">    Shape* blueRectangle = <span class="keyword">new</span> <span class="built_in">Rectangle</span>(blue);</span><br><span class="line"></span><br><span class="line">    redCircle-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    blueRectangle-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> redCircle;</span><br><span class="line">    <span class="keyword">delete</span> blueRectangle;</span><br><span class="line">    <span class="keyword">delete</span> red;</span><br><span class="line">    <span class="keyword">delete</span> blue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过桥接模式，我们将形状和颜色的实现部分解耦，使得它们可以独立地变化和扩展，从而提高了代码的灵活性和可维护性。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式通过使得单个对象和组合对象具有一致的接口，使得客户端可以统一地对待单个对象和组合对象，从而简化了客户端代码。</p><p>组合模式主要包括以下几个角色：</p><ol><li><strong>组件（Component）</strong>：定义了组合中对象的共有接口，可以是抽象类或接口。组件类通常包含管理子组件的方法，例如添加子组件、删除子组件、获取子组件等。</li><li><strong>叶子（Leaf）</strong>：表示组合中的叶子节点对象，叶子节点没有子节点。通常是组合的基本对象，它实现了组件接口。</li><li><strong>容器（Composite）</strong>：表示组合中的容器节点对象，容器节点包含子节点。容器节点可以有一个或多个子节点，它实现了组件接口，并提供了管理子节点的方法。</li></ol><p>下面通过一个简单的例子来说明组合模式的应用。</p><p>假设我们要设计一个Linux文件系统，文件系统中包含文件（File）和文件夹（Folder）。文件夹可以包含文件或其他文件夹，从而形成树形结构。我们希望能够通过组合模式来实现文件系统的设计。</p><p>首先，我们定义组件接口 <code>FileSystemComponent</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FileSystemComponent</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们创建叶子类 <code>File</code> 和容器类 <code>Folder</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File: &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> : <span class="keyword">public</span> FileSystemComponent &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::vector&lt;FileSystemComponent*&gt; m_children;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Folder</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addComponent</span><span class="params">(FileSystemComponent* component)</span> </span>&#123;</span><br><span class="line">        m_children.<span class="built_in">push_back</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Folder: &quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : m_children) &#123;</span><br><span class="line">            child-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用组合模式来构建文件系统。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File* file1 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">&quot;File1.txt&quot;</span>);</span><br><span class="line">    File* file2 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">&quot;File2.txt&quot;</span>);</span><br><span class="line">    Folder* folder1 = <span class="keyword">new</span> <span class="built_in">Folder</span>(<span class="string">&quot;Folder1&quot;</span>);</span><br><span class="line">    folder1-&gt;<span class="built_in">addComponent</span>(file1);</span><br><span class="line">    folder1-&gt;<span class="built_in">addComponent</span>(file2);</span><br><span class="line"></span><br><span class="line">    File* file3 = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">&quot;File3.txt&quot;</span>);</span><br><span class="line">    Folder* folder2 = <span class="keyword">new</span> <span class="built_in">Folder</span>(<span class="string">&quot;Folder2&quot;</span>);</span><br><span class="line">    folder2-&gt;<span class="built_in">addComponent</span>(file3);</span><br><span class="line">    folder2-&gt;<span class="built_in">addComponent</span>(folder1);</span><br><span class="line"></span><br><span class="line">    folder2-&gt;<span class="built_in">showInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> folder2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式（Decorator Pattern）是一种结构型设计模式，它允许在不改变对象自身的基础上动态地添加功能。装饰模式通过将对象包装在装饰器对象中，从而实现对对象的功能扩展，同时保持接口的一致性和组合性。</p><p>装饰模式主要包括以下几个角色：</p><ol><li><strong>组件（Component）</strong>：定义了被装饰的对象的接口，可以是抽象类或接口。</li><li><strong>具体组件（Concrete Component）</strong>：实现了组件接口，是被装饰的对象。</li><li><strong>装饰器（Decorator）</strong>：继承自组件类，并持有一个指向组件对象的引用，它定义了一个与组件接口一致的接口，并可以添加额外的功能。</li><li><strong>具体装饰器（Concrete Decorator）</strong>：实现了装饰器接口，负责向被装饰的对象添加新的功能。</li></ol><p>下面通过一个简单的例子来说明装饰模式的应用。</p><p>假设我们有一个基础的文本编辑器，它具有一个接口 <code>TextEditor</code>，可以实现编辑文本的基本功能。我们希望能够通过装饰模式来扩展文本编辑器的功能，例如添加加粗、斜体和下划线等样式。</p><p>首先，我们定义组件接口 <code>TextEditor</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TextEditor</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们创建具体组件类 <code>SimpleTextEditor</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleTextEditor</span> : <span class="keyword">public</span> TextEditor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Writing text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，我们创建装饰器接口 <code>TextDecorator</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextDecorator</span> : <span class="keyword">public</span> TextEditor &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    TextEditor* m_textEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextDecorator</span>(TextEditor* textEditor) : <span class="built_in">m_textEditor</span>(textEditor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        m_textEditor-&gt;<span class="built_in">write</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们创建具体装饰器类，例如加粗、斜体和下划线。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoldDecorator</span> : <span class="keyword">public</span> TextDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BoldDecorator</span>(TextEditor* textEditor) : <span class="built_in">TextDecorator</span>(textEditor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Writing text in bold: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItalicDecorator</span> : <span class="keyword">public</span> TextDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ItalicDecorator</span>(TextEditor* textEditor) : <span class="built_in">TextDecorator</span>(textEditor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Writing text in italic: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnderlineDecorator</span> : <span class="keyword">public</span> TextDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnderlineDecorator</span>(TextEditor* textEditor) : <span class="built_in">TextDecorator</span>(textEditor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Writing text with underline: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用装饰模式来扩展文本编辑器的功能。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TextEditor* editor = <span class="keyword">new</span> <span class="built_in">SimpleTextEditor</span>();</span><br><span class="line">    editor-&gt;<span class="built_in">write</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用装饰器来添加额外的功能</span></span><br><span class="line">    TextEditor* boldEditor = <span class="keyword">new</span> <span class="built_in">BoldDecorator</span>(editor);</span><br><span class="line">    boldEditor-&gt;<span class="built_in">write</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TextEditor* italicEditor = <span class="keyword">new</span> <span class="built_in">ItalicDecorator</span>(editor);</span><br><span class="line">    italicEditor-&gt;<span class="built_in">write</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TextEditor* underlineEditor = <span class="keyword">new</span> <span class="built_in">UnderlineDecorator</span>(editor);</span><br><span class="line">    underlineEditor-&gt;<span class="built_in">write</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">delete</span> editor;</span><br><span class="line">    <span class="keyword">delete</span> boldEditor;</span><br><span class="line">    <span class="keyword">delete</span> italicEditor;</span><br><span class="line">    <span class="keyword">delete</span> underlineEditor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过装饰模式，我们成功地扩展了文本编辑器的功能，而不需要修改原有的代码。这样可以实现代码的可复用性和可扩展性。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口，用于访问子系统中的一组接口。外观模式通过将客户端与子系统的复杂性分离，为客户端提供了一个简化的接口，从而隐藏了子系统的复杂性。</p><p><strong>外观模式就是给很多复杂的子系统提供一个简单的上层接口，并在这些接口中包含用户真正关心的功能。</strong></p><p>外观模式主要包括以下几个角色：</p><ol><li><strong>外观（Facade）</strong>：为客户端提供了一个简化的接口，客户端通过外观接口与子系统进行交互，而不需要直接与子系统的组件进行交互。</li><li><strong>子系统（Subsystem）</strong>：包含一组相互关联的类或接口，负责完成具体的功能。</li></ol><p>下面通过一个简单的例子来说明外观模式的应用。</p><p>假设我们有一个电脑系统，其中包含了CPU、内存和硬盘等子系统。客户端想要启动电脑，但不想直接与子系统进行交互，而是希望通过一个简单的接口来启动电脑。</p><p>首先，我们定义外观类 <code>ComputerFacade</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：CPU</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CPU is starting...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：内存</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory is starting...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统类：硬盘</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hard drive is starting...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类：ComputerFacade</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerFacade</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CPU cpu;</span><br><span class="line">    Memory memory;</span><br><span class="line">    HardDrive hardDrive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cpu.<span class="built_in">start</span>();</span><br><span class="line">        memory.<span class="built_in">start</span>();</span><br><span class="line">        hardDrive.<span class="built_in">start</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Computer is started successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中使用外观模式来启动电脑。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComputerFacade computerFacade;</span><br><span class="line">    computerFacade.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过外观模式，客户端可以通过简单的接口 <code>start()</code> 来启动电脑，而不需要了解或直接操作 CPU、内存和硬盘等子系统的细节。外观模式将子系统的复杂性隐藏在背后，提供了一个简单的界面给客户端使用，从而降低了客户端与子系统之间的耦合度。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最大程度地减少内存使用和提高性能。在享元模式中，共享的对象被设计成可共享的，并且可以在需要时被重复使用。</p><p>享元模式主要包括以下几个角色：</p><ol><li><strong>享元接口（Flyweight）</strong>：定义了享元对象的接口，通过这个接口可以接受并作用于外部状态。</li><li><strong>具体享元（Concrete Flyweight）</strong>：实现了享元接口，并为内部状态（可共享状态）提供存储。具体享元对象必须是可共享的，可以在多个环境中重复使用。</li><li><strong>非共享具体享元（Unshared Concrete Flyweight）</strong>：不可共享的享元对象，通常是因为其内部状态无法共享或者不适合共享的原因。</li><li><strong>享元工厂（Flyweight Factory）</strong>：负责创建和管理享元对象，它维护一个享元池（Flyweight Pool），用于存储和管理已经创建的享元对象，确保可以重复使用。</li></ol><p>假设我们有一个简单的游戏，需要绘制大量的树木，并且这些树木在外观上都是相同的，但在位置上是不同的。我们可以使用享元模式来实现树木对象的共享，以节省内存和提高性能。</p><p>首先，我们定义树木类 <code>Tree</code>，它是享元接口，并包含了树木的绘制方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeType</span> : <span class="keyword">public</span> Tree &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string color;</span><br><span class="line">    std::string texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeType</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; color, <span class="type">const</span> std::string&amp; texture)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">color</span>(color), <span class="built_in">texture</span>(texture) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a &quot;</span> &lt;&lt; color &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; texture &lt;&lt; <span class="string">&quot; tree named &quot;</span> &lt;&lt; name</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; at position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建享元工厂类 <code>TreeFactory</code>，用于创建和管理树木对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, TreeType*&gt; treeTypes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeType* <span class="title">getTreeType</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; color, <span class="type">const</span> std::string&amp; texture)</span> </span>&#123;</span><br><span class="line">        std::string key = name + color + texture;</span><br><span class="line">        <span class="keyword">if</span> (treeTypes.<span class="built_in">find</span>(key) == treeTypes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            treeTypes[key] = <span class="keyword">new</span> <span class="built_in">TreeType</span>(name, color, texture);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeTypes[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在客户端代码中使用享元模式来绘制树木。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制多棵树木，位置不同但外观相同</span></span><br><span class="line">    factory.<span class="built_in">getTreeType</span>(<span class="string">&quot;Oak&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Broadleaf&quot;</span>)-&gt;<span class="built_in">draw</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    factory.<span class="built_in">getTreeType</span>(<span class="string">&quot;Pine&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Needle&quot;</span>)-&gt;<span class="built_in">draw</span>(<span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">    factory.<span class="built_in">getTreeType</span>(<span class="string">&quot;Maple&quot;</span>, <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Broadleaf&quot;</span>)-&gt;<span class="built_in">draw</span>(<span class="number">70</span>, <span class="number">40</span>);</span><br><span class="line">    factory.<span class="built_in">getTreeType</span>(<span class="string">&quot;Oak&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Broadleaf&quot;</span>)-&gt;<span class="built_in">draw</span>(<span class="number">90</span>, <span class="number">50</span>); <span class="comment">// 重复使用已有的享元对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过享元模式，我们成功地共享了相同的树木对象，并在不同的位置上对它们进行了重复使用，从而节省了内存空间。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式（Proxy Pattern）是一种结构型设计模式，它允许通过代理对象来控制对真实对象的访问。代理模式通常用于在访问一个对象时引入一定程度的间接性，从而可以在访问对象前后做一些额外的处理。</p><p>代理模式主要包括以下几个角色：</p><ol><li><strong>抽象主题（Subject）</strong>：定义了真实主题和代理主题的共同接口，客户端通过该接口访问真实主题和代理主题。</li><li><strong>真实主题（Real Subject）</strong>：定义了代理所代表的真实对象。</li><li><strong>代理主题（Proxy）</strong>：保存了对真实主题的引用，并提供了与真实主题相同的接口，客户端通过代理对象来间接地访问真实对象。</li></ol><p>下面通过一个简单的例子来说明代理模式的应用。</p><p>假设我们有一个文件加载器（<code>FileLoader</code>）接口，其中定义了加载文件的方法 <code>loadFile()</code>。我们希望在加载文件之前进行权限检查，以确保用户有权限访问该文件。这时可以使用代理模式来实现。</p><p>首先，我们定义了文件加载器接口 <code>FileLoader</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLoader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建了真实主题类 <code>RealFileLoader</code>，用于实际加载文件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealFileLoader</span> : <span class="keyword">public</span> FileLoader &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 实际加载文件的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们创建了代理主题类 <code>ProxyFileLoader</code>，用于在加载文件之前进行权限检查。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFileLoader</span> : <span class="keyword">public</span> FileLoader &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FileLoader* realLoader;</span><br><span class="line">    <span class="type">bool</span> isAdmin; <span class="comment">// 是否是管理员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProxyFileLoader</span>(FileLoader* realLoader, <span class="type">bool</span> isAdmin) : <span class="built_in">realLoader</span>(realLoader), <span class="built_in">isAdmin</span>(isAdmin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">            realLoader-&gt;<span class="built_in">loadFile</span>(filename);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Access denied. You don&#x27;t have permission to access the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在客户端代码中使用代理模式来加载文件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建真实主题对象</span></span><br><span class="line">    FileLoader* realLoader = <span class="keyword">new</span> <span class="built_in">RealFileLoader</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理主题对象</span></span><br><span class="line">    FileLoader* proxyLoader = <span class="keyword">new</span> <span class="built_in">ProxyFileLoader</span>(realLoader, <span class="literal">true</span>); <span class="comment">// 使用管理员权限</span></span><br><span class="line">    proxyLoader-&gt;<span class="built_in">loadFile</span>(<span class="string">&quot;document.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个代理主题对象，权限不足</span></span><br><span class="line">    FileLoader* proxyLoader2 = <span class="keyword">new</span> <span class="built_in">ProxyFileLoader</span>(realLoader, <span class="literal">false</span>); <span class="comment">// 普通用户权限</span></span><br><span class="line">    proxyLoader2-&gt;<span class="built_in">loadFile</span>(<span class="string">&quot;document.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> realLoader;</span><br><span class="line">    <span class="keyword">delete</span> proxyLoader;</span><br><span class="line">    <span class="keyword">delete</span> proxyLoader2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过代理模式，我们成功地引入了一个代理对象来控制对真实对象的访问，在加载文件之前进行了权限检查，从而增加了安全性。</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象在链式结构中依次处理请求，直到其中一个对象能够处理该请求为止。责任链模式将请求的发送者和接收者解耦，使得多个对象都有机会处理请求，从而提高了系统的灵活性和可扩展性。</p><p>在责任链模式中，通常会有一个抽象处理者（Handler）和具体处理者（Concrete Handler）。每个具体处理者都包含一个指向下一个处理者的引用，当收到请求时，它可以选择自己处理或者将请求传递给下一个处理者。</p><p>下面通过一个简单的例子来说明责任链模式的应用。</p><p>假设我们有一个报销审批系统，需要根据报销金额来决定谁来审批。如果报销金额小于等于1000元，则由部门经理审批；如果报销金额大于1000元且小于等于5000元，则由财务部门审批；如果报销金额大于5000元，则由总经理审批。</p><p>首先，我们定义了抽象处理者类 <code>Handler</code>，其中包含了一个指向下一个处理者的引用和一个处理请求的纯虚函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Handler* nextHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Handler</span>() : <span class="built_in">nextHandler</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextHandler</span><span class="params">(Handler* handler)</span> </span>&#123;</span><br><span class="line">        nextHandler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> std::string&amp; applicant, <span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建了具体处理者类 <code>DepartmentManagerHandler</code>、<code>FinanceDepartmentHandler</code> 和 <code>GeneralManagerHandler</code>，分别对应部门经理、财务部门和总经理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepartmentManagerHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> std::string&amp; applicant, <span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Department Manager approves the reimbursement of &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; yuan for &quot;</span> &lt;&lt; applicant &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(applicant, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinanceDepartmentHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> std::string&amp; applicant, <span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">1000</span> &amp;&amp; amount &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Finance Department approves the reimbursement of &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; yuan for &quot;</span> &lt;&lt; applicant &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(applicant, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralManagerHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(<span class="type">const</span> std::string&amp; applicant, <span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;General Manager approves the reimbursement of &quot;</span> &lt;&lt; amount &lt;&lt; <span class="string">&quot; yuan for &quot;</span> &lt;&lt; applicant &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nextHandler-&gt;<span class="built_in">handleRequest</span>(applicant, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在客户端代码中创建责任链，并将请求发送给责任链的第一个处理者。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体处理者对象</span></span><br><span class="line">    Handler* departmentManager = <span class="keyword">new</span> <span class="built_in">DepartmentManagerHandler</span>();</span><br><span class="line">    Handler* financeDepartment = <span class="keyword">new</span> <span class="built_in">FinanceDepartmentHandler</span>();</span><br><span class="line">    Handler* generalManager = <span class="keyword">new</span> <span class="built_in">GeneralManagerHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建责任链</span></span><br><span class="line">    departmentManager-&gt;<span class="built_in">setNextHandler</span>(financeDepartment);</span><br><span class="line">    financeDepartment-&gt;<span class="built_in">setNextHandler</span>(generalManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    departmentManager-&gt;<span class="built_in">handleRequest</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">800</span>);</span><br><span class="line">    departmentManager-&gt;<span class="built_in">handleRequest</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">3000</span>);</span><br><span class="line">    departmentManager-&gt;<span class="built_in">handleRequest</span>(<span class="string">&quot;Carol&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> departmentManager;</span><br><span class="line">    <span class="keyword">delete</span> financeDepartment;</span><br><span class="line">    <span class="keyword">delete</span> generalManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过责任链模式，我们成功地将报销审批的责任传递给了一系列的处理者，每个处理者都有机会处理请求，直到有一个处理者能够处理该请求为止。这样可以灵活地添加、修改或删除处理者，而不需要修改客户端代码。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式（Command Pattern）是一种行为型设计模式，它允许将请求封装成对象，从而使得可以用不同的请求对客户端进行参数化，并且支持对请求排队、记录请求日志、撤销操作等。</p><p>在命令模式中，通常会有四个角色：</p><ol><li><strong>命令接口（Command）</strong>：声明了执行请求的方法 <code>execute()</code>。</li><li><strong>具体命令（Concrete Command）</strong>：实现了命令接口，包含了对接收者的引用，并实现了具体的执行逻辑。</li><li><strong>接收者（Receiver）</strong>：执行具体的操作。</li><li><strong>调用者&#x2F;请求者（Invoker&#x2F;Client）</strong>：创建命令对象并设置其接收者，负责发出请求。</li></ol><p>下面通过一个简单的例子来说明命令模式的应用。</p><p>假设我们有一个遥控器（Remote Control），上面有多个按钮，每个按钮可以控制一个设备执行特定的操作，比如打开电灯、关闭电灯、打开音响、关闭音响等。</p><p>首先，我们定义了命令接口 <code>Command</code>，包含了执行命令的抽象方法 <code>execute()</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们创建了具体命令类 <code>LightOnCommand</code> 和 <code>StereoOffCommand</code>，分别用于控制打开电灯和关闭音响。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Light is on&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Light is off&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stereo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stereo is on&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stereo is off&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Light* light;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LightOnCommand</span>(Light* light) : <span class="built_in">light</span>(light) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StereoOffCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Stereo* stereo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StereoOffCommand</span>(Stereo* stereo) : <span class="built_in">stereo</span>(stereo) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        stereo-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们创建了调用者&#x2F;请求者类 <code>RemoteControl</code>，用于将命令对象与具体的按钮关联起来，并执行相应的命令。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command* slot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommand</span><span class="params">(Command* cmd)</span> </span>&#123;</span><br><span class="line">        slot = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buttonPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">            slot-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在客户端代码中使用命令模式来控制设备。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建命令对象和接收者对象</span></span><br><span class="line">    Light* light = <span class="keyword">new</span> <span class="built_in">Light</span>();</span><br><span class="line">    Stereo* stereo = <span class="keyword">new</span> <span class="built_in">Stereo</span>();</span><br><span class="line">    Command* lightOnCommand = <span class="keyword">new</span> <span class="built_in">LightOnCommand</span>(light);</span><br><span class="line">    Command* stereoOffCommand = <span class="keyword">new</span> <span class="built_in">StereoOffCommand</span>(stereo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建调用者对象并设置命令</span></span><br><span class="line">    RemoteControl remoteControl;</span><br><span class="line">    remoteControl.<span class="built_in">setCommand</span>(lightOnCommand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟按下按钮</span></span><br><span class="line">    remoteControl.<span class="built_in">buttonPressed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新命令对象</span></span><br><span class="line">    remoteControl.<span class="built_in">setCommand</span>(stereoOffCommand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟按下按钮</span></span><br><span class="line">    remoteControl.<span class="built_in">buttonPressed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> light;</span><br><span class="line">    <span class="keyword">delete</span> stereo;</span><br><span class="line">    <span class="keyword">delete</span> lightOnCommand;</span><br><span class="line">    <span class="keyword">delete</span> stereoOffCommand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过命令模式，我们成功地将命令封装成对象，使得可以轻松地将命令与调用者解耦，并且支持命令的排队、记录和撤销等操作。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，用于提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示。迭代器模式将遍历元素的责任交给迭代器对象，而不是聚合对象本身，从而实现了解耦和更好的封装性。</p><p>在迭代器模式中，通常会有两个角色：</p><ol><li><strong>迭代器（Iterator）</strong>：定义了访问和遍历元素的接口，包括获取下一个元素、判断是否还有元素等方法。</li><li><strong>具体迭代器（Concrete Iterator）</strong>：实现了迭代器接口，在具体聚合对象上进行迭代。</li></ol><p>下面通过一个简单的例子来说明迭代器模式的应用。</p><p>假设我们有一个列表类 <code>List</code>，其中包含了一组整数，我们希望能够通过迭代器来依次访问这些整数。</p><p>首先，我们定义了迭代器接口 <code>Iterator</code>，包含了访问和遍历元素的抽象方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建了具体迭代器类 <code>ListIterator</code>，用于在列表上进行迭代。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;&amp; list;</span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListIterator</span>(std::vector&lt;<span class="type">int</span>&gt;&amp; list) : <span class="built_in">list</span>(list), <span class="built_in">index</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list[index++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; list.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们创建了聚合类 <code>List</code>，其中包含了一个返回迭代器的方法 <code>createIterator()</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Iterator&gt; <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ListIterator&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们在客户端代码中使用迭代器来遍历列表。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list;</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建迭代器并遍历列表</span></span><br><span class="line">    std::shared_ptr&lt;Iterator&gt; iterator = list.<span class="built_in">createIterator</span>();</span><br><span class="line">    <span class="keyword">while</span> (iterator-&gt;<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; iterator-&gt;<span class="built_in">next</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过迭代器模式，我们成功地将遍历元素的责任从聚合对象中分离出来，使得聚合对象和遍历算法能够独立演化，同时也使得客户端代码更加简洁和易于扩展。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它用于减少对象之间的直接通信，而是通过一个中介对象来协调和控制各个对象之间的交互。这种模式提供了一种集中化的方式来管理复杂的关联关系，使得各个对象之间的耦合度降低，系统更易于维护和扩展。</p><p>在中介者模式中，通常会存在以下几个角色：</p><ol><li><strong>中介者（Mediator）：</strong> 定义了一个接口用于各个同事对象之间的通信，并负责协调各个同事对象的行为。</li><li><strong>具体中介者（Concrete Mediator）：</strong> 实现了中介者接口，负责实际的协调工作，了解并维护各个同事对象之间的关系。</li><li><strong>同事对象（Colleague）：</strong> 每个同事对象都知道中介者对象，但它们之间并不直接通信，而是通过中介者对象来进行消息的传递和交互。</li><li><strong>具体同事对象（Concrete Colleague）：</strong> 实现了同事对象接口，负责自己的业务逻辑，并与其他同事对象通过中介者对象进行通信。</li></ol><p>下面通过一个简单的例子来说明中介者模式的应用。</p><p>假设我们有一个简单的聊天室程序，其中包含多个用户（同事对象），用户之间可以发送消息进行通信，我们可以使用中介者模式来实现这个聊天室。</p><p>首先，我们定义了中介者接口 <code>ChatRoom</code>，并声明了用于发送消息的方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; sender)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们创建了具体中介者类 <code>ConcreteChatRoom</code>，实现了中介者接口，并在其中实现了消息的发送逻辑。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteChatRoom</span> : <span class="keyword">public</span> ChatRoom &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message, <span class="type">const</span> std::string&amp; sender)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; sender &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，我们定义了同事对象接口 <code>User</code>，并声明了用于发送消息的方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ChatRoom* mediator;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>(ChatRoom* mediator, <span class="type">const</span> std::string&amp; name) : <span class="built_in">mediator</span>(mediator), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">receiveMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，我们创建了具体同事对象类 <code>ConcreteUser</code>，实现了同事对象接口，并在其中实现了发送消息和接收消息的逻辑。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteUser</span> : <span class="keyword">public</span> User &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteUser</span>(ChatRoom* mediator, <span class="type">const</span> std::string&amp; name) : <span class="built_in">User</span>(mediator, name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        mediator-&gt;<span class="built_in">sendMessage</span>(message, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; received a message]: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们可以在客户端代码中创建多个用户并加入到聊天室中，它们之间可以通过中介者对象进行消息的发送和接收。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ChatRoom* chatRoom = <span class="keyword">new</span> <span class="built_in">ConcreteChatRoom</span>();</span><br><span class="line"></span><br><span class="line">    User* user1 = <span class="keyword">new</span> <span class="built_in">ConcreteUser</span>(chatRoom, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    User* user2 = <span class="keyword">new</span> <span class="built_in">ConcreteUser</span>(chatRoom, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user1-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hello, Bob!&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;Hi, Alice!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> user1;</span><br><span class="line">    <span class="keyword">delete</span> user2;</span><br><span class="line">    <span class="keyword">delete</span> chatRoom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过中介者模式，我们成功地将用户之间的通信逻辑从用户对象中分离出来，由中介者对象负责协调和管理，使得系统更加灵活和易于扩展。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式（Memento Pattern）是一种行为型设计模式，用于捕获对象的内部状态，并在需要时将对象恢复到先前的状态。该模式通常用于需要实现撤销操作或者保存历史状态的场景。</p><h3 id="角色说明："><a href="#角色说明：" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>发起人（Originator）：</strong> 负责创建备忘录（Memento），并将自身状态保存到备忘录中或者从备忘录中恢复状态。</li><li><strong>备忘录（Memento）：</strong> 存储发起人对象的内部状态，在需要时可以将状态恢复到先前的状态。</li><li><strong>管理者（Caretaker）：</strong> 负责保存和管理备忘录对象，但不对备忘录的内容进行操作。</li></ul><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>保存状态：</strong> 当发起人对象需要保存当前状态时，创建一个备忘录对象，并将当前状态保存到备忘录中。</li><li><strong>恢复状态：</strong> 当需要恢复到先前的状态时，从备忘录中获取之前保存的状态，并将发起人对象恢复到该状态。</li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个文本编辑器程序，用户可以编辑文本并执行撤销操作。我们可以使用备忘录模式来实现撤销功能。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">const</span> std::string&amp; state) : <span class="built_in">state</span>(state) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getText</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">createMemento</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Memento</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">restoreFromMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        text = memento.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Memento memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memento <span class="title">retrieve</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Editor editor;</span><br><span class="line">    History history;</span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">setText</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    history.<span class="built_in">save</span>(editor.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    editor.<span class="built_in">setText</span>(<span class="string">&quot;Hello, design patterns!&quot;</span>);</span><br><span class="line">    history.<span class="built_in">save</span>(editor.<span class="built_in">createMemento</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复到先前的状态</span></span><br><span class="line">    editor.<span class="built_in">restoreFromMemento</span>(history.<span class="built_in">retrieve</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After undo: &quot;</span> &lt;&lt; editor.<span class="built_in">getText</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Editor</code> 类表示文本编辑器，<code>Memento</code> 类表示备忘录，<code>History</code> 类表示撤销历史记录。通过备忘录模式，用户可以编辑文本并执行撤销操作，恢复到之前的编辑状态。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式（Observer Pattern）是一种行为型设计模式，用于定义对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。这种模式也被称为发布-订阅（Publish-Subscribe）模式。</p><h3 id="角色说明：-1"><a href="#角色说明：-1" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>主题（Subject）：</strong> 也称为被观察者或可观察对象，它维护一系列观察者对象，并提供注册和移除观察者的方法，以及通知观察者的方法。</li><li><strong>观察者（Observer）：</strong> 也称为订阅者或监听者，它定义了一个更新的接口，以便主题在状态发生变化时能够通知观察者进行更新。</li><li><strong>具体主题（ConcreteSubject）：</strong> 实现了主题接口的具体类，在状态发生变化时会通知所有注册的观察者。</li><li><strong>具体观察者（ConcreteObserver）：</strong> 实现了观察者接口的具体类，当收到主题的通知时会执行更新操作。</li></ul><h3 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>注册观察者：</strong> 观察者通过注册到主题上来订阅主题的状态变化。</li><li><strong>状态变化通知：</strong> 主题在状态发生变化时会通知所有注册的观察者。</li><li><strong>更新操作：</strong> 收到通知的观察者会执行相应的更新操作，以响应状态变化。</li></ol><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个天气数据的发布订阅系统，气象站（主题）会定期发布实时天气数据，而多个天气预报应用（观察者）可以订阅气象站的数据并进行展示。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* observer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherObserver</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temperature)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current temperature: &quot;</span> &lt;&lt; temperature &lt;&lt; <span class="string">&quot; degrees Celsius&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(observers.<span class="built_in">begin</span>(), observers.<span class="built_in">end</span>(), observer);</span><br><span class="line">        <span class="keyword">if</span> (it != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            observers.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer* observer : observers) &#123;</span><br><span class="line">            observer-&gt;<span class="built_in">update</span>(temperature);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTemperature</span><span class="params">(<span class="type">float</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeatherStation weatherStation;</span><br><span class="line">    WeatherObserver observer1, observer2;</span><br><span class="line"></span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;observer1);</span><br><span class="line">    weatherStation.<span class="built_in">registerObserver</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    weatherStation.<span class="built_in">setTemperature</span>(<span class="number">25.5f</span>); <span class="comment">// 发布天气数据</span></span><br><span class="line">    weatherStation.<span class="built_in">setTemperature</span>(<span class="number">30.0f</span>); <span class="comment">// 发布天气数据</span></span><br><span class="line"></span><br><span class="line">    weatherStation.<span class="built_in">removeObserver</span>(&amp;observer2);</span><br><span class="line"></span><br><span class="line">    weatherStation.<span class="built_in">setTemperature</span>(<span class="number">28.0f</span>); <span class="comment">// 发布天气数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>WeatherStation</code> 类是具体主题类，<code>WeatherObserver</code> 类是具体观察者类。当气象站更新天气数据时，会调用 <code>setTemperature()</code> 方法来通知所有注册的观察者。观察者收到通知后，会调用 <code>update()</code> 方法来更新显示当前温度。7100</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，将每个算法封装到独立的类中，并使它们可以相互替换。策略模式使得算法可以独立于客户端而变化，从而使得客户端可以根据需要选择不同的算法。</p><h3 id="角色说明：-2"><a href="#角色说明：-2" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>策略接口（Strategy）：</strong> 定义了所有支持的算法的通用接口。</li><li><strong>具体策略类（ConcreteStrategy）：</strong> 实现了策略接口，并封装了具体的算法。</li><li><strong>上下文（Context）：</strong> 维护一个对策略对象的引用，并负责将客户端的请求委托给具体的策略对象。</li></ul><h3 id="工作原理：-2"><a href="#工作原理：-2" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>封装算法：</strong> 将每个算法封装到具体的策略类中。</li><li><strong>选择算法：</strong> 在上下文中选择并保存一个具体的策略对象。</li><li><strong>执行算法：</strong> 当客户端需要执行某个算法时，直接调用上下文对象的方法，并委托给当前选择的具体策略对象执行。</li></ol><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>作为橡胶人路飞，平时白痴但战斗时头脑异常清醒，会根据敌我双方的形式做出正确的判断：</p><p>对手战力弱，使用1档并根据实际情况使用相应的招式<br>对手战力一般，切换2档并根据实际情况使用相应的招式<br>对手战力强，切换3档并根据实际情况使用相应的招式<br>对手战力无敌，切换4档并根据实际情况使用相应的招式<br>对手战斗逆天，切换5档并根据实际情况使用相应的招式<br>假设将所有的策略都写到一个类中就会使得路飞这个类过于复杂，而且不容易维护，如果基于策略模式来处理路飞这个类，可以把关于在什么场景下使用什么策略的判断去除，把处理逻辑分散到多个不同的策略类中，这样就可以将复杂的逻辑简化了。</p><p>根据上面的描述路飞一共有五种形态，不论使用哪种形态都需要制定战斗策略，这一点是不变的，所以我们就可以定义出一个抽象的策略类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractStrategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractStrategy</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个抽象类中的fight()函数有一个布尔类型的参数，表示在当前这个状态下是要进行近距离攻击还是远程攻击，参数不同，在这种状态下使用的招式也不同。有了这个抽象的基类，就可以定义出一系列的子类了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一档</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YiDang</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*** 现在使用的是一档: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isfar)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶机关枪&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶·攻城炮&quot;</span> &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二挡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErDang</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*** 切换成二挡: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isfar)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶Jet火箭&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶Jet·铳乱打&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三挡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SanDang</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*** 切换成三挡: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isfar)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶巨人回旋弹&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶巨人战斧&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四挡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SiDang</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*** 切换成四挡: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isfar)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶狮子火箭炮&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;橡胶犀牛榴弹炮&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 五档</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuDang</span> : <span class="keyword">public</span> AbstractStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(<span class="type">bool</span> isfar = <span class="literal">false</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*** 切换成五挡: 变成尼卡形态可以把物体变成橡胶, 并任意改变物体的形态对其进行攻击!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这五个子类分别对应的路飞的一档、二挡、三挡、四挡、五档，也就是五种不同的策略，在它们内部都重写了从基类继承的纯虚函数fight()，并根据函数的参数做了不同的处理。通过这种方式的拆分就把复杂的问题简单化了，有种兄弟分家的感觉，本来是在同一个屋檐下，分家之后都有了自己的房子，各过各的互不干涉。</p><p>上面说到了分家，那个这几个儿子的爹是谁呢？没错，就是路飞，这五个子类都是路飞的果实能力，但是现在他们从路飞这个对象中分离出去了。所以现在路飞和这几个技能的状态类之间就变成了组合关系。关于路飞这个类我们可以这样定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 难度级别</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Level</span>:<span class="type">char</span> &#123;Easy, Normal, Hard, Experts, Professional&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路飞</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Luffy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">(Level level, <span class="type">bool</span> isfar = <span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_strategy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_strategy;</span><br><span class="line">            m_strategy = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (level)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Level::Easy:</span><br><span class="line">            m_strategy = <span class="keyword">new</span> YiDang;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level::Normal:</span><br><span class="line">            m_strategy = <span class="keyword">new</span> ErDang;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level::Hard:</span><br><span class="line">            m_strategy = <span class="keyword">new</span> SanDang;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level::Experts:</span><br><span class="line">            m_strategy = <span class="keyword">new</span> SiDang;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Level::Professional:</span><br><span class="line">            m_strategy = <span class="keyword">new</span> WuDang;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_strategy-&gt;<span class="built_in">fight</span>(isfar);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Luffy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_strategy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractStrategy* m_strategy = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Luffy 类中的fight()方法里边根据参数传递进来的难度级别，路飞在战斗的时候就可以选择开启对应的档位使用相关的招式来击败对手。</p><p>路飞在战斗的时候头脑还是非常灵活的，下面来看一下路飞经历过的一些战斗：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Luffy* luffy = <span class="keyword">new</span> Luffy;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--- 在香波地群岛遇到了海军士兵: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    luffy-&gt;<span class="built_in">fight</span>(Level::Easy);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--- 在魔谷镇遇到了贝拉米: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    luffy-&gt;<span class="built_in">fight</span>(Level::Normal);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--- 在司法岛遇到了罗布·路奇: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    luffy-&gt;<span class="built_in">fight</span>(Level::Hard);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--- 在德雷斯罗萨遇到了多弗朗明哥: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    luffy-&gt;<span class="built_in">fight</span>(Level::Experts);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--- 在鬼岛遇到了凯多: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    luffy-&gt;<span class="built_in">fight</span>(Level::Professional);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> luffy;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">--- 在香波地群岛遇到了海军士兵:</span><br><span class="line">*** 现在使用的是一档: 橡胶·攻城炮</span><br><span class="line">--- 在魔谷镇遇到了贝拉米:</span><br><span class="line">*** 切换成二挡: 橡胶Jet·铳乱打</span><br><span class="line">--- 在司法岛遇到了罗布·路奇:</span><br><span class="line">*** 切换成三挡: 橡胶巨人战斧</span><br><span class="line">--- 在德雷斯罗萨遇到了多弗朗明哥:</span><br><span class="line">*** 切换成四挡: 橡胶犀牛榴弹炮</span><br><span class="line">--- 在鬼岛遇到了凯多:</span><br><span class="line">*** 切换成五挡: 变成尼卡形态可以把物体变成橡胶, 并任意改变物体的形态对其进行攻击!!!</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为，使得对象看起来好像修改了其类。状态模式将对象的状态封装成独立的类，并将行为委托给当前状态对象。这样可以避免在对象内部使用大量的条件语句来切换行为，提高了代码的可维护性和可扩展性。</p><h3 id="角色说明：-3"><a href="#角色说明：-3" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>环境类（Context）：</strong> 定义了客户感兴趣的接口，并维护一个具体状态子类的实例，用于定义当前的状态。</li><li><strong>抽象状态类（State）：</strong> 定义了一个接口，用于封装与环境对象的一个特定状态相关的行为。</li><li><strong>具体状态类（Concrete State）：</strong> 实现了抽象状态类定义的接口，并实现了与环境对象当前状态相关的行为。</li></ul><h3 id="工作原理：-3"><a href="#工作原理：-3" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>定义状态：</strong> 将对象的各种状态封装成独立的状态类。</li><li><strong>状态切换：</strong> 当对象的状态发生改变时，切换到对应的状态类。</li><li><strong>委托行为：</strong> 将对象的行为委托给当前状态类处理。</li></ol><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个文档编辑器，可以根据文档的不同状态（未保存、已保存、已打开等）来执行不同的操作。我们可以使用状态模式来实现文档编辑器的状态管理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentState</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleSave</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleOpen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：未保存状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsavedState</span> : <span class="keyword">public</span> DocumentState &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleSave</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Document is saved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleOpen</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening unsaved document...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Closing unsaved document...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态类：已保存状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavedState</span> : <span class="keyword">public</span> DocumentState &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleSave</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Document is already saved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleOpen</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Opening saved document...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Closing saved document...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DocumentState* currentState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DocumentEditor</span>() : <span class="built_in">currentState</span>(<span class="keyword">new</span> <span class="built_in">UnsavedState</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(DocumentState* state)</span> </span>&#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">handleSave</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">handleOpen</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState-&gt;<span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DocumentEditor editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前状态为未保存，执行保存操作</span></span><br><span class="line">    editor.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换状态为已保存，执行打开操作</span></span><br><span class="line">    editor.<span class="built_in">setState</span>(<span class="keyword">new</span> <span class="built_in">SavedState</span>());</span><br><span class="line">    editor.<span class="built_in">open</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次执行保存操作</span></span><br><span class="line">    editor.<span class="built_in">save</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行关闭操作</span></span><br><span class="line">    editor.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>DocumentState</code> 是抽象状态类，<code>UnsavedState</code> 和 <code>SavedState</code> 是具体的状态类，<code>DocumentEditor</code> 是上下文类。编辑器根据文档的状态执行不同的操作，例如保存、打开、关闭等。通过状态模式，可以轻松地管理文档编辑器的状态转换和行为。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</p><h3 id="角色说明：-4"><a href="#角色说明：-4" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>抽象类（Abstract Class）：</strong> 定义了一个模板方法，其中包含了算法的框架和部分步骤的具体实现，这些步骤可以是抽象的，由子类去实现。</li><li><strong>具体类（Concrete Class）：</strong> 实现了抽象类中定义的抽象方法，完成算法中剩余的具体步骤。</li></ul><h3 id="工作原理：-4"><a href="#工作原理：-4" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>定义模板方法：</strong> 在抽象类中定义一个模板方法，包含了算法的框架和一些具体步骤的实现。</li><li><strong>实现具体步骤：</strong> 在具体类中实现抽象类中定义的抽象方法，完成算法的具体步骤。</li><li><strong>执行模板方法：</strong> 调用抽象类中的模板方法，触发算法的执行，其中包含了具体类中实现的步骤。</li></ol><h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个制作咖啡和茶的过程，其中煮水、冲泡和倒入杯中的步骤在两种饮料中都存在，但添加调料的步骤各不相同。我们可以使用模板方法模式来实现这个过程。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类：饮料</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法：制作饮料</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">boilWater</span>();</span><br><span class="line">        <span class="built_in">brew</span>();</span><br><span class="line">        <span class="built_in">pourInCup</span>();</span><br><span class="line">        <span class="built_in">addCondiments</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：添加调料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法：煮水</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Boiling water...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法：倒入杯中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pouring into cup...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实现冲泡方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dripping Coffee through filter...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现添加调料方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding Sugar and Milk...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类：茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Beverage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实现冲泡方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Steeping the tea...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现添加调料方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCondiments</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding Lemon...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Beverage* coffee = <span class="keyword">new</span> <span class="built_in">Coffee</span>();</span><br><span class="line">    Beverage* tea = <span class="keyword">new</span> <span class="built_in">Tea</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Making Coffee...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    coffee-&gt;<span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nMaking Tea...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    tea-&gt;<span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> coffee;</span><br><span class="line">    <span class="keyword">delete</span> tea;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Beverage</code> 是抽象类，定义了一个模板方法 <code>prepare()</code>，其中包含了制作饮料的整个流程，包括煮水、冲泡、倒入杯中和添加调料。<code>Coffee</code> 和 <code>Tea</code> 是具体类，实现了 <code>brew()</code> 和 <code>addCondiments()</code> 方法，完成了咖啡和茶的具体制作过程。通过模板方法模式，我们可以在不改变制作饮料流程的情况下，方便地添加新的饮料类。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式（Visitor Pattern）是一种行为型设计模式，用于在不改变对象结构的前提下，为对象结构中的元素添加新的操作。它将操作封装成独立的访问者类，使得可以在不修改元素类的情况下定义新的操作。</p><h3 id="角色说明：-5"><a href="#角色说明：-5" class="headerlink" title="角色说明："></a>角色说明：</h3><ul><li><strong>访问者（Visitor）：</strong> 定义了对每个元素的访问操作，可以访问不同类型的元素，并执行相应的操作。</li><li><strong>具体访问者（Concrete Visitor）：</strong> 实现了访问者定义的操作，对对象结构中的元素进行具体操作。</li><li><strong>元素（Element）：</strong> 定义了一个接受访问者的方法，接受一个访问者对象作为参数，以便让访问者访问自己。</li><li><strong>具体元素（Concrete Element）：</strong> 实现了元素定义的接受访问者方法，将自身传递给访问者，以便访问者对自己进行操作。</li><li><strong>对象结构（Object Structure）：</strong> 包含了一个元素的集合，可以是一个列表、数组、树等数据结构，提供了遍历元素的方法。</li></ul><h3 id="工作原理：-5"><a href="#工作原理：-5" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>定义访问者接口：</strong> 确定访问者可以执行的操作，定义在访问者接口中。</li><li><strong>实现具体访问者：</strong> 实现访问者接口中定义的操作，针对不同的元素进行不同的处理。</li><li><strong>定义元素接口：</strong> 确定元素可以接受访问者的方法，定义在元素接口中。</li><li><strong>实现具体元素：</strong> 实现元素接口中的接受访问者方法，将自身传递给访问者进行处理。</li><li><strong>组织对象结构：</strong> 组织一个包含元素的集合，提供遍历元素的方法。</li><li><strong>客户端调用：</strong> 创建具体访问者和具体元素对象，将具体元素对象添加到对象结构中，并调用访问者对象的访问方法。</li></ol><h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><p>假设有一个图形编辑器，其中包含了多种图形（如圆形、矩形、三角形等），我们需要为不同类型的图形添加不同的操作（如计算面积、计算周长等）。我们可以使用访问者模式来实现这个需求。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Circle&amp; circle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Rectangle&amp; rectangle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Triangle&amp; triangle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者：面积计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> : <span class="keyword">public</span> ShapeVisitor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Circle&amp; circle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area of Circle: &quot;</span> &lt;&lt; <span class="number">3.14</span> * circle.radius * circle.radius &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Rectangle&amp; rectangle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area of Rectangle: &quot;</span> &lt;&lt; rectangle.width * rectangle.height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Triangle&amp; triangle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Area of Triangle: &quot;</span> &lt;&lt; <span class="number">0.5</span> * triangle.base * triangle.height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体元素：三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> base;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">double</span> b, <span class="type">double</span> h) : <span class="built_in">base</span>(b), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(ShapeVisitor&amp; visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visit</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建具体元素对象</span></span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rectangle</span><span class="params">(<span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Triangle <span class="title">triangle</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建具体访问者对象</span></span><br><span class="line">    AreaCalculator areaCalculator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具体访问者对象访问具体元素对象</span></span><br><span class="line">    circle.<span class="built_in">accept</span>(areaCalculator);</span><br><span class="line">    rectangle.<span class="built_in">accept</span>(areaCalculator);</span><br><span class="line">    triangle.<span class="built_in">accept</span>(areaCalculator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了图形编辑器中的几种图形（圆形、矩形、三角形）作为具体元素，以及一个面积计算器作为具体访问者。通过访问者模式，我们可以轻松地添加新的操作，例如计算周长、绘制图形等，而不需要修改图形类的代码，这符合开闭原则的设计理念。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL查漏补缺</title>
      <link href="/2024/09/26/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2024/09/26/STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="反向迭代器适配器（reverse-iterator）"><a href="#反向迭代器适配器（reverse-iterator）" class="headerlink" title="反向迭代器适配器（reverse_iterator）"></a>反向迭代器适配器（reverse_iterator）</h1><p>鸡肋，一般迭代器都提供了begin()和end()的反向库rbegin()和rend();</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::reverse_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator&gt; my_reiter;</span><br></pre></td></tr></table></figure><h1 id="STL插入迭代器适配器（insert-iterator）"><a href="#STL插入迭代器适配器（insert-iterator）" class="headerlink" title="STL插入迭代器适配器（insert_iterator）"></a>STL插入迭代器适配器（insert_iterator）</h1><p>插入迭代器适配器（insert_iterator），简称插入迭代器或者插入器，其功能就是向指定容器中插入元素。值得一提的是，根据插入位置的不同，C++ STL 标准库提供了 3 种插入迭代器</p><table><thead><tr><th>迭代器适配器</th><th>功能</th></tr></thead><tbody><tr><td>back_insert_iterator</td><td>在指定容器的尾部插入新元素，但前提必须是提供有 push_back() 成员方法的容器（包括 vector、deque 和 list）。</td></tr><tr><td>front_insert_iterator</td><td>在指定容器的头部插入新元素，但前提必须是提供有 push_front() 成员方法的容器（包括 list、deque 和 forward_list）。</td></tr><tr><td>insert_iterator</td><td>在容器的指定位置之前插入新元素，前提是该容器必须提供有 insert() 成员方法。</td></tr></tbody></table><h2 id="back-insert-iterator迭代器-鸡肋"><a href="#back-insert-iterator迭代器-鸡肋" class="headerlink" title="back_insert_iterator迭代器(鸡肋)"></a>back_insert_iterator迭代器(鸡肋)</h2><p>back_insert_iterator 迭代器可用于在指定容器的末尾处添加新元素。</p><p>需要注意的是，由于此类型迭代器的底层实现需要调用指定容器的 push_back() 成员方法，这就意味着，此类型迭代器并不适用于 STL 标准库中所有的容器，它只适用于包含 push_back() 成员方法的容器。</p><p>C++ STL 标准库中，提供有 push_back() 成员方法的容器包括 vector、deque 和 list。(实际上也鸡肋，push_back()可以直接使用)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; foo;</span><br><span class="line">    <span class="comment">//创建一个可向 foo 容器尾部添加新元素的迭代器</span></span><br><span class="line">    std::back_insert_iterator&lt; std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">back_it</span>(foo);</span><br><span class="line">    <span class="comment">//将 5 插入到 foo 的末尾</span></span><br><span class="line">    back_it = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//将 4 插入到当前 foo 的末尾</span></span><br><span class="line">    back_it = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//将 3 插入到当前 foo 的末尾</span></span><br><span class="line">    back_it = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//将 6 插入到当前 foo 的末尾</span></span><br><span class="line">    back_it = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//输出 foo 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>(); it != foo.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="front-insert-iterator迭代器-鸡肋"><a href="#front-insert-iterator迭代器-鸡肋" class="headerlink" title="front_insert_iterator迭代器(鸡肋)"></a>front_insert_iterator迭代器(鸡肋)</h2><p>和 back_insert_iterator 正好相反，front_insert_iterator 迭代器的功能是向目标容器的头部插入新元素。</p><p>并且，由于此类型迭代器的底层实现需要借助目标容器的 push_front() 成员方法，这意味着，只有包含 push_front() 成员方法的容器才能使用该类型迭代器。</p><p>C++ STL 标准库中，提供有 push_front() 成员方法的容器，仅有 deque、list 和 forward_list。&#x3D;&#x3D;鸡肋&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 forward_list 容器</span></span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; foo;</span><br><span class="line">    <span class="comment">//创建一个前插入迭代器</span></span><br><span class="line">    <span class="comment">//std::front_insert_iterator&lt; std::forward_list&lt;int&gt; &gt; front_it(foo);</span></span><br><span class="line">    std::front_insert_iterator&lt; std::forward_list&lt;<span class="type">int</span>&gt; &gt; front_it = <span class="built_in">front_inserter</span>(foo);</span><br><span class="line">    <span class="comment">//向 foo 容器的头部插入元素</span></span><br><span class="line">    front_it = <span class="number">5</span>;</span><br><span class="line">    front_it = <span class="number">4</span>;</span><br><span class="line">    front_it = <span class="number">3</span>;</span><br><span class="line">    front_it = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::forward_list&lt;<span class="type">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>(); it != foo.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="insert-iterator迭代器-有用"><a href="#insert-iterator迭代器-有用" class="headerlink" title="insert_iterator迭代器(有用)"></a>insert_iterator迭代器(有用)</h2><p>当需要向容器的任意位置插入元素时，就可以使用 insert_iterator 类型的迭代器。</p><p>需要说明的是，该类型迭代器的底层实现，需要调用目标容器的 insert() 成员方法。但幸运的是，&#x3D;&#x3D;STL 标准库中所有容器都提供有 insert() 成员方法，因此 insert_iterator 是唯一可用于关联式容器的插入迭代器。&#x3D;&#x3D;</p><p>和前 2 种插入迭代器一样，insert_iterator 迭代器也定义在 <iterator> 头文件，并位于 std 命名空间中，因此在使用该类型迭代器之前，程序应包含如下语句：</iterator></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>不同之处在于，定义 insert_iterator 类型迭代器的语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::insert_iterator&lt;Container&gt; <span class="title">insert_it</span> <span class="params">(container,it)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，Container 表示目标容器的类型，参数 container 表示目标容器，而 it 是一个基础迭代器，表示新元素的插入位置。</p><p>和前 2 种插入迭代器相比，insert_iterator 迭代器除了定义时需要多传入一个参数，它们的用法完全相同。除此之外，C++ STL 标准库中还提供有 inserter() 函数，可以快速创建 insert_iterator 类型迭代器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化为 &#123;5,5&#125;</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;<span class="comment">//&#123;5,5&#125;</span></span><br><span class="line">    <span class="comment">//定义一个基础迭代器，用于指定要插入新元素的位置</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt;::iterator it = ++foo.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//创建一个 insert_iterator 迭代器</span></span><br><span class="line">    <span class="comment">//std::insert_iterator&lt; std::list&lt;int&gt; &gt; insert_it(foo, it);</span></span><br><span class="line">    std::insert_iterator&lt; std::list&lt;<span class="type">int</span>&gt; &gt; insert_it = <span class="built_in">inserter</span>(foo, it);</span><br><span class="line">    <span class="comment">//向 foo 容器中插入元素</span></span><br><span class="line">    insert_it = <span class="number">1</span>;</span><br><span class="line">    insert_it = <span class="number">2</span>;</span><br><span class="line">    insert_it = <span class="number">3</span>;</span><br><span class="line">    insert_it = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//输出 foo 容器存储的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::list&lt;<span class="type">int</span>&gt;::iterator it = foo.<span class="built_in">begin</span>(); it != foo.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果 insert_iterator 迭代器的目标容器为关联式容器，由于该类型容器内部会自行对存储的元素进行排序，因此我们指定的插入位置只起到一个提示的作用，即帮助关联式容器从指定位置开始，搜索正确的插入位置。但是，如果提示位置不正确，会使的插入操作的效率更加糟糕。</p><hr><h2 id="流迭代器-istream-iterator和ostream-iterator-可了解"><a href="#流迭代器-istream-iterator和ostream-iterator-可了解" class="headerlink" title="流迭代器(istream_iterator和ostream_iterator)(可了解)"></a>流迭代器(istream_iterator和ostream_iterator)(可了解)</h2><h3 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>用 operator&lt;&lt; 写入 T 类型对象到为之创建迭代器的 std::basic_ostream 对象。每次写操作后写入可选的分隔字符串</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(v1.<span class="built_in">begine</span>(),v2.<span class="built_in">end</span>(),out_it);</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ostream_iterator</span></span><br><span class="line">    : <span class="keyword">public</span> iterator&lt;output_iterator_tag, <span class="type">void</span>, <span class="type">void</span>, <span class="type">void</span>, <span class="type">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">ostream_type*_M_stream;</span><br><span class="line"><span class="type">const</span> _CharT*_M_string;</span><br><span class="line">        ostream_iterator&amp; <span class="keyword">operator</span>=(<span class="type">const</span> _Tp&amp; __value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// T 类型对象到为之创建迭代器的 std::basic_ostream 对象</span></span><br><span class="line">            *_M_stream &lt;&lt; __value;   </span><br><span class="line">            <span class="comment">// 每次写操作后写入可选的分隔字符串</span></span><br><span class="line">            <span class="keyword">if</span> (_M_string)</span><br><span class="line">                  *_M_stream &lt;&lt; _M_string;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对任何具有输出运算符（&lt;&lt;运算符）的定义ostream_iterator.<br>当创建一个ostream_iterator时，我们可以提供(可选的)第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个c风格的字符串（即,一个字符串字面常量或者指向一个空字符结尾的字符数组指针）。<br>必须将ostream_iterator绑定到一个指定的流，不能够存在空的或表示尾后位置的ostream_iterator<br>我们可以用ostream_iterator来输出值的序列:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">*out_iter++ = e;<span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>此程序将vec中的每个元素写到cout,每个元素后加一个空格。</p></li><li><p>每次向out_iter赋值时，写操作就会被提交</p></li><li><p><strong>值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">out_iter= e;<span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>注意: 运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。<br>但是，推荐第一种写法，在这种写法中，流迭代器的使用和其他迭代器的使用保持一致。如果想要将此循环改为操作其他迭代器的类型，修改起来非常容易.而且，对于读者来说，此循环的行为也更为清晰。</strong></p></li><li><p>可以调用copy来打印vec中的元素，这比编写循环更为简单:</p></li></ul><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h3><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p>std::istream_iterator 是单趟输入迭代器，从为之创建迭代器的 std::basic_istream 对象读取 T 类型的相继对象，通过调用适当的 operator&gt;&gt; 。<strong>实际读取操作在自增，而非解引用迭代器时进行。</strong>在构造迭代器时读取首个对象。解引用只返回最近读取的对象的副本。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::istream_iterator&lt;<span class="type">double</span>&gt; eos;</span><br><span class="line"><span class="function">std::istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(std::cin)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(iit!=eos) value1 = *iit;</span><br><span class="line">++iit;</span><br><span class="line"><span class="keyword">if</span>(iit!=eos) value2 = *iit;</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">istream_iterator</span></span><br><span class="line">: <span class="keyword">public</span> iterator&lt;input_iterator_tag, _Tp, _Dist, <span class="type">const</span> _Tp*, <span class="type">const</span> _Tp&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line">      istream_type*_M_stream;</span><br><span class="line">      _Tp_M_value;</span><br><span class="line">      <span class="comment">// 标记流读取结束</span></span><br><span class="line">      <span class="type">bool</span>_M_ok;</span><br><span class="line">      <span class="comment">// 构造时读取一个值</span></span><br><span class="line">      <span class="built_in">istream_iterator</span>(istream_type&amp; __s)</span><br><span class="line">          : _M_stream(std::__addressof(__s)), _M_ok(<span class="literal">true</span>)</span><br><span class="line">      &#123; _M_read(); &#125;</span><br><span class="line">      <span class="comment">// 自增时读取数据</span></span><br><span class="line">  istream_iterator&amp;  <span class="keyword">operator</span>++() &#123;</span><br><span class="line">_M_read();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">void</span> _M_read()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (_M_stream &amp;&amp; !(*_M_stream &gt;&gt; _M_value))</span><br><span class="line">          &#123;</span><br><span class="line">            _M_stream = <span class="number">0</span>;</span><br><span class="line">            _M_ok = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意: 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。</p><p>一个istream_iterator使用&gt;&gt;来读取流。因此,istream_iterator要读取的类型必须定义了输入运算符。<br>当创建一个istream_iterator时，我们可以将它绑定到一个流。<br>当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>;<span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; int_eof;<span class="comment">//尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>;<span class="comment">//打开一个aflie的文件</span></span><br><span class="line"><span class="function">istream_iterator&lt;string&gt; <span class="title">str_it</span><span class="params">(in)</span></span>;<span class="comment">//从&quot;afile&quot;读取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_iter</span><span class="params">(cin)</span></span>;<span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;<span class="comment">//istream尾后迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">while</span> (int_iter != eof)<span class="comment">//当有数据可供读取时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//后置递增运算符，返回迭代器的旧值</span></span><br><span class="line"><span class="comment">//解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(*int_iter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此循环从cin读取int值，保存在vec中.<br>在每个循环步中，循环体代码检查in_iter是否等于eof.<br>eof被定义为空的istream_iterator，从而可以当做尾后迭代器来使用.<br>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等<br>对于传递给push_back的参数，其中用到了解引用运算符和后置递增运算符。<br>后置递增运算会从流中读取下一个值，向前推进，但返回的迭代器时迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引用就能获得此值</p><p>注意： 后置递增运算会从流中读取下一个值</p><ul><li>我们可以将程序重写为如下形式，体现istream-<a href="https://so.csdn.net/so/search?q=iterator&spm=1001.2101.3001.7020">iterator</a>更有用的地方:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_iter</span><span class="params">(cin)</span>, eof</span>;<span class="comment">//从cin中读取int</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(int_iter,eof)</span></span>;<span class="comment">//从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure><ul><li><p>在本例中我们用一对表示元素范围的迭代器来构造vec。</p></li><li><p>这两个迭代器是istream_iterator,这意味着元素的范围是通过关联的流中读取数据获得的。</p></li><li><p><strong>这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据类型为止</strong>.</p></li><li><p>从流中读取的数据被用来构造vec。</p><p>istream_iterator可以使用懒惰求值</p></li></ul><p>当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。<br>具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。<br>标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。<br>对于大多数程序员来说，立即读取还是推迟读取没什么差别。但是，如果我们创建一个istream_iterator,没有使用就销毁了，或者我们正在从两个不同的对象同步读取一个流，那么何时读取可能就很重要了。</p><hr><h2 id="move-iterator移动迭代器用法详解-类似移动构造函数和move"><a href="#move-iterator移动迭代器用法详解-类似移动构造函数和move" class="headerlink" title="move_iterator移动迭代器用法详解(类似移动构造函数和move())"></a>move_iterator移动迭代器用法详解(类似移动构造函数和move())</h2><p> move_iterator 迭代器适配器，又可简称为移动迭代器，其可以实现以移动而非复制的方式，将某个区域空间中的元素移动至另一个指定的空间。</p><p><img src="/./STL%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-M5a2Q5bqn5pat54K5,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h3 id="1-move-iterator移动迭代器的创建"><a href="#1-move-iterator移动迭代器的创建" class="headerlink" title="1 move_iterator移动迭代器的创建"></a>1 move_iterator移动迭代器的创建</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将 vector 容器的随机访问迭代器作为新建移动迭代器底层使用的基础迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;string&gt;::iterator Iter;</span><br><span class="line"><span class="comment">//调用默认构造函数，创建移动迭代器</span></span><br><span class="line">move_iterator&lt;Iter&gt;mIter;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个 vector 容器</span></span><br><span class="line">vector&lt;string&gt; myvec&#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将 vector 容器的随机访问迭代器作为新建移动迭代器底层使用的基础迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;string&gt;::iterator Iter;</span><br><span class="line"><span class="comment">//创建并初始化移动迭代器</span></span><br><span class="line">move_iterator&lt;Iter&gt;<span class="built_in">mIter2</span>(myvec.<span class="built_in">begin</span>());</span><br><span class="line">move_iterator&lt;Iter&gt;<span class="built_in">mIter3</span>(mIter2);</span><br></pre></td></tr></table></figure><p>以上 3 种创建 move_iterator 迭代器的方式，其本质都是直接调用 move_iterator 模板类中的构造方法实现的。除此之外，C++ STL 标准库还提供了一个 make_move_iterator() 函数，通过调用此函数可以快速创建一个 move_iterator 迭代器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;string&gt;::iterator Iter;</span><br><span class="line">vector&lt;string&gt; myvec&#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//将 make_move_iterator() 的返回值赋值给同类型的 mIter 迭代器</span></span><br><span class="line">move_iterator&lt;Iter&gt;mIter = <span class="built_in">make_move_iterator</span>(myvec.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><hr><h3 id="2-move-iterator移动迭代器示例"><a href="#2-move-iterator移动迭代器示例" class="headerlink" title="2 move_iterator移动迭代器示例"></a>2 move_iterator移动迭代器示例</h3><p>vector 容器，该类型容器支持如下初始化的方式:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建并初始化一个 vector 容器</span></span><br><span class="line">vector&lt;string&gt; myvec&#123; <span class="string">&quot;QT&quot;</span>,<span class="string">&quot;MFC&quot;</span>,<span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//再次创建一个 vector 容器，利用 myvec 为其初始化</span></span><br><span class="line">vector&lt;string&gt;<span class="built_in">othvec</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 myvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;othvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 othvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : othvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    初始化 othvec 容器是通过复制 myvec 容器中的元素实现的。也就是说，othvec 容器从 myvec 容器中复制了一份 &quot;STL&quot;、&quot;Python&quot;、&quot;Java&quot; 并存储起来，此过程不会影响 myvec 容器。</code></pre><p>那么，如果不想采用复制的方式，而就是想 myvec 容器中存储的元素全部移动到 othvec 容器中，该怎么办呢？没错，就是采用移动迭代器。<br>运用移动迭代器为 othvec 容器初始化：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建并初始化一个 vector 容器</span></span><br><span class="line">vector&lt;string&gt; myvec&#123; <span class="string">&quot;QT&quot;</span>,<span class="string">&quot;MFC&quot;</span>,<span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//再次创建一个 vector 容器，利用 myvec 为其初始化</span></span><br><span class="line">vector&lt;string&gt;<span class="built_in">othvec</span>(<span class="built_in">make_move_iterator</span>(myvec.<span class="built_in">begin</span>()), <span class="built_in">make_move_iterator</span>(myvec.<span class="built_in">end</span>()));</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 myvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;othvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 othvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : othvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过和程序一做对比不难看出它们的区别， othvec 容器初始化时，使用的是移动迭代器，其会将 myvec 容器中的元素直接移动到 othvec 容器中。</p><p>注意，即便通过移动迭代器将容器中某区域的元素移动到了其他容器中，该区域内仍可能残留有之前存储的元素，但这些元素是不能再被使用的，否则极有可能使程序产生各种其他错误。</p><p>和其他迭代器适配器一样，move_iterator 模板类中也提供有 base() 成员方法，通过该方法，我们可以获取到当前移动迭代器底层所使用的基础迭代器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> vector&lt;string&gt;::iterator Iter;</span><br><span class="line"><span class="comment">//创建并初始化一个 vector 容器</span></span><br><span class="line">vector&lt;string&gt; myvec&#123; <span class="string">&quot;QT&quot;</span>,<span class="string">&quot;MFC&quot;</span>,<span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//创建 2 个移动迭代器</span></span><br><span class="line">move_iterator&lt;Iter&gt;begin = <span class="built_in">make_move_iterator</span>(myvec.<span class="built_in">begin</span>());</span><br><span class="line">move_iterator&lt;Iter&gt;end = <span class="built_in">make_move_iterator</span>(myvec.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//以复制的方式初始化 othvec 容器</span></span><br><span class="line">vector &lt;string&gt; <span class="built_in">othvec</span>(begin.<span class="built_in">base</span>(), end.<span class="built_in">base</span>());</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 myvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;othvec:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出 othvec 容器中的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : othvec) &#123;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 base() 成员方法，初始化 othvec 容器的方式转变为以复制而非移动的方式，因此 myvec 容器不会受到影响。 </p><h2 id="STL-advance-函数用法"><a href="#STL-advance-函数用法" class="headerlink" title="STL advance()函数用法"></a>STL advance()函数用法</h2><table><thead><tr><th>迭代器辅助函数</th><th>功能</th></tr></thead><tbody><tr><td>advance(it, n)</td><td>it 表示某个迭代器，n 为整数。该函数的功能是将 it 迭代器前进或后退 n 个位置。</td></tr><tr><td>distance(first, last)</td><td>first 和 last 都是迭代器，该函数的功能是计算 first 和 last 之间的距离。</td></tr><tr><td>begin(cont)</td><td>cont 表示某个容器，该函数可以返回一个指向 cont 容器中第一个元素的迭代器。</td></tr><tr><td>end(cont)</td><td>cont 表示某个容器，该函数可以返回一个指向 cont 容器中最后一个元素之后位置的迭代器。</td></tr><tr><td>prev(it)</td><td>it 为指定的迭代器，该函数默认可以返回一个指向上一个位置处的迭代器。注意，it 至少为双向迭代器。</td></tr><tr><td>next(it)</td><td>it 为指定的迭代器，该函数默认可以返回一个指向下一个位置处的迭代器。注意，it 最少为前向迭代器。</td></tr></tbody></table><p>本节先讲解 advance() 函数，其他函数后续章节会做详细介绍。</p><p>需要注意的是，如果 it 为输入迭代器或者前向迭代器，则 n 必须为一个正数，即表示将 it 右移（前进） n 个位置；反之，如果 it 为双向迭代器或者随机访问迭代器，则 n 为正数时表示将 it 右移（前进） n 个位置，n 为负数时表示将 it 左移（后退） n 个位置。</p><p>另外，根据 it 类型是否为随机访问迭代器，advance() 函数底层采用了不同的实现机制：</p><ul><li><p>当 it 为随机访问迭代器时，由于该类型迭代器支持 p+n 或者 p-n（其中 p 就是一个随机访问迭代器）运算，advance() 函数底层采用的就是 it+n 操作实现的；</p></li><li><p>当 it 为其他类型迭代器时，它们仅支持进行 ++ 或者 – 运算，这种情况下，advance() 函数底层是通过重复执行 n 个 ++ 或者 – 操作实现的。</p><p>首先以 forward_list 容器（仅支持使用前向迭代器）为例，下面程序演示了 advance() 函数的功能：</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::advance</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 forward_list 容器</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//it为前向迭代器，其指向 mylist 容器中第一个元素</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt;::iterator it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序中，由于 it 为前向迭代器，其只能进行 ++ 操作，即只能前进（右移），所以 advance() 函数的第 2 个参数只能为正数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::advance</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 vector 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//it为随机访问迭代器，其指向 myvector 容器中第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、*it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//继续使用it，其指向 myvector 容器中最后一个元素之后的位置</span></span><br><span class="line">    it = myvector.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//借助 advance() 函数将 it 迭代器后退 3 个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">-3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、*it = 3</span></span><br><span class="line"><span class="comment">2、*it = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>注意，advance() 函数本身不会检测 it 迭代器移动 n 个位置的可行性，如果 it 迭代器的移动位置超出了合理范围，it 迭代器的指向将无法保证，此时使用 *it 将会导致程序崩溃。</code></p><h2 id="distance-函数用法"><a href="#distance-函数用法" class="headerlink" title="distance()函数用法"></a>distance()函数用法</h2><p>distance() 函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">distance</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 都为迭代器，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回<code>[first, last)</code>范围内包含的元素的个数。</p><p>注意，first 和 last 的迭代器类型，直接决定了 distance() 函数底层的实现机制：</p><ul><li>当 first 和 last 为随机访问迭代器时，distance() 底层直接采用 last - first 求得 [first, last) 范围内包含元素的个数，其时间复杂度为<code>O(1)</code>常数阶；</li><li>当 first 和 last 为非随机访问迭代器时，distance() 底层通过不断执行 ++first（或者 first++）直到 first&#x3D;&#x3D;last，由此来获取 [first, last) 范围内包含元素的个数，其时间复杂度为<code>O(n)</code>线性阶。</li></ul><p>以 list 容器（其迭代器类型为双向迭代器）为例，演示了 distance() 函数的用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::distance</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 list 容器</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">    <span class="comment">//向空 list 容器中添加元素 0~9</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        mylist.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定 2 个双向迭代器，用于执行某个区间</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator first = mylist.<span class="built_in">begin</span>();<span class="comment">//指向元素 0</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator last = mylist.<span class="built_in">end</span>();<span class="comment">//指向元素 9 之后的位置</span></span><br><span class="line">    <span class="comment">//获取 [first,last) 范围内包含元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;distance() = &quot;</span> &lt;&lt; <span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="如何将const-iterator转换为iterator类型迭代器？"><a href="#如何将const-iterator转换为iterator类型迭代器？" class="headerlink" title="如何将const_iterator转换为iterator类型迭代器？"></a>如何将const_iterator转换为iterator类型迭代器？</h2><p>在 advance() 和 distance() 函数各自的功能和用法基础上，继续讲解如何利用这 2 个函数实现将 const_iterator 迭代器转换为 iterator 迭代器，或者将 const_reverse_iterator 迭代器转换为 reverse_iterator 迭代器。</p><p>要知道，C++ STL标准库为了方便用户更轻松地操作容器，每个容器的模板类都提供有丰富且实用的方法。在这些方法中，有些是以 const_iterator 类型迭代器作为参数，也就意味着在使用此类方法时，需要为其传入一个 const_iterator 类型的迭代器。</p><p>例如，vector 容器模板类中提供有 insert() 方法，该方法的语法格式如下：</p><p>iterator insert (const_iterator position, const value_type&amp; val);</p><p>实际上，当我们将某一类型的迭代器传递给 insert() 方法中 const_iterator 类型的 position 形参时，即便类型不匹配，编译器也不会立即报错，而是先尝试将其类型转换成 const_iterator 类型，如果转换成功，则程序仍可以正常执行；反之如果转换失败，编译器才会报错。<br><code>C++ 中，通常将编译器自行尝试进行类型转换的整个过程称为[隐式转换]（或者自动类型转换）。</code></p><p>对于 C++ STL 标准库中的这 4 种基础迭代器来说，C++ 编译器的隐式转换仅支持以下 2 种情况：</p><ol><li><p>将 iterator 类型的迭代器隐式转换为 const_iterator 类型的迭代器；</p></li><li><p>将 reverse_iterator 类型的迭代器隐式转换为 const_reverse_iterator 类型的迭代器。</p><p><code>注意，以上 2 种隐式转换是单向的，即编译器只支持从 iterator 转换为 const_iterator，从 reverse_iterator 转换为 const_reverse_iterator，但不支持逆向转换。</code></p></li></ol><p>可能会想到使用强制类型转换（const_cast）的方式。但可以明确的是，强制类型转换并不适用于迭代器，因为 const_cast 的功能仅是去掉某个类型的 const 修饰符，但 const_iterator 和iterator 是完全不同的 2 个类，同样 const_reverse_iterator 和 reverse_iterator 也是完全不同的 2 个类，它们仅仅是类名有 const 的差别，但并不是 const T 和 T 的关系。</p><p>使用 advance() 和 distance() </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将 const_iterator 转换为 iterator</span></span><br><span class="line"><span class="built_in">advance</span>(iter, distance&lt;cont&lt;T&gt;::const_iterator&gt;(iter,citer));</span><br><span class="line"><span class="comment">//将 const_reverse_iterator 转换为 reverse_iterator</span></span><br><span class="line"><span class="built_in">advance</span>(iter, distance&lt;cont&lt;T&gt;::const_reverse_iterator&gt;(iter,citer));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>其中，citer 为指向某个容器（比如 cont）任意位置的 const_iterator（或者 const_reverse_iterator）类型迭代器，而 iter 通常初始为指向 cont 容器中第一个元素的 iterator（或者 reverse_iterator）类型迭代器。通过套用此格式，最终 iter 会变成一个指向和 citer 一样的 iterator（或者 reverse_iterator）类型迭代器。</code></p><p>注意，在使用 distance() 函数时，必须额外指明 2 个参数为 const 迭代器类型，否则会因为传入的 iter 和 citer 类型不一致导致 distance() 函数编译出错。</p><p>该实现方式的本质是，先创建一个迭代器 citer，并将其初始化为指向容器中第一个元素的位置。在此基础上，通过计算和目标迭代器 iter 的距离（调用 distance()），将其移动至和 iter 同一个位置（调用 advance()），由此就可以间接得到一个指向同一位置的 iter 迭代器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;value&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//定义一个 const_iterator 类型的迭代器，其指向最后一个元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator citer = --value.<span class="built_in">cend</span>();</span><br><span class="line"><span class="comment">//初始化一个非 const 迭代器，另其指向</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = value.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//将 iter 变成和 citer 同样指向的迭代器</span></span><br><span class="line"><span class="built_in">advance</span>(iter, distance&lt;vector&lt;<span class="type">int</span>&gt;::const_iterator&gt;(iter, citer));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*citer = &quot;</span> &lt;&lt; *citer &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h2 id="begin-和end-函数用法"><a href="#begin-和end-函数用法" class="headerlink" title="begin()和end()函数用法"></a>begin()和end()函数用法</h2><p>无论是序列式容器还是关联式容器（包括哈希容器），不仅模板类内部提供有 begin() 和 end() 成员方法，C++ STL 标准库中还提供有同名且具有相同功能的 begin() 和 end() 函数。</p><p>首先需要说明的是，begin() 和 end() 是以函数模板的形式定义的，但它们的模板并没有位于某一个头文件中，而是很多头文件中都有它们的定义。</p><blockquote><p>C++ STL 标准库中，包含 begin() 和 end() 函数模板的头文件包括：<iterator>, <array>, <deque>, <forward_list>, <list>, <map>, <regex>（正则表达式的头文件）, <set>, <string>, <unordered_map>, <unordered_set> 以及 <vector>。</vector></unordered_set></unordered_map></string></set></regex></map></list></forward_list></deque></array></iterator></p></blockquote><p>不仅如此，begin() 和 end() 都位于 std 命名空间中。因此，在使用这 2 个函数之前，程序中应引入容纳它们函数模板的头文件以及 std 命名空间。</p><p>在实际的使用场景中，begin() 和 end() 函数往往会一起使用的。根据作用对象的不同，begin() 和 end() 函数可细分为以下 2 个功能。</p><h3 id="1-begin-和end-参数为容器"><a href="#1-begin-和end-参数为容器" class="headerlink" title="1 begin()和end()参数为容器"></a>1 begin()和end()参数为容器</h3><p>当将某个具体容器（比如 cont）作为参数分别传给 begin() 和 end() 函数时，其中 begin() 底层会执行 cont.begin() 语句，而 end() 底层会执行 cont.end() 语句，它们最终会将得到的迭代器作为函数的返回值反馈回来。</p><p>当作用对象为容器时，end() 和 begin() 函数的语法格式是完全一样的，这里以 begin() 函数为例，有以下 2 种格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//① 非 const 修改的容器作为参数，begin() 函数返回的为非 const 类型的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">begin</span> <span class="params">(Container&amp; cont)</span></span></span><br><span class="line"><span class="function"><span class="comment">//② 传入 const 修饰的容器，begin() 函数返回的为 const 类型的迭代器</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Container&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">begin</span> <span class="params">(<span class="type">const</span> Container&amp; cont)</span></span></span><br></pre></td></tr></table></figure><p>其中，cont 表示指定的容器；同时，函数会返回一个有特定指向的迭代器，且此迭代器的类型也取决于 cont 容器。</p><blockquote><p>以上 2 种格式的区别仅在与传入的容器是否有 const 修饰，即如果有，则通过该函数获得的迭代器也有 const 修饰（不能用于修改容器中存储的数据）；反之就没有。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector, std::begin, std::end</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//调用 begin() 和 end() 函数遍历 myvector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">begin</span>(myvector); it != <span class="built_in">end</span>(myvector); ++it)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-begin-和end-参数为数组"><a href="#2-begin-和end-参数为数组" class="headerlink" title="2 begin()和end()参数为数组"></a>2 begin()和end()参数为数组</h3><p>除了可以将指定容器作为参数传给 begin() 和 end() 之外，还可以指定数组作为参数传给它们。</p><p>将指定数组传给 begin() 函数，其会返回一个指向该数组首个元素的指针；将指定数组传给 end() 函数，其会返回一个指向数组中最后一个元素之后位置的指针。</p><p>同样，数组作为参数时，end() 函数的语法格式和 begin() 函数也完全一样，这里仅给出了 begin() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector, std::begin, std::end</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个普通数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 vector 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector;</span><br><span class="line">    <span class="comment">//将数组中的元素添加到 myvector 容器中存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *it = <span class="built_in">begin</span>(arr); it != <span class="built_in">end</span>(arr); ++it)</span><br><span class="line">        myvector.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    <span class="comment">//输出 myvector 容器中存储的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="prev-和next-函数用法详解"><a href="#prev-和next-函数用法详解" class="headerlink" title="prev()和next()函数用法详解"></a>prev()和next()函数用法详解</h2><p>advance() 函数的功能，其可以将指定迭代器前移或后移 n 个位置的距离。</p><p>但值得一提的是，advance() 函数移动的是源迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::advance</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 vector 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">//it为随机访问迭代器，其指向 myvector 容器中第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//输出 it 迭代器指向的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动前的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 advance() 函数将 it 迭代器前进 2 个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动后的 *it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序执行结果为：</span></span><br><span class="line">移动前的 *it = <span class="number">1</span></span><br><span class="line">移动后的 *it = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过程序的运行结果不难看出，advance() 函数没有任何返回值，其移动的是 it 迭代器本身。</p><p>这就产生一个问题，若我们不想移动 it 迭代器本身，而仅仅是想在 it 迭代器的基础上，得到一个移动指定位置的新迭代器，显然 advance() 函数是不合适的，这时就可以使用 C++ STL 标准库提供的另外 2 个函数，即 prev() 和 next() 函数。</p><h3 id="STL-prev-函数"><a href="#STL-prev-函数" class="headerlink" title="STL prev()函数"></a>STL prev()函数</h3><p>其中，it 为源迭代器，其类型只能为双向迭代器或者随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。</p><blockquote><p>注意，当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::next</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 list 容器</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt;::iterator it = mylist.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span></span><br><span class="line">    <span class="keyword">auto</span> newit = <span class="built_in">prev</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//n为负数，newit 位于 it 右侧</span></span><br><span class="line">    it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    newit = <span class="built_in">prev</span>(it, <span class="number">-2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序执行结果为：</span></span><br><span class="line"><span class="comment">prev(it, 2) = 4</span></span><br><span class="line"><span class="comment">prev(it, -2) = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，当 it 指向 mylist 容器最后一个元素之后的位置时，通过 prev(it, 2) 可以获得一个新迭代器 newit，其指向的是距离 it 左侧 2 个元素的位置（其存储的是元素 4）；当 it 指向 mylist 容器中首个元素时，通过 prev(it, -2) 可以获得一个指向距离 it 右侧 2 个位置处的新迭代器。</p><blockquote><p>注意，prev() 函数自身不会检验新迭代器的指向是否合理，需要我们自己来保证其合理性。</p></blockquote><h3 id="STL-next-函数"><a href="#STL-next-函数" class="headerlink" title="STL next()函数"></a>STL next()函数</h3><p>和 prev 相反，next 原意为“下一个”，但其功能和 prev() 函数类似，即用来获取一个距离指定迭代器 n 个元素的迭代器。</p><p>其中 it 为源迭代器，其类似可以为前向迭代器、双向迭代器以及随机访问迭代器；n 为指定新迭代器距离 it 的距离，默认值为 1。该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。</p><blockquote><p>需要注意的是，当 it 为前向迭代器时，n 只能为正数，该函数最终得到的新迭代器位于 it 右侧；当 it 为双向迭代器或者随机访问迭代器时，若 n 为正数，则得到的新迭代器位于 it 右侧，反之位于 it 左侧。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>     <span class="comment">// std::next</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 list 容器</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt;::iterator it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 右侧</span></span><br><span class="line">    <span class="keyword">auto</span> newit = <span class="built_in">next</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;next(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//n为负数，newit 位于 it 左侧</span></span><br><span class="line">    it = mylist.<span class="built_in">end</span>();</span><br><span class="line">    newit = <span class="built_in">next</span>(it, <span class="number">-2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;next(it, -2) = &quot;</span> &lt;&lt; *newit;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tiny Web Server学习笔记</title>
      <link href="/2024/09/26/TinyWebServer_day1/"/>
      <url>/2024/09/26/TinyWebServer_day1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="1-什么是Web-Server（网络服务器）"><a href="#1-什么是Web-Server（网络服务器）" class="headerlink" title="1. 什么是Web Server（网络服务器）"></a>1. 什么是Web Server（网络服务器）</h1><p>一个Web Server就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过HTTP协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容（文件、网页等）或返回一个Error信息。</p><p><img src="https://raw.githubusercontent.com/Huixxi/Algorithm-with-Cplusplus/master/AlgorithmImages/web-server.svg" alt="img"></p><h1 id="2-用户如何与你的Web服务器进行通信"><a href="#2-用户如何与你的Web服务器进行通信" class="headerlink" title="2. 用户如何与你的Web服务器进行通信"></a>2. 用户如何与你的Web服务器进行通信</h1><p>浏览器中键入<strong>“域名”或“IP地址:端口号”</strong>，浏览器则先将你的域名解析成相应的IP地址或者直接根据你的IP地址向对应的Web服务器发送一个HTTP请求。这一过程首先要通过TCP协议的<strong>三次握手建立与目标Web服务器的连接</strong>，然后<strong>HTTP协议</strong>生成针对目标Web服务器的<strong>HTTP请求报文，通过TCP、IP等协议发送到目标Web服务器上。</strong></p><h1 id="3-Web服务器如何接收客户端发来的HTTP请求报文呢"><a href="#3-Web服务器如何接收客户端发来的HTTP请求报文呢" class="headerlink" title="3. Web服务器如何接收客户端发来的HTTP请求报文呢?"></a>3. Web服务器如何接收客户端发来的HTTP请求报文呢?</h1><p>Web服务器端通过**<code>socket</code>**监听来自用户的请求。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 创建监听socket文件描述符 */</span></span><br><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 创建监听socket的TCP/IP的IPV4 socket地址 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">/* INADDR_ANY：将套接字绑定到所有可用的接口 */</span></span><br><span class="line">address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* SO_REUSEADDR 允许端口被重复使用 */</span></span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="comment">/* 绑定socket和它的地址 */</span></span><br><span class="line">ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));  </span><br><span class="line"><span class="comment">/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */</span></span><br><span class="line">ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这段代码是用于在 Linux 环境下创建一个 TCP 服务器的基本步骤。下面是对代码中的主要操作进行解释：</p><ol><li><code>socket(PF_INET, SOCK_STREAM, 0)</code>：<ul><li>通过调用 <code>socket</code> 函数创建一个套接字描述符 <code>listenfd</code>，用于监听客户端连接请求。</li><li><code>PF_INET</code> 表示使用 IPv4 协议族，<code>SOCK_STREAM</code> 表示创建一个基于 TCP 的流式套接字。</li><li>最后一个参数通常为 0，表示使用默认的协议。</li></ul></li><li><code>struct sockaddr_in address;</code>：<ul><li>创建一个 IPv4 的 socket 地址结构体 <code>address</code>，用于存储服务器的 IP 地址和端口号。</li></ul></li><li><code>bzero(&amp;address, sizeof(address));</code>：<ul><li>使用 <code>bzero</code> 函数将 <code>address</code> 结构体清零，确保其中的所有字段都被初始化为 0。</li></ul></li><li><code>address.sin_family = AF_INET;</code>：<ul><li>设置地址族为 IPv4。</li></ul></li><li><code>address.sin_addr.s_addr = htonl(INADDR_ANY);</code>：<ul><li>将服务器 IP 地址设置为 <code>INADDR_ANY</code>，表示服务器将监听所有网络接口上的连接请求。</li></ul></li><li><code>address.sin_port = htons(port);</code>：<ul><li>设置服务器端口号为变量 <code>port</code> 所指定的值，并将其转换为网络字节序（大端序）。</li></ul></li><li><code>int flag = 1;</code>：<ul><li>创建一个整型变量 <code>flag</code>，并将其值设为 1，用于设置套接字选项。</li></ul></li><li><code>setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));</code>：<ul><li>调用 <code>setsockopt</code> 函数设置 <code>listenfd</code> 套接字的选项。</li><li><code>SO_REUSEADDR</code> 允许地址重用，即在服务器绑定地址时允许重复使用已被占用的地址和端口。</li></ul></li><li><code>ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));</code>：<ul><li>将创建的套接字 <code>listenfd</code> 绑定到指定的 IP 地址和端口上。</li><li><code>bind</code> 函数用于将套接字和套接字地址结构绑定在一起。</li></ul></li><li><code>ret = listen(listenfd, 5);</code>：<ul><li>将套接字设置为监听状态，允许最多同时有 5 个客户端连接等待被接受（这是一个经验值）。</li></ul></li></ol><p>远端的很多用户会尝试去<code>connect()</code>这个Web Server上正在<code>listen</code>的这个<code>port</code>，而监听到的这些连接会排队等待被<code>accept()</code>。</p><p>由于用户连接请求是随机到达的异步事件，每当监听socket（<code>listenfd</code>）<code>listen</code>到新的客户连接并且放入监听队列，我们都需要告诉我们的Web服务器有连接来了，<code>accept</code>这个连接，并分配一个逻辑单元来处理这个用户请求。而且，我们在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发，同时处理多个事件，后面会提到使用线程池实现并发）。</p><p>这里，服务器通过<strong>epoll</strong>这种I&#x2F;O复用技术（还有select和poll）来实现对监听socket（<code>listenfd</code>）和连接socket（客户请求）的同时监听。<strong>注意I&#x2F;O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符</strong>，所以为提高效率，将在这部分通过<strong>线程池来实现并发（多线程并发）</strong>，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件中 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="comment">/* 针对connfd，开启EPOLLONESHOT，因为我们希望每个socket在任意时刻都只被一个线程处理 */</span></span><br><span class="line">    <span class="keyword">if</span>(one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建一个额外的文件描述符来唯一标识内核中的epoll事件表 */</span></span><br><span class="line"><span class="type">int</span> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);  </span><br><span class="line"><span class="comment">/* 创建一个 epoll 实例，并返回一个文件描述符 epollfd，用于唯一标识内核中的 epoll 事件表。参数 5 表示这个 epoll 实例的大小为 5，这个大小并不是硬性要求，只是一个初始大小的建议值。*/</span></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];  </span><br><span class="line"><span class="comment">/* 用于存储从内核中获取的就绪事件的 epoll_event 结构数组。MAX_EVENT_NUMBER 是一个常量，表示最大事件数量。 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">false</span>);  </span><br><span class="line"><span class="comment">/* 将监听套接字 listenfd 上的事件注册到 epoll 内核事件表中。</span></span><br><span class="line"><span class="comment">如果 one_shot 参数为 true，则开启 EPOLLONESHOT 选项，表示每个套接字在任意时刻只会被一个线程处理。 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/* 调用 epoll_wait 函数等待一组文件描述符上的事件，并将当前所有就绪的 epoll_event 复制到 events 数组中。函数阻塞直到有事件发生或者超时。 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = events[i].data.fd;  <span class="comment">// 事件表中就绪的socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd == listenfd) &#123;  <span class="comment">// 当listen到新的用户连接，listenfd上则产生就绪事件</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">        <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">        <span class="comment">/* ET模式 */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* accept()返回一个新的socket文件描述符用于send()和recv() */</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="comment">/* 并将connfd注册到内核事件表中 */</span></span><br><span class="line">            users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">        <span class="comment">// 如有异常，则直接关闭客户连接，并删除该用户的timer</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">/* 当这一sockfd上有可读事件时，epoll_wait通知主线程。*/</span></span><br><span class="line">        <span class="keyword">if</span>(users[sockfd].<span class="built_in">read</span>()) &#123; <span class="comment">/* 主线程从这一sockfd循环读取数据, 直到没有更多数据可读 */</span></span><br><span class="line">            pool-&gt;<span class="built_in">append</span>(users + sockfd);  <span class="comment">/* 然后将读取到的数据封装成一个请求对象并插入请求队列 */</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="comment">/* 当这一sockfd上有可写事件时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果 */</span></span><br><span class="line">        <span class="keyword">if</span>(users[sockfd].<span class="built_in">write</span>()) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器程序通常需要处理三类事件：I&#x2F;O事件，信号及定时事件。有两种事件处理模式：</p><ul><li>Reactor模式：要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。</li><li>Proactor模式：将所有的I&#x2F;O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后<code>users[sockfd].read()</code>，选择一个工作线程来处理客户请求<code>pool-&gt;append(users + sockfd)</code>。</li></ul><p>通常使用同步I&#x2F;O模型（如<code>epoll_wait</code>）实现Reactor，使用异步I&#x2F;O（如<code>aio_read</code>和<code>aio_write</code>）实现Proactor。但在此项目中，我们使用的是<strong>同步I&#x2F;O模拟的Proactor</strong>事件处理模式。那么什么是同步I&#x2F;O，什么是异步I&#x2F;O呢？</p><p>同步（阻塞）I&#x2F;O：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p><p>异步（非阻塞）I&#x2F;O：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p><h1 id="对lock锁封装"><a href="#对lock锁封装" class="headerlink" title="对lock锁封装"></a>对lock锁封装</h1><blockquote><p><strong>头文件</strong></p><p>#include <exception><br>#include &lt;semaphore.h&gt;<br>#include<thread><br>#include<condition_variable><br>#include<mutex></mutex></condition_variable></thread></exception></p></blockquote><p><strong>封装信号量的使用</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">sem</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sem</span>(<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">sem</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>封装互斥锁</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">locker</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">locker</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_mutex.~<span class="built_in">mutex</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::mutex* <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>条件变量封装</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">cond</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_condition.<span class="built_in">wait</span>(lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">timewait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, <span class="type">const</span> std::chrono::milliseconds&amp; duration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_condition.<span class="built_in">wait_for</span>(lock, duration) == std::cv_status::no_timeout;<span class="comment">//判断是否超时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_condition.<span class="built_in">notify_one</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_condition.<span class="built_in">notify_all</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::condition_variable m_condition;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="同步-异步日志系统"><a href="#同步-异步日志系统" class="headerlink" title="同步&#x2F;异步日志系统"></a>同步&#x2F;异步日志系统</h1><p>同步&#x2F;异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备.</p><blockquote><ul><li>自定义阻塞队列</li><li>单例模式创建日志</li><li>同步日志</li><li>异步日志</li><li>实现按天、超行分类</li></ul></blockquote><p><strong>头文件</strong></p><blockquote><p>#include <iostream><br>#include &lt;stdlib.h&gt;<br>#include <thread><br>#include &lt;sys&#x2F;time.h&gt;<br>#include”lock.h”</thread></iostream></p></blockquote><h2 id="自定义阻塞队列模块"><a href="#自定义阻塞队列模块" class="headerlink" title="自定义阻塞队列模块"></a><strong>自定义阻塞队列模块</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block_queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="type">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m_max_size = max_size;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        m_array.<span class="built_in">clear</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否满了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">size</span>() &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_array.<span class="built_in">empty</span>();</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">front</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array.<span class="built_in">front</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">back</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array.<span class="built_in">back</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往队列添加元素，需要将所有使用队列的线程先唤醒</span></span><br><span class="line">   <span class="comment">//当有元素push进队列,相当于生产者生产了一个元素</span></span><br><span class="line">   <span class="comment">//若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">size</span>() &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_array.<span class="built_in">push_back</span>(item);</span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒所有等待进程是因为已经阻塞了，尽可能的全部处理，提高处理效率</span></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">while</span> (m_array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        item = m_array.<span class="built_in">front</span>();</span><br><span class="line">        m_array.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了超时处理</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> ms_timeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;</span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t))</span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_array.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = m_array.<span class="built_in">front</span>();</span><br><span class="line">        m_array.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_array.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_max_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex;</span><br><span class="line">    cond m_cond;</span><br><span class="line"></span><br><span class="line">    deque&lt;T&gt; m_array;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">    <span class="type">int</span> m_max_size;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><blockquote><p>#include &lt;stdio.h&gt;<br>#include <iostream><br>#include <string><br>#include &lt;stdarg.h&gt;&#x2F;&#x2F;支持可变参数变量<br>#include <thread><br>#include “block_queue.h”</thread></string></iostream></p></blockquote><p><strong>log.h</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">flush_log_thread</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size = <span class="number">8192</span>, <span class="type">int</span> split_lines = <span class="number">5000000</span>, <span class="type">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">async_write_log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line">        <span class="comment">//从阻塞队列中取出一个日志string，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> dir_name[<span class="number">128</span>]; <span class="comment">//路径名</span></span><br><span class="line">    <span class="type">char</span> log_name[<span class="number">128</span>]; <span class="comment">//log文件名</span></span><br><span class="line">    <span class="type">int</span> m_split_lines;  <span class="comment">//日志最大行数</span></span><br><span class="line">    <span class="type">int</span> m_log_buf_size; <span class="comment">//日志缓冲区大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_count;  <span class="comment">//日志行数记录</span></span><br><span class="line">    <span class="type">int</span> m_today;        <span class="comment">//因为按天分类,记录当前时间是那一天</span></span><br><span class="line">    FILE* m_fp;         <span class="comment">//打开log的文件指针</span></span><br><span class="line">    <span class="type">char</span>* m_buf;</span><br><span class="line">    block_queue&lt;string&gt;* m_log_queue; <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="type">bool</span> m_is_async;                  <span class="comment">//是否同步标志位</span></span><br><span class="line">    locker m_mutex;</span><br><span class="line">    <span class="type">int</span> m_close_log; <span class="comment">//关闭日志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br></pre></td></tr></table></figure><p><strong>log.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_count = <span class="number">0</span>;</span><br><span class="line">    m_is_async = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Log::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size, <span class="type">int</span> split_lines, <span class="type">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果设置了max_queue_size,则设置为异步</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;</span><br><span class="line">        m_log_queue = <span class="keyword">new</span> <span class="built_in">block_queue</span>&lt;string&gt;(max_queue_size);</span><br><span class="line">        <span class="comment">//flush_log_thread为回调函数,这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="function">thread <span class="title">tid</span><span class="params">(flush_log_thread)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_log_buf_size = log_buf_size;</span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="type">char</span>[m_log_buf_size];</span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);</span><br><span class="line">    m_split_lines = split_lines;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);<span class="comment">/*strrchr 函数用于在字符串 file_name 中查找最后一次出现字符 &#x27;/&#x27; 的位置，</span></span><br><span class="line"><span class="comment">    并返回该位置的指针。如果找到了该字符，则返回该字符及其后面的子串；如果未找到，则返回 NULL。*/</span></span><br><span class="line">    <span class="type">char</span> log_full_name[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);</span><br><span class="line">        <span class="comment">/*假设现在是 2024 年 4 月 12 日，file_name 的值是 &quot;example.log&quot;，那么经过 snprintf 格式化后的 log_full_name 可能会是 &quot;2024_04_12_example.log&quot;。*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_today = my_tm.tm_mday;</span><br><span class="line"></span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">time_t</span> t = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (level)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入一个log，对m_count++, m_split_lines最大行数</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    m_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) <span class="comment">//everyday log</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> new_log[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);</span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;</span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);</span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入的具体时间内容格式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">        my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">        my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - n - <span class="number">1</span>, format, valst);</span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    log_str = m_buf;</span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//强制刷新写入流缓冲区</span></span><br><span class="line">    <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="校验-数据库连接池"><a href="#校验-数据库连接池" class="headerlink" title="校验 &amp; 数据库连接池"></a>校验 &amp; 数据库连接池</h1><p>数据库连接池</p><blockquote><ul><li>单例模式，保证唯一</li><li>list实现连接池</li><li>连接池为静态大小</li><li>互斥锁实现线程安全</li></ul></blockquote><p>校验</p><blockquote><ul><li>HTTP请求采用POST方式</li><li>登录用户名和密码校验</li><li>用户注册及多线程注册安全</li></ul></blockquote><p><strong>头文件</strong></p><blockquote><p>#include &lt;stdio.h&gt;<br>#include <list><br>#include &lt;mysql&#x2F;mysql.h&gt;<br>#include &lt;error.h&gt;<br>#include &lt;string.h&gt;<br>#include <iostream><br>#include <string><br>#include”lock.h”<br>#include”log.h”</string></iostream></list></p></blockquote><p><strong>函数声明</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connect_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">MYSQL * <span class="title">GetConnection</span><span class="params">()</span></span>;<span class="comment">//获取数据库连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReleaseConnect</span><span class="params">(MYSQL* conn)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="function"><span class="type">static</span> connect_pool* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">connect_pool</span>();</span><br><span class="line">~<span class="built_in">connect_pool</span>();</span><br><span class="line"><span class="type">int</span> m_MaxConn;<span class="comment">//最大连接数</span></span><br><span class="line"><span class="type">int</span> m_CurConn;<span class="comment">//当前已使用的连接数</span></span><br><span class="line"><span class="type">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">locker lock;</span><br><span class="line">list&lt;MYSQL*&gt;connList;<span class="comment">//连接池</span></span><br><span class="line">sem reserve;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_url;<span class="comment">//主机地址</span></span><br><span class="line">string m_Port;<span class="comment">//数据库端口号</span></span><br><span class="line">string m_User;<span class="comment">//登录数据库的用户名</span></span><br><span class="line">string m_PassWord;<span class="comment">//登录数据库密码</span></span><br><span class="line">string m_DatabaseName;<span class="comment">//使用数据库名</span></span><br><span class="line"><span class="type">int</span> m_close_log;<span class="comment">//日志开关</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connectionRAII</span> &#123;<span class="comment">//实例化对象并控制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">connectionRAII</span>(MYSQL** con, connect_pool* connPool);</span><br><span class="line">~<span class="built_in">connectionRAII</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MYSQL* conRAII;</span><br><span class="line">connect_pool* poolRAII;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>函数实现</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sql_connectpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">connect_pool::<span class="built_in">connect_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_CurConn = <span class="number">0</span>;</span><br><span class="line">m_FreeConn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connect_pool* <span class="title">connect_pool::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> connect_pool connPool;</span><br><span class="line"><span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_url = url;</span><br><span class="line">m_Port = Port;</span><br><span class="line">m_User = User;</span><br><span class="line">m_PassWord = PassWord;</span><br><span class="line">m_DatabaseName = DBName;</span><br><span class="line">m_close_log = close_log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">&#123;</span><br><span class="line">MYSQL* con = <span class="literal">NULL</span>;</span><br><span class="line">con = <span class="built_in">mysql_init</span>(con);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">++m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reserve = <span class="built_in">sem</span>(m_FreeConn);</span><br><span class="line"></span><br><span class="line">m_MaxConn = m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">connect_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MYSQL* con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">reserve.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">con = connList.<span class="built_in">front</span>();</span><br><span class="line">connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">--m_FreeConn;</span><br><span class="line">++m_CurConn;</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect_pool::ReleaseConnect</span><span class="params">(MYSQL* con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">++m_FreeConn;</span><br><span class="line">--m_CurConn;</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">reserve.<span class="built_in">post</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">list&lt;MYSQL*&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">MYSQL* con = *it;</span><br><span class="line"><span class="built_in">mysql_close</span>(con);</span><br><span class="line">&#125;</span><br><span class="line">m_CurConn = <span class="number">0</span>;</span><br><span class="line">m_FreeConn = <span class="number">0</span>;</span><br><span class="line">connList.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前空闲的连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_pool::GetFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect_pool::~<span class="built_in">connect_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DestroyPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL** SQL, connect_pool* connPool) &#123;</span><br><span class="line">*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line"></span><br><span class="line">conRAII = *SQL;</span><br><span class="line">poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>() &#123;</span><br><span class="line">poolRAII-&gt;<span class="built_in">ReleaseConnect</span>(conRAII);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定时器处理非活动连接"><a href="#定时器处理非活动连接" class="headerlink" title="定时器处理非活动连接"></a>定时器处理非活动连接</h1><p>由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.</p><blockquote><ul><li>统一事件源</li><li>基于升序链表的定时器</li><li>处理非活动连接</li></ul></blockquote><h1 id="http连接处理类"><a href="#http连接处理类" class="headerlink" title="http连接处理类"></a>http连接处理类</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2024/09/26/stl/"/>
      <url>/2024/09/26/stl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a>STL基础</h1><h2 id="C-STL是什么，有什么用？"><a href="#C-STL是什么，有什么用？" class="headerlink" title="C++ STL是什么，有什么用？"></a>C++ STL是什么，有什么用？</h2><p>在已有 <a href="https://c.biancheng.net/cplus/">C++</a> 尤其是 C++ 模板的基础上，从本节开始，我们开始系统地学习 <a href="https://c.biancheng.net/stl/">STL</a> 标准模板库，首先来了解什么是 STL，以及学习 STL 有什么用？</p><p>STL，英文全称 s<a href="https://c.biancheng.net/ref/tan.html">tan</a>dard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p><code>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</code></p><p>根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和<a href="https://c.biancheng.net/data_structure/">数据结构</a>的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><h2 id="C-STL要学哪些知识"><a href="#C-STL要学哪些知识" class="headerlink" title="C++STL要学哪些知识"></a>C++STL要学哪些知识</h2><p>&#x3D;&#x3D;<strong>C++ STL基本组成（6大组件+13个头文件）</strong>&#x3D;&#x3D;</p><table><thead><tr><th>STL的组成</th><th>含义</th></tr></thead><tbody><tr><td>容器</td><td>一些封装<a href="https://c.biancheng.net/data_structure/">数据结构</a>的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td>算法</td><td>STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。</numeric></algorithm></td></tr><tr><td>迭代器</td><td>在 <a href="https://c.biancheng.net/cplus/">C++</a> STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td>函数对象</td><td>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td>适配器</td><td>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td>内存分配器</td><td>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>在 C++ 标准中，它们被重新组织为 13 个头文件，如表 2 所示。</p><p><img src="/../typora-user-images/13head.png" alt="image-20240318220604552"></p><p>按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 &lt;vector.h&gt; 为有扩展名的形式。</vector></p><p>但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件（例如 Visual C++ 支持的 Dinkumware 版本同时具备 &lt;vector.h&gt; 和 <vector>）；甚至有些 STL 版本同时拥有 3 种形式的头文件（例如 SGI 版本同时拥有 <vector>、&lt;vector.h&gt; 和 &lt;stl_vector.h&gt;）；但也有个别的 STL 版本只存在包含扩展名的头文件（例如 C++ Builder 的 RaugeWare 版本只有 &lt;vector.h&gt;）</vector></vector></p><h1 id="STL序列式容器"><a href="#STL序列式容器" class="headerlink" title="STL序列式容器"></a>STL序列式容器</h1><h2 id="C-STL容器是什么？"><a href="#C-STL容器是什么？" class="headerlink" title="C++ STL容器是什么？"></a>C++ STL容器是什么？</h2><p>&#x3D;&#x3D;简单的理解容器，它就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。&#x3D;&#x3D;STL 提供有 3 类标准容器，分别是<strong>序列容器、排序容器和哈希容器</strong>，其中后两类容器有时也统称为&#x3D;&#x3D;关联容器&#x3D;&#x3D;。</p><p>它们各自的含义如表 1 所示。</p><table><thead><tr><th>容器种类</th><th>功能</th></tr></thead><tbody><tr><td>序列容器</td><td>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</td></tr><tr><td>排序容器</td><td>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。</td></tr><tr><td>哈希容器</td><td><a href="https://c.biancheng.net/cplus/">C++</a> 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</td></tr></tbody></table><h2 id="迭代器是什么，C-STL迭代器（iterator）用法详解"><a href="#迭代器是什么，C-STL迭代器（iterator）用法详解" class="headerlink" title="迭代器是什么，C++ STL迭代器（iterator）用法详解"></a>迭代器是什么，C++ STL迭代器（iterator）用法详解</h2><p>无论是序列容器还是关联容器，最常做的操作无疑是遍历容器中存储的元素，而实现此操作，多数情况会选用“迭代器（iterator）”来实现。那么，迭代器到底是什么呢？</p><p>我们知道，尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。</p><p>既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。</p><p>这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 <a href="https://c.biancheng.net/cplus/">C++</a> 的<a href="https://c.biancheng.net/c/80/">指针</a>非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读&#x2F;写操作。</p><h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><p><a href="https://c.biancheng.net/stl/">STL</a> 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。</p><p><code>容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</code></p><p>常用的迭代器按功能强弱分为**输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 **5 种。本节主要介绍后面的这 3 种迭代器</p><p><code>输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。有关这 2 个迭代器，我们会在后续章节做详细介绍。</code></p><ol><li><p>前向迭代器（forward iterator）<br>假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p></li><li><p>双向迭代器（bidirectional iterator）<br>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p></li><li><p>随机访问迭代器（random access iterator）<br>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p></li></ol><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>C++ 11 标准中不同容器指定使用的迭代器类型。<br>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set &#x2F; multiset</td><td>双向迭代器</td></tr><tr><td>map &#x2F; multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map &#x2F; unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set &#x2F; unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><h3 id="迭代器的定义方式"><a href="#迭代器的定义方式" class="headerlink" title="迭代器的定义方式"></a>迭代器的定义方式</h3><p>尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，具体分为 4 种，如表 1 所示。</p><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator 迭代器名;</td></tr></tbody></table><p>通过定义以上几种迭代器，就可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li></ul><p>注意，&#x3D;&#x3D;以上 4 种定义迭代器的方式，并不是每个容器都适用&#x3D;&#x3D;。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器。</p><p>vector 支持随机访问迭代器，因此遍历 vector 容器有以下几种做法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历 vector 容器。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 vector 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="comment">//创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第二种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第三种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   </span><br><span class="line">       cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第四种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第二种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第三种遍历方法：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"><span class="comment">第四种遍历方法：</span></span><br><span class="line"><span class="comment">1 3 5 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><p>以下代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下代码则不合法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; *i;</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用“&lt;”进行比较</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    cout &lt;&lt; v[i];</span><br><span class="line"><span class="comment">//因为双向迭代器不支持用下标随机访问元素：</span></span><br></pre></td></tr></table></figure><h2 id="C-序列式容器（STL序列式容器）是什么"><a href="#C-序列式容器（STL序列式容器）是什么" class="headerlink" title="C++序列式容器（STL序列式容器）是什么"></a>C++序列式容器（STL序列式容器）是什么</h2><p>所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型（例如 int、double 等）的数据，需要特殊说明的是，该类容器并不会自动对存储的元素按照值的大小进行排序。</p><p>需要注意的是，序列容器只是一类容器的统称，并不指具体的某个容器，序列容器大致包含以下几类容器：</p><ul><li>**array&lt;T,N&gt;**（数组容器）：表示可以存储 N 个 T 类型的元素，是 <a href="https://c.biancheng.net/cplus/">C++</a> 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li><strong>vector<T>（向量容器）</T></strong>：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li><strong>deque<T>（双端队列容器）</T></strong>：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li><strong>list<T>（链表容器）</T></strong>：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</T></li><li>**forward_list<T>**（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</T></li></ul><p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911110REB.jpg" alt="img"></p><h3 id="容器中常见的函数成员"><a href="#容器中常见的函数成员" class="headerlink" title="容器中常见的函数成员"></a>容器中常见的函数成员</h3><table><thead><tr><th>函数成员</th><th>函数功能</th><th>array&lt;T,N&gt;</th><th>vector<T></T></th><th>deque<T></T></th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>operator&#x3D;()</td><td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>size()</td><td>返回实际元素个数。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>capacity()</td><td>返回当前容量。</td><td>-</td><td>是</td><td>-</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>operator<a href></a></td><td>使用索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>at()</td><td>使用经过边界检査的索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的<a href="https://c.biancheng.net/c/80/">指针</a>。</td><td>是</td><td>是</td><td>-</td></tr></tbody></table><p>list 和 forward_list 容器彼此非常相似，forward_list 中包含了 list 的大部分成员函数，而未包含那些需要反向遍历的函数。表 3 展示了 list 和 forward_list 的函数成员。</p><table><thead><tr><th>函数成员</th><th>函数功能</th><th>list<T></T></th><th>forward_list<T></T></th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td><td>是</td><td>是</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器。</td><td>是</td><td>是</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td><td>是</td><td>-</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td><td>是</td><td>-</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td></tr><tr><td>before_begin()</td><td>返回指向第一个元素前一个位置的迭代器。</td><td>-</td><td>是</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，即不能用该指针修改元素的值。</td><td>-</td><td>是</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>是</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>-</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td><td>是</td><td>-</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td><td>是</td><td>是</td></tr><tr><td>operator&#x3D;()</td><td>复制同类型容器的元素，或者用初始化列表替换现有内容。</td><td>是</td><td>是</td></tr><tr><td>size()</td><td>返回实际元素个数。</td><td>是</td><td>-</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值，这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td><td>是</td><td>是</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td><td>是</td><td>是</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td><td>是</td><td>是</td></tr><tr><td>front()</td><td>返回容器中第一个元素的引用。</td><td>是</td><td>是</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的引用。</td><td>是</td><td>-</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td><td>是</td><td>-</td></tr><tr><td>push_front()</td><td>在序列的起始位置添加一个元素。</td><td>是</td><td>是</td></tr><tr><td>emplace()</td><td>在指定位置直接生成一个元素。</td><td>是</td><td>-</td></tr><tr><td>emplace_after()</td><td>在指定位置的后面直接生成一个元素。</td><td>-</td><td>是</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td><td>是</td><td>-</td></tr><tr><td>cmplacc_front()</td><td>在序列的起始位生成一个元索。</td><td>是</td><td>是</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td><td>是</td><td>-</td></tr><tr><td>insert_after()</td><td>在指定位置的后面插入一个或多个元素。</td><td>-</td><td>是</td></tr><tr><td>pop_back()</td><td>移除序列尾部的元素。</td><td>是</td><td>-</td></tr><tr><td>pop_front()</td><td>移除序列头部的元素。</td><td>是</td><td>是</td></tr><tr><td>reverse()</td><td>反转容器中某一段的元素。</td><td>是</td><td>是</td></tr><tr><td>erase()</td><td>移除指定位置的一个元素或一段元素。</td><td>是</td><td>-</td></tr><tr><td>erase_after()</td><td>移除指定位置后面的一个元素或一段元素。</td><td>-</td><td>是</td></tr><tr><td>remove()</td><td>移除所有和参数匹配的元素。</td><td>是</td><td>是</td></tr><tr><td>remove_if()</td><td>移除满足一元函数条件的所有元素。</td><td>是</td><td>是</td></tr><tr><td>unique()</td><td>移除所有连续重复的元素。</td><td>是</td><td>是</td></tr><tr><td>clear()</td><td>移除所有的元素，容器大小变为 0。</td><td>是</td><td>是</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td><td>是</td><td>是</td></tr><tr><td>sort()</td><td>对元素进行排序。</td><td>是</td><td>是</td></tr><tr><td>merge()</td><td>合并两个有序容器。</td><td>是</td><td>是</td></tr><tr><td>splice()</td><td>移动指定位置前面的所有元素到另一个同类型的 list 中。</td><td>是</td><td>-</td></tr><tr><td>splice_after()</td><td>移动指定位置后面的所有元素到另一个同类型的 list 中。</td><td>-</td><td>是</td></tr></tbody></table><h2 id="array-STL-array-容器用法详解"><a href="#array-STL-array-容器用法详解" class="headerlink" title="array(STL array)容器用法详解"></a>array(STL array)容器用法详解</h2><p>array 容器是 <a href="https://c.biancheng.net/cplus/">C++</a> 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。</p><p>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中</array></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">array</span>;</span><br><span class="line">&#125;</span><br><span class="line">在使用该容器之前，代码中需引入 &lt;array&gt; 头文件，并默认使用 std 命令空间，如下所示：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。</p><p>通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 10&gt; values &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">double</span>, 10&gt; values &#123;<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,,<span class="number">2.0</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://c.biancheng.net/uploads/allimg/180911/2-1P911150226392.jpg" alt="初始化array容器"></p><p>array 容器还提供有很多功能实用的成员函数</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的随机访问迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的随机访问迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的随机访问迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()&#x3D;&#x3D;0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的<a href="https://c.biancheng.net/c/80/">指针</a>。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><h3 id="STL-array随机访问迭代器"><a href="#STL-array随机访问迭代器" class="headerlink" title="STL array随机访问迭代器"></a>STL array随机访问迭代器</h3><p>在 array 容器的模板类中，和随机访问迭代器相关的成员函数如表 1 所示。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="迭代器的具体功能示意图"></p><p>它们的功能并结合实际场景的需要，这些成员函数通常是成对使用的，即 begin()&#x2F;end()、rbegin()&#x2F;rend()、cbegin()&#x2F;cend()、crbegin()&#x2F;crend() 各自成对搭配使用。不仅如此，这 4 对中 begin()&#x2F;end() 和 cbegin()&#x2F;cend()、rbegin()&#x2F;rend() 和 crbegin()&#x2F;crend() 的功能大致是相同的（如图 2 所示），唯一的区别就在于其返回的迭代器能否用来修改元素值。</p><h4 id="begin-end-和-cbegin-cend"><a href="#begin-end-和-cbegin-cend" class="headerlink" title="begin()&#x2F;end() 和 cbegin()&#x2F;cend()"></a>begin()&#x2F;end() 和 cbegin()&#x2F;cend()</h4><p>begin() 和 end() 成员函数返回的都是正向迭代器，它们分别指向「首元素」和「尾元素+1」 的位置。在实际使用时，我们可以利用它们实现初始化容器或者遍历容器中元素的操作。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//初始化 values 容器为&#123;1,2,3,4,5&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        *first = h;</span><br><span class="line">        ++first;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器对象是由 array 对象的成员函数 begin() 和 end() 返回的。我们可以像使用普通<a href="https://c.biancheng.net/c/80/">指针</a>那样上使用迭代器对象。比如代码中，在保存了元素值后，使用前缀 ++ 运算符对 first 进行自增，当 first 等于 end 时，所有的元素都被设完值，循环结束。</p><p>当操作对象为 array 容器时，它们和 begin()&#x2F;end() 成员函数是通用的。所以上面代码中，first 和 last 还可以像下面这样定义：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">end</span> (values);</span><br></pre></td></tr></table></figure><p>array 模板类还提供了 cbegin() 和 cend() 成员函数，它们和 begin()&#x2F;end() 唯一不同的是，前者返回的是 const 类型的正向迭代器，这就意味着，有 cbegin() 和 cend() 成员函数返回的迭代器，可以用来遍历容器内的元素，也可以访问元素，但是不能对所存储的元素进行修改。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 array 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = values.<span class="built_in">cend</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//由于 *first 为 const 类型，不能用来修改元素</span></span><br><span class="line">    <span class="comment">//*first = 10;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//遍历容器并输出容器中所有元素</span></span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用 const 类型迭代器访问元素</span></span><br><span class="line">        cout &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array容器访问元素的几种方式"><a href="#array容器访问元素的几种方式" class="headerlink" title="array容器访问元素的几种方式"></a>array容器访问元素的几种方式</h2><h3 id="访问array容器中单个元素"><a href="#访问array容器中单个元素" class="headerlink" title="访问array容器中单个元素"></a>访问array容器中单个元素</h3><p>使用下标寻址符&#x3D;&#x3D;[]&#x3D;&#x3D;,但是可能越界访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2.</span>O*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>为了避免越界访问，可以使用array的成员函数at()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">values.<span class="built_in">at</span> (<span class="number">4</span>) = values.<span class="built_in">at</span>(<span class="number">3</span>) + <span class="number">2.</span>O*values.<span class="built_in">at</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句实现的功能相同，其次当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。因此当需要访问容器中某个指定元素时，建议大家使用 at()，除非确定索引没有越界。</p><p>array 容器还提供了 get<n> 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素。需要注意的是，该模板函数中，参数的实参必须是一个在编译时可以确定的常量表达式，所以它不能是一个循环变量。也就是说，它只能访问模板参数指定的元素，编译器在编译时会对它进行检查。</n></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;string, 5&gt; words&#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(words) &lt;&lt; endl; <span class="comment">// Output words[3]</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; get&lt;6&gt;(words) &lt;&lt; std::endl; //越界，会发生编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，array 容器提供了 data() 成员函数，通过调用该函数可以得到指向容器首个元素的<a href="https://c.biancheng.net/c/80/">指针</a>。通过该指针，我们可以获得容器中的各个元素，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; *( words.<span class="built_in">data</span>()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问array容器中多个元素"><a href="#访问array容器中多个元素" class="headerlink" title="访问array容器中多个元素"></a>访问array容器中多个元素</h3><p>我们知道，array 容器提供的 size() 函数能够返回容器中元素的个数（函数返回值为 size_t 类型），所以能够像下面这样去逐个提取容器中的元素，并计算它们的和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; values.<span class="built_in">size</span>() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size() 函数的存在，为 array 容器提供了标准数组所没有的优势，即能够知道它包含多少元素。</p><p>并且，接受数组容器作为参数的函数，只需要通过调用容器的成员函数 size()，就能得到元素的个数。除此之外，通过调用 array 容器的 empty() 成员函数，即可知道容器中有没有元素（如果容器中没有元素，此函数返回 true），如下所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(values.<span class="built_in">empty</span>())</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has no elements.\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The container has &quot;</span>&lt;&lt; values.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;elements.\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>如何获取 array 容器中元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values1;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; values1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.<span class="built_in">at</span>(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="type">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.<span class="built_in">begin</span>(); i &lt; values1.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.<span class="built_in">begin</span>(); i &lt; values2.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.  初始化列表"></a>1.  初始化列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 需注意，C++ 中 vector 即是本文描述的 nums</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1;</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2.  访问元素"></a>2.  访问元素</h4><p>本质上是数组，因此可以在 O(1) 时间内访问和更新元素，效率很高。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> num = nums[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure><h4 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3.  插入与删除元素"></a>3.  插入与删除元素</h4><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 O(1) ，但插入和删除元素的效率仍与数组相同，时间复杂度为 O(n) 。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">nums.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">nums.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>);      <span class="comment">// 删除索引 3 处的元素</span></span><br><span class="line">nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>(),num.<span class="built_in">begin</span>()+<span class="number">2</span>);<span class="comment">//删除索引0-2区间内的元素</span></span><br></pre></td></tr></table></figure><h4 id="4-遍历列表"><a href="#4-遍历列表" class="headerlink" title="4.  遍历列表"></a>4.  遍历列表</h4><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    count += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5.  拼接列表"></a>5.  拼接列表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// 将列表 nums1 拼接到 nums 之后</span></span><br><span class="line">nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h4 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.  排序列表"></a>6.  排序列表</h4><p>完成列表排序后，我们便可以使用在数组类算法题中经常考查的“二分查找”和“双指针”算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure><h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><p>许多编程语言内置了列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。</p><p>为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。</p><ul><li><strong>初始容量</strong>：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。</li><li><strong>数量记录</strong>：声明一个变量 <code>size</code> ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li><li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *arr;             <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> arrCapacity = <span class="number">10</span>; <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> arrSize = <span class="number">0</span>;      <span class="comment">// 列表长度（当前元素数量）</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>;   <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">MyList</span>() &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[arrCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">MyList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引如果越界，则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        arr[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        arr[<span class="built_in">size</span>()] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= index; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = arr[index];</span><br><span class="line">        <span class="comment">// 将索引 index 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = index; j &lt; <span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize--;</span><br><span class="line">        <span class="comment">// 返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extendCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个长度为原数组 extendRatio 倍的新数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">capacity</span>() * extendRatio;</span><br><span class="line">        <span class="type">int</span> *tmp = arr;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">        <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            arr[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        arrCapacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为 Vector 用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vec[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="vector添加元素（push-back-和emplace-back-）详解"><a href="#vector添加元素（push-back-和emplace-back-）详解" class="headerlink" title="vector添加元素（push_back()和emplace_back()）详解"></a>vector添加元素（push_back()和emplace_back()）详解</h3><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><p>该成员函数的功能是在 vector 容器尾部添加一个元素，用法也非常简单，比如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back()"></a>emplace_back()</h4><p>该函数是 <a href="https://c.biancheng.net/cplus/">C++</a> 11 新增加的，其功能和 push_back() 相同，都是在 vector 容器的尾部添加一个元素。</p><p>emplace_back() 成员函数的用法也很简单，这里直接举个例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h4><p>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</p><p><strong>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；</strong></p><p><strong>而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.<span class="built_in">emplace_back</span>(<span class="number">2</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果为：</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为</span></span><br><span class="line"><span class="comment">emplace_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">push_back:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用拷贝构造函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。因此，在实际使用时，建议大家优先选用 emplace_back()。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。</code></p><h3 id="insert-和emplace-详解"><a href="#insert-和emplace-详解" class="headerlink" title="insert()和emplace()详解"></a>insert()和emplace()详解</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p>insert() 函数的功能是在 vector 容器的指定位置插入一个或多个元素。该函数的语法格式有多种，如表 1 所示。</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>iterator insert(pos,elem)</td><td>在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,n,elem)</td><td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,first,last)</td><td>在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td>iterator insert(pos,initlist)</td><td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><p>下面的例子，演示了如何使用 insert() 函数向 vector 容器中插入元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="emplace"><a href="#emplace" class="headerlink" title="emplace()"></a>emplace()</h4><p>emplace() 是 <a href="https://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素。</p><p><strong><code>再次强调，emplace() 每次只能插入一个元素，而不是多个。</code></strong></p><p>该函数的语法格式如下：</p><p><code>iterator emplace (const_iterator pos, args...);</code></p><p>其中，pos 为指定插入位置的迭代器；args… 表示与新插入元素的构造函数相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</p><p><code>简单的理解 args...，即被插入元素的构造函数需要多少个参数，那么在 emplace() 的第一个参数的后面，就需要传入相应数量的参数。</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; demo1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure><p>既然 emplace() 和 insert() 都能完成向 vector 容器中插入新元素，那么谁的运行效率更高呢？答案是 emplace()。在说明原因之前，通过下面这段程序，就可以直观看出两者运行效率的差异：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="type">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.<span class="built_in">insert</span>(demo2.<span class="built_in">begin</span>(), <span class="built_in">testDemo</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace:</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;移动构造函数看另一个C++11新特性里的右值引用部分&#x3D;&#x3D;</p><hr><h3 id="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"><a href="#vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）" class="headerlink" title="vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）"></a>vector如何避免多次不必要的扩容带来的性能损失（reserve函数的调用）</h3><h4 id="1、vector数据结构性质"><a href="#1、vector数据结构性质" class="headerlink" title="1、vector数据结构性质"></a>1、vector数据结构性质</h4><p>vector占用一块连续分配的内存，一种可以存储任意类型的动态数组，与array不同的地方就是：数组是静态分配空间，一旦分配了空间的大小，就不可再改变了；而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</p><p>vector数据结构如下，通过三个迭代器start, finish, end_of_storage的系列public接口，可很好地完成数据存储、溢出判断(iter &gt;&#x3D; iv.end())、大小、容量(容量与大小不等，以免不断申请空间耗费资源)、重载操作符[]、判空、最前元素、最后元素等等。<br><img src="/../typora-user-images/vector.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">iterator start;               <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line"> iterator finish;              <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage;      <span class="comment">// 表示实际分配内存空间的尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;扩容条件&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size==capacity;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> - size:实际所包含的元素个数 </span></span><br><span class="line"><span class="comment"> - capacity:容器的容量,指的是在不分配更多内存的情况下，容器可以保存的最多元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/kuorong.png" alt="在这里插入图片描述"></p><p>vector 容器扩容的整个过程，大致分为以下 4 个步骤：</p><p>1、分配一块大小是当前 vector 容量几倍的新存储空间。注意，多数 STL 版本中的 vector 容器，其容器都会以 2<br>的倍数增长，也就是说，每次 vector 容器扩容，它们的容量都会提高到之前的 2 倍；<br>2、将 vector 容器存储的所有元素，依照原有次序从旧的存储空间复制到新的存储空间中；<br>3、析构掉旧存储空间中存储的所有元素；<br>4、释放旧的存储空间。<br>通过以上分析不难看出，vector 容器的扩容过程是非常耗时的，并且当容器进行扩容后，之前和该容器相关的所有指针、迭代器以及引用都会失效。因此在使用 vector 容器过程中，我们应尽量避免执行不必要的扩容操作。</p><hr><h4 id="2、push-back后iterator失效程序崩溃的原因"><a href="#2、push-back后iterator失效程序崩溃的原因" class="headerlink" title="2、push_back后iterator失效程序崩溃的原因"></a>2、push_back后iterator失效程序崩溃的原因</h4><p>在使用push_back对vector进行构造的时候，vector的容量capacity(与size有区别)会根据压入元素的数量进行内存的自动重新分配，这时候iterator会因为vector存储空间的变化而失效，需要注意iterator的有效性，以免iterator指向未知的内存空间导致程序异常。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">iter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用for进行vector的push_back之后，初始化了一个iterator指向vecInt的begin位置，并打印验证。之后再用push_back在vector的末尾添加了一个元素123，这时候用iter来遍历vecInt。</p><p>&#x3D;&#x3D;下面对MAX_NUM进行修改，将其改为8&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8<span class="comment">//MAX_NUM修改为8，其余地方不做任何修改</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iter != vecInt.<span class="built_in">end</span>())&#123;</span><br><span class="line">cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">iter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只修改MAX_NUM的值，其他地方保留和code2一样，再次运行的时候，程序崩溃了！</p><p>对于vector来说，和数组最大的区别之一，就是不需要在初始化的时候声明vector的大小。如果初始化的时候没有指明vector的大小，那么会根据实际的使用情况，在内存中为vector分配的大小分别 2 -&gt; 4 -&gt; 8 -&gt; 16 … 。<br>MAX_NUM是8，所以在for进行push_back之后，vecInt在内存中的大小为8。 对vecInt再次将元素123进行push_back的时候，新的vector大小将超过当前的vector大小，所以会自动重新分配存储空间。<br>由于vector的存储空间已经被重新分配，在push_back(123)之后，iter自然也就会指向一个未知的空间。所以会导致程序异常。<br>&#x3D;&#x3D;可以使用capacity()验证&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != MAX_NUM; i++)&#123;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = vecInt.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the 1st element: &quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">123</span>);</span><br><span class="line">cout &lt;&lt; vecInt.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先注释掉会崩溃的代码</span></span><br><span class="line"><span class="comment">//while(iter != vecInt.end())&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//iter++;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity:8</span></span><br><span class="line"><span class="comment">the lst element:0</span></span><br><span class="line"><span class="comment">capacity:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3、reserve（）避免多次不必要的扩容"><a href="#3、reserve（）避免多次不必要的扩容" class="headerlink" title="3、reserve（）避免多次不必要的扩容"></a>3、reserve（）避免多次不必要的扩容</h4><p><img src="/../typora-user-images/res.png" alt="image-20240319105542682"></p><p>reserve的作用是更改vector的容量（capacity），使vector至少可以容纳n个元素。</p><ul><li>如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间</li></ul><p>当push_back的元素数量大于n的时候，会重新分配一个大小为2n的新空间，再将原有的n的元素和新的元素放入新开辟的内存空间中。</p><p>（注：重新分配内存，并不会在原有的地址之后紧跟着分配的新的空间，一般会重新开辟一段更大的空间，再将原来的数据和新的数据放入新的空间）</p><hr><h3 id="利用vector的swap-成员收缩内存"><a href="#利用vector的swap-成员收缩内存" class="headerlink" title="利用vector的swap()成员收缩内存"></a>利用vector的swap()成员收缩内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给v重新设定尺寸</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给v收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收缩内存后v的容量&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;收缩内存后v的尺寸&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以发现，直接用resize()成员只能做到缩小尺寸（size），而实际的容量（capacity）并没有缩小。但是，使用swap()成员就能做到同时收缩v的容量。</p><p>原理就是，先利用待收缩的v进行拷贝构造创建出一个匿名对象，这个对象的尺寸和容量大小都是v当前的尺寸大小（上面例子中也就是3）。然后匿名对象调用swao()成员，与v交换指针（容器交换），匿名对象的指针指向之前v的那片内存空间，v的指针指向匿名对象的那片内存空间。这样v的尺寸和容量就都能得到收缩了。（执行完这行语句之后，由于是匿名对象，所以匿名对象所知的那篇内存空间会被释放）</p><hr><h3 id="vector不是存储bool类型元素的vector容器"><a href="#vector不是存储bool类型元素的vector容器" class="headerlink" title="&#x3D;&#x3D;vector不是存储bool类型元素的vector容器&#x3D;&#x3D;"></a>&#x3D;&#x3D;vector<bool>不是存储bool类型元素的vector容器&#x3D;&#x3D;</bool></h3><p><code>具体来讲，不推荐使用 vector&lt;bool&gt; 的原因有以下 2 个：</code></p><ol><li><code>严格意义上讲，vector&lt;bool&gt; 并不是一个 STL 容器；</code></li><li><code>vector&lt;bool&gt; 底层存储的并不是 bool 类型值。</code></li></ol><p>值得一提的是，对于是否为 STL 容器，C++ 标准库中有明确的判断条件，其中一个条件是：如果 cont 是包含对象 T 的 STL 容器，且该容器中重载了 [ ] 运算符（即支持 operator[]），则以下代码必须能够被编译：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此行代码的含义是，借助 operator[ ] 获取一个 cont<T> 容器中存储的 T 对象，同时将这个对象的地址赋予给一个 T 类型的指针。<br>这就意味着，如果 vector<bool> 是一个 STL 容器，则下面这段代码是可以通过编译的：</bool></T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 vector&lt;bool&gt; 容器</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt;cont&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//试图将指针 p 指向 cont 容器中第一个元素</span></span><br><span class="line"><span class="type">bool</span> *p = &amp;cont[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此段代码不能通过编译。原因在于 vector<bool> 底层采用了独特的存储机制。</bool></p><p>实际上，为了节省空间，vector<bool> 底层在存储各个 bool 类型值时，每个 bool 值都只使用一个比特位（二进制位）来存储。也就是说在 vector<bool> 底层，<strong>一个字节可以存储 8 个 bool 类型值。</strong>在这种存储机制的影响下，<strong>operator[ ] 势必就需要返回一个指向单个比特位的引用，但显然这样的引用是不存在的，等号左右两边出现冲突！</strong><br>如果在实际场景中需要使用 vector<bool> 这样的存储结构，该怎么办呢？很简单，可以选择使用 <strong>deque<bool></bool></strong> 或者 <strong>bitset</strong> 来替代 vector<bool>。</bool></bool></bool></bool></p><p>deque 容器几乎具有 vecotr 容器全部的功能（拥有的成员方法也仅差 reserve() 和 capacity()），而且更重要的是，deque 容器可以正常存储 bool 类型元素。</p><p>还可以考虑用 bitset 代替 vector<bool>，其本质是一个模板类，可以看做是一种类似数组的存储结构。和后者一样，bitset 只能用来存储 bool 类型值，且底层存储机制也采用的是用一个比特位来存储一个 bool 值。</bool></p><p>和 vector 容器不同的是，bitset 的大小在一开始就确定了，因此不支持插入和删除元素；另外 bitset 不是容器，所以不支持使用迭代器</p><hr><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><p>deque 是 double-ended queue 的缩写，又称双端队列容器。</p><p>前面章节中，我们已经系统学习了 vector 容器，值得一提的是，deque 容器和 vecotr 容器有很多相似之处，比如：</p><ul><li><p>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为<code>O(1)</code>），而不擅长在序列中间添加或删除元素。</p></li><li><p>deque 容器也可以根据需要修改自身的容量和大小。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png" alt="双向队列的操作"></p></li></ul><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>。并且更重要的一点是，deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。</p><blockquote><p>当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</p></blockquote><p>deque 容器以模板类 deque<T>（T 为存储元素的类型）的形式在 <deque> 头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</deque></T></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;deque&gt;using namespace std;</span><br></pre></td></tr></table></figure><blockquote><p>注意，std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。</p></blockquote><h3 id="创建deque容器的几种方式"><a href="#创建deque容器的几种方式" class="headerlink" title="创建deque容器的几种方式"></a>创建deque容器的几种方式</h3><ol><li>创建一个没有任何元素的空 deque 容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d;</span><br></pre></td></tr></table></figure><p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p><ol start="2"><li>创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10);</span><br></pre></td></tr></table></figure><p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p><ol start="3"><li>创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d(10, 5)</span><br></pre></td></tr></table></figure><p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p><ol start="4"><li>在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::deque&lt;int&gt; d1(5);std::deque&lt;int&gt; d2(d1);</span><br></pre></td></tr></table></figure><p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p><ol start="5"><li>通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拷贝普通数组，创建deque容器int a[] = &#123; 1,2,3,4,5 &#125;;std::deque&lt;int&gt;d(a, a + 5);//适用于所有类型的容器std::array&lt;int, 5&gt;arr&#123; 11,12,13,14,15 &#125;;std::deque&lt;int&gt;d(arr.begin()+2, arr.end());//拷贝arr容器中的&#123;13,14,15&#125;</span><br></pre></td></tr></table></figure><h3 id="deque容器可利用的成员函数"><a href="#deque容器可利用的成员函数" class="headerlink" title="deque容器可利用的成员函数"></a>deque容器可利用的成员函数</h3><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>size()</td><td>返回实际元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小。</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td></tr><tr><td>erase()</td><td>移除一个元素或一段元素。</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr></tbody></table><p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p><p>deque 容器还有一个<code>std::swap(x , y)</code> 非成员函数（其中 x 和 y 是存储相同类型元素的 deque 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异</p><hr><h3 id="deque容器迭代器的使用注意事项"><a href="#deque容器迭代器的使用注意事项" class="headerlink" title="deque容器迭代器的使用注意事项"></a>deque容器迭代器的使用注意事项</h3><p>首先需要注意的一点是，迭代器的功能是遍历容器，在遍历的同时可以访问（甚至修改）容器中的元素，但迭代器不能用来初始化空的 deque 容器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//*first = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，当向 deque 容器添加元素时，deque 容器会申请更多的内存空间，同时其包含的所有元素可能会被复制或移动到新的内存地址（原来占用的内存会释放），这会导致之前创建的迭代器失效。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> first = d.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//添加元素，会导致 first 失效</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;导致程序运行崩溃，其原因就在于在创建 first 迭代器之后，deque 容器做了添加元素的操作，导致 first 失效。&#x3D;&#x3D;</p><blockquote><p>在对容器做添加元素的操作之后，如果仍需要使用之前以创建好的迭代器，为了保险起见，一定要重新生成。</p></blockquote><h3 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> front = deque.<span class="built_in">front</span>(); <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> back = deque.<span class="built_in">back</span>();   <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = deque.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><h3 id="双向队列实现"><a href="#双向队列实现" class="headerlink" title="双向队列实现"></a>双向队列实现</h3><h4 id="1-基于双向链表的实现¶"><a href="#1-基于双向链表的实现¶" class="headerlink" title="1.  基于双向链表的实现¶"></a>1.  基于双向链表的实现<a href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#1">¶</a></h4><p>因为它可以方便地删除头节点（对应出队操作）和在尾节点后添加新节点（对应入队操作）。</p><p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p><p>linkedListDeque</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step1.png" alt="基于链表实现双向队列的入队出队操作"></p><p>push_back()</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step2_push_last.png" alt="linkedlist_deque_push_last"></p><p>push_front()</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step3_push_first.png" alt="linkedlist_deque_push_first"></p><p>pop_back()</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step4_pop_last.png" alt="linkedlist_deque_pop_last"></p><p>pop_front()</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_step5_pop_first.png" alt="linkedlist_deque_pop_first"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;              <span class="comment">// 节点值</span></span><br><span class="line">    DoublyListNode *next; <span class="comment">// 后继节点指针</span></span><br><span class="line">    DoublyListNode *prev; <span class="comment">// 前驱节点指针</span></span><br><span class="line">    <span class="built_in">DoublyListNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize = <span class="number">0</span>;              <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">LinkedListDeque</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">LinkedListDeque</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">        DoublyListNode *pre, *cur = front;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num, <span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = <span class="keyword">new</span> <span class="built_in">DoublyListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front 和 rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front-&gt;prev = node;</span><br><span class="line">            node-&gt;next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            node-&gt;prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front-&gt;val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            DoublyListNode *fNext = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fNext-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> front;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear-&gt;val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            DoublyListNode *rPrev = rear-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                rPrev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                rear-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rear-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-基于数组的实现¶"><a href="#2-基于数组的实现¶" class="headerlink" title="2.  基于数组的实现¶"></a>2.  基于数组的实现<a href="https://www.hello-algo.com/chapter_stack_and_queue/deque/#2">¶</a></h4><p>如图 5-9 所示，与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。</p><p>ArrayDeque</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step1.png" alt="基于数组实现双向队列的入队出队操作"></p><p>push_last</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step2_push_last.png" alt="array_deque_push_last"></p><p>push_first</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step3_push_first.png" alt="array_deque_push_first"></p><p>pop_last</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step4_pop_last.png" alt="array_deque_pop_last"></p><p>pop_first</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/array_deque_step5_pop_first.png" alt="array_deque_pop_first"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums; <span class="comment">// 用于存储双向队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;        <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;      <span class="comment">// 双向队列长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayDeque</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        nums.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组尾部后，回到头部</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">        <span class="keyword">return</span> (i + <span class="built_in">capacity</span>()) % <span class="built_in">capacity</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">        <span class="comment">// 通过取余操作实现 front 越过数组头部后回到尾部</span></span><br><span class="line">        front = <span class="built_in">index</span>(front - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 num 添加至队首</span></span><br><span class="line">        nums[front] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="type">int</span> rear = <span class="built_in">index</span>(front + queSize);</span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekFirst</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">        front = <span class="built_in">index</span>(front + <span class="number">1</span>);</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekLast</span>();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算尾元素索引</span></span><br><span class="line">        <span class="type">int</span> last = <span class="built_in">index</span>(front + queSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            res[i] = nums[<span class="built_in">index</span>(j)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list（STL-list）容器完全攻略（超级详细）"><a href="#list（STL-list）容器完全攻略（超级详细）" class="headerlink" title="list（STL list）容器完全攻略（超级详细）"></a>list（STL list）容器完全攻略（超级详细）</h2><p><a href="https://c.biancheng.net/stl/">STL</a> list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><p><img src="https://c.biancheng.net/uploads/allimg/180912/2-1P912134314345.jpg" alt="img"></p><p>可以看到，list 容器中各个元素的前后顺序是靠<a href="https://c.biancheng.net/c/80/">指针</a>来维系的，每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p><p>基于这样的存储结构，list 容器具有一些其它容器（array、vector 和 deque）所不具备的优势，即它可以在序列已知的任何位置快速插入或删除元素（时间复杂度为<code>O(1)</code>）。并且在 list 容器中移动元素，也比其它容器的效率高。</p><p>使用 list 容器的缺点是，它不能像 array 和 vector 那样，通过位置直接访问元素。举个例子，如果要访问 list 容器中的第 6 个元素，它不支持<code>容器对象名[6]</code>这种语法格式，正确的做法是从容器中第一个元素或最后一个元素开始遍历容器，直到找到该位置。</p><p><code>实际场景中，如何需要对序列进行大量添加或删除元素的操作，而直接访问元素的需求却很少，这种情况建议使用 list 容器存储序列。</code></p><p>list 容器以模板类 list<T>（T 为存储元素的类型）的形式在<code>&lt;list&gt;</code>头文件中，并位于 std 命名空间中。因此，在使用该容器之前，代码中需要包含下面两行代码：</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><blockquote><p>注意，std 命名空间也可以在使用 list 容器时额外注明，两种方式都可以。</p></blockquote><h4 id="list容器可用的成员函数"><a href="#list容器可用的成员函数" class="headerlink" title="list容器可用的成员函数"></a>list容器可用的成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素。</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素。</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素。</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table><h4 id="list迭代器及用法"><a href="#list迭代器及用法" class="headerlink" title="list迭代器及用法"></a>list迭代器及用法</h4><p><img src="https://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="img"></p><hr><h2 id="STL-forward-list容器完全攻略"><a href="#STL-forward-list容器完全攻略" class="headerlink" title="STL forward_list容器完全攻略"></a>STL forward_list容器完全攻略</h2><p>forward_list 是 <a href="https://c.biancheng.net/cplus/">C++</a> 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表</p><p><img src="https://c.biancheng.net/uploads/allimg/191219/2-191219135239561.gif" alt="单链表和双向链表"></p><p> 不难看出，使用链表存储数据最大的特点在于，其并不会将数据进行集中存储（向数组那样），换句话说，链表中数据的存储位置是分散的、随机的，整个链表中数据的线性关系通过<a href="https://c.biancheng.net/c/80/">指针</a>来维持。</p><p>因此，forward_list 容器具有和 list 容器相同的特性，即擅长在序列的任何位置进行插入元素或删除元素的操作，但对于访问存储的元素，没有其它容器（如 array、vector）的效率高。</p><p>另外，由于单链表没有双向链表那样灵活，因此相比 list 容器，forward_list 容器的功能受到了很多限制。比如，由于单链表只能从前向后遍历，而不支持反向遍历，因此 forward_list 容器只提供前向迭代器，而不是双向迭代器。这意味着，forward_list 容器不具有 rbegin()、rend() 之类的成员函数。</p><h4 id="forward-list容器的创建"><a href="#forward-list容器的创建" class="headerlink" title="forward_list容器的创建"></a>forward_list容器的创建</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::forward_list&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">values</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建一个包含 n 个元素的 forward_list 容器，并为每个元素指定初始值。</span></span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::forward_list&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1)</span></span>;<span class="comment">//在已有 forward_list 容器的情况下，通过拷贝该容器可以创建新的 forward_list 容器</span></span><br></pre></td></tr></table></figure><h4 id="forward-list容器支持的成员函数"><a href="#forward-list容器支持的成员函数" class="headerlink" title="forward_list容器支持的成员函数"></a>forward_list容器支持的成员函数</h4><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>before_begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td></tr><tr><td>begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td></tr><tr><td>end()</td><td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td></tr><tr><td>insert_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>erase_after()</td><td>删除容器中某个指定位置或区域内的所有元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice_after()</td><td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序。</td></tr></tbody></table><p>C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 forward_list 容器包含的 begin() 和 end() 成员函数不同，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。</p><p>forward_list 容器还有一个<code>std::swap(x , y)</code>非成员函数（其中 x 和 y 是存储相同类型元素的 forward_list 容器），它和 swap() 成员函数的功能完全相同，仅使用语法上有差异。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.<span class="built_in">emplace_front</span>(<span class="number">4</span>);<span class="comment">//&#123;4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">emplace_after</span>(values.<span class="built_in">before_begin</span>(), <span class="number">5</span>); <span class="comment">//&#123;5,4,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">reverse</span>();<span class="comment">//&#123;3,2,1,4,5&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = values.<span class="built_in">begin</span>(); it != values.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 2 1 4 5</span></span><br></pre></td></tr></table></figure><h4 id="和使用forward-list容器相关的函数"><a href="#和使用forward-list容器相关的函数" class="headerlink" title="和使用forward_list容器相关的函数"></a>和使用forward_list容器相关的函数</h4><p>forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 <iterator> 中的 dis<a href="https://c.biancheng.net/ref/tan.html">tan</a>ce() 函数。举个例子：</iterator></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">distance</span>(std::<span class="built_in">begin</span>(my_words), std::<span class="built_in">end</span>(my_words));</span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数，比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="STL关联式容器"><a href="#STL关联式容器" class="headerlink" title="STL关联式容器"></a>STL关联式容器</h1><h2 id="STL关联式容器是什么"><a href="#STL关联式容器是什么" class="headerlink" title="STL关联式容器是什么"></a>STL关联式容器是什么</h2><p>通过学习所有的序列式容器不难发现，无论是哪种序列式容器，其存储的都是 C++ 基本数据类型（诸如 int、double、float、string 等）或使用结构体自定义类型的元素。</p><p>关联式容器则大不一样，此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。</p><blockquote><p>弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。</p></blockquote><p>使用关联式容器存储的元素，都是一个一个的“键值对”（ &lt;key,value&gt; ），这是和序列式容器最大的不同。除此之外，序列式容器中存储的元素默认都是未经过排序的，而使用关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序。</p><p>关联式容器所具备的这些特性，归咎于 STL 标准库在实现该类型容器时，底层选用了 「红黑树」这种<a href="https://c.biancheng.net/data_structure/">数据结构</a>来组织和存储各个键值对。有关红黑树组织和存储数据的方式，我们已经在数据结构中做了详细的介绍，读者可猛击《<a href="https://c.biancheng.net/view/vip_3433.html">红黑树</a>》一文做详细了解。</p><hr><h2 id="C-STL关联式容器种类"><a href="#C-STL关联式容器种类" class="headerlink" title="C++ STL关联式容器种类"></a>C++ STL关联式容器种类</h2><table><thead><tr><th>关联式容器名称</th><th>特点</th></tr></thead><tbody><tr><td>map</td><td>定义在 <map> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序（调用 std::less<T>）。</T></map></td></tr><tr><td>set</td><td>定义在 <set> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less<T>）。</T></set></td></tr><tr><td>multimap</td><td>定义在 <map> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</map></td></tr><tr><td>multiset</td><td>定义在 <set> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</set></td></tr></tbody></table><p>这里为 map 容器为例，编写了一个样例（如下所示）。对于该程序，读者只需体会关联式容器的特性即可，无需纠结 map 容器的具体用法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>] = <span class="string">&quot;C语言教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>] = <span class="string">&quot;Python教程&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>] = <span class="string">&quot;Java教程&quot;</span>;</span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 容器在存储元素时，会根据各个元素键的大小自动调整元素的顺序（默认按照升序排序）</p><h2 id="STL-pair用法"><a href="#STL-pair用法" class="headerlink" title="STL pair用法"></a>STL pair用法</h2><p>关联式容器存储的是“键值对”形式的数据，比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="string">&quot;a&quot;</span>,<span class="number">1</span>&gt;;</span><br><span class="line">&lt;<span class="string">&quot;b&quot;</span>,<span class="number">214</span>&gt;</span><br></pre></td></tr></table></figure><p>每行都表示一个键值对，其中第一个元素作为键（key），第二个元素作为值（value）</p><p>基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。</p><p>虑到“键值对”并不是普通类型数据，<a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second（可以是 C++ 基本数据类型、结构体、类自定的类型）创建成一个新元素<code>&lt;first, second&gt;</code>。通过其构成的元素格式不难看出，使用 pair 类模板来创建“键值对”形式的元素，再合适不过。</p><p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中，所以在使用该类模板之前，需引入此头文件。另外值得一提的是，在 C++ 11 标准之前，pair 类模板中提供了以下 3 种构造函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="number">1</span>) 默认构造函数，即创建空的 pair 对象</span><br><span class="line"><span class="built_in">pair</span>();</span><br><span class="line">#<span class="number">2</span>) 直接使用 <span class="number">2</span> 个元素初始化成 pair 对象</span><br><span class="line"><span class="built_in">pair</span> (<span class="type">const</span> first_type&amp; a, <span class="type">const</span> second_type&amp; b);</span><br><span class="line">#<span class="number">3</span>) 拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(<span class="type">const</span> pair&lt;U,V&gt;&amp; pr)</span></span>;</span><br><span class="line"><span class="comment">//C++11引入右值引用</span></span><br><span class="line">#<span class="number">4</span>) 移动构造函数</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(pair&lt;U,V&gt;&amp;&amp; pr)</span></span>;<span class="comment">//一般使用make_pair(U u,T t)作为移动构造函数返回</span></span><br><span class="line">#<span class="number">5</span>) 使用右值引用参数，创建 pair 对象</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> V&gt; <span class="title">pair</span> <span class="params">(U&amp;&amp; a, V&amp;&amp; b)</span></span>;</span><br></pre></td></tr></table></figure><p>C++ 11 还允许我们手动为 pair1 对象赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pairl.first=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">pairl.second=<span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小</p><p>注意，对于进行比较的 2 个 pair 对象，其对应的键和值的类型比较相同，否则将没有可比性，同时编译器提示没有相匹配的运算符，即找不到合适的重载运算符。也就是说相同类型的pair</p><p>pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p><hr><h2 id="STL-map"><a href="#STL-map" class="headerlink" title="STL map"></a>STL map</h2><p>作为关联式容器的一种，map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括 <a href="https://c.biancheng.net/cplus/">C++</a> 基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p><blockquote><p>通常情况下，map 容器中存储的各个键值对都选用 string 字符串作为键的类型。</p></blockquote><p>与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。当然，根据实际情况的需要，我们可以手动指定 map 容器的排序规则，既可以选用 <a href="https://c.biancheng.net/stl/">STL</a> 标准库中提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>），也可以自定义排序规则。</p><p>另外需要注意的是，&#x3D;&#x3D;<strong>使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</strong>&#x3D;&#x3D;换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p><blockquote><p>前面提到，map 容器存储的都是 pair 类型的键值对元素，更确切的说，该容器存储的都是 pair&lt;const K, T&gt; 类型（其中 K 和 T 分别表示键和值的数据类型）的键值对元素。</p></blockquote><h3 id="创建C-map容器的几种方法"><a href="#创建C-map容器的几种方法" class="headerlink" title="创建C++ map容器的几种方法"></a>创建C++ map容器的几种方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过调用 map 容器类的默认构造函数，可以创建出一个空的 map 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap;</span><br><span class="line"><span class="comment">// 当然在创建 map 容器的同时，也可以进行初始化</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="comment">//map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123;std::<span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>),std::<span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>)&#125;;              </span><br><span class="line"><span class="comment">//在某些场景中，可以利用先前已创建好的 map 容器，再创建一个新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(myMap);                   <span class="comment">//C++ 11 标准中，还为 map 容器增添了移动构造函数。当有临时的 map 对象作为参数，传递给要初始化的 map 容器时，此时就会调用移动构造函数。 #创建一个会返回临时 map 对象的函数</span></span><br><span class="line"><span class="function">std::map&lt;std::string,<span class="type">int</span>&gt; <span class="title">disMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt;tempMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用 map 类模板的移动构造函数创建 newMap 容器</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(<span class="built_in">disMap</span>());</span><br><span class="line"><span class="comment">//map 类模板还支持取已建 map 容器中指定区域内的键值对，创建并初始化新的 map 容器。</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;<span class="built_in">newMap</span>(++myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*当然，在以上几种创建 map 容器的基础上，我们都可以手动修改 map 容器的排序规则。默认情况下，map 容器调用 std::less&lt;T&gt; 规则，根据容器内各键值对的键的大小，对所有键值对做升序排序。*/</span>                     </span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::less&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//手动修改了 myMap 容器的排序规则，令其作降序排序</span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;               </span><br></pre></td></tr></table></figure><hr><h3 id="C-map容器包含的成员方法"><a href="#C-map容器包含的成员方法" class="headerlink" title="C++ map容器包含的成员方法"></a>C++ map容器包含的成员方法</h3><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 map 容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[]</td><td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td></tr><tr><td>at(key)</td><td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td></tr><tr><td>insert()</td><td>向 map 容器中插入键值对。</td></tr><tr><td>erase()</td><td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td></tr><tr><td>swap()</td><td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(key)</td><td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table><h3 id="STL-map容器迭代器"><a href="#STL-map容器迭代器" class="headerlink" title="STL map容器迭代器"></a>STL map容器迭代器</h3><p><a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> 标准库为 map 容器配备的是双向迭代器（bidirectional iterator）。这意味着，map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符进行比较。</p><p>相比序列式容器，map 容器提供了更多的成员方法（如表 1 所示），通过调用它们，我们可以轻松获取具有指定含义的迭代器。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td></tr></tbody></table><p><img src="/../typora-user-images/2-19112Q14QE40.png" alt="C++ STL map部分成员方法示意图"></p><p>map 类模板中还提供有 lower_bound(key) 和 upper_bound(key) 成员方法，它们的功能是类似的，唯一的区别在于：</p><ul><li>&#x3D;&#x3D;lower_bound(key) 返回的是指向第一个键不小于 key 的键值对的迭代器；&#x3D;&#x3D;</li><li>&#x3D;&#x3D;upper_bound(key) 返回的是指向第一个键大于 key 的键值对的迭代器；&#x3D;&#x3D;</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//找到第一个键的值不小于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;Java教程&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound(key) 和 upper_bound(key) 更多用于 multimap 容器，在 map 容器中很少用到。</code></p><p>equal_range(key) 成员方法可以看做是 lower_bound(key) 和 upper_bound(key) 的结合体，该方法会返回一个 pair 对象，其中的 2 个元素都是迭代器类型，其中 pair.first 实际上就是 lower_bound(key) 的返回值，而 pair.second 则等同于 upper_bound(key) 的返回值。</p><p>显然，equal_range(key) 成员方法表示的一个范围，位于此范围中的键值对，其键的值都为 key。举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">//pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;myMap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                   &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个 pair 对象，来接收 equal_range() 的返回值</span></span><br><span class="line">    pair &lt;std::map&lt;string, string&gt;::iterator, std::map&lt;string, string&gt;::iterator&gt; myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">    <span class="comment">//通过遍历，输出 myPair 指定范围内的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="map获取键对应值的几种方法"><a href="#map获取键对应值的几种方法" class="headerlink" title="map获取键对应值的几种方法"></a>map获取键对应值的几种方法</h3><p>map 容器中存储的都是 pair 类型的键值对，但几乎在所有使用 map 容器的场景中，经常要做的不是找到指定的 pair 对象（键值对），而是从该容器中找到某个键对应的值。</p><blockquote><p>注意，使用 map 容器存储的各个键值对，其键的值都是唯一的，因此指定键对应的值最多有 1 个。</p></blockquote><ol><li>map 类模板中对<code>[ ]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</li></ol><p>注意，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 “”，即空字符串（即使用该类型的默认值作为键值对的值）。</p><ol start="2"><li>除了借助 [ ] 运算符获取 map 容器中指定键对应的值，还可以使用 at() 成员方法。和前一种方法相比，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出 out_of_range 异常。</li></ol><p>除了可以直接获取指定键对应的值之外，还可以借助 find() 成员方法间接实现此目的。和以上 2 种方式不同的是，该方法返回的是一个迭代器，即如果查找成功，该迭代器指向查找到的键值对；反之，则指向 map 容器最后一个键值对之后的位置（和 end() 成功方法返回的迭代器一样）。</p><hr><h3 id="map-insert-插入数据的4种方式"><a href="#map-insert-插入数据的4种方式" class="headerlink" title="map insert()插入数据的4种方式"></a>map insert()插入数据的4种方式</h3><p>除了使用 [ ] 运算符实现向 map 容器中添加新键值对外，map 类模板中还提供有 insert() 成员方法，该方法专门用来向 map 容器中插入新的键值对。</p><p>注意，这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整。</p><p>自 C++ 11 标准后，insert() 成员方法的用法大致有以下 4 种。</p><ol><li>无需指定插入位置，直接将键值对添加到 map 容器中。insert() 方法的语法格式有以下 2 种：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、引用传递一个键值对</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//2、以右值引用的方式传递键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">  <span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false。</li></ul><ol start="2"><li>除此之外，insert() 方法还支持向 map 容器的指定位置插入新键值对，该方法的语法格式如下</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 参数</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 键值对参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, P&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 val 为要插入的键值对变量。注意，和第 1 种方式的语法格式不同，这里 insert() 方法返回的是迭代器，而不再是 pair 对象：</p><ul><li><p>如果插入成功，insert() 方法会返回一个指向 map 容器中已插入键值对的迭代器；</p></li><li><p>如果插入失败，insert() 方法同样会返回一个迭代器，该迭代器指向 map 容器中和 val 具有相同键的那个键值对。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.<span class="built_in">insert</span>(it, STL);</span><br><span class="line">    cout &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.<span class="built_in">insert</span>(it, std::<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>));</span><br><span class="line">    cout &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>再次强调，即便指定了新键值对的插入位置，map 容器仍会对存储的键值对进行排序。也可以说，决定新插入键值对位于 map 容器中位置的，不是 insert() 方法中传入的迭代器，而是新键值对中键的值。</p><ol start="3"><li>insert() 方法还支持向当前 map 容器中插入其它 map 容器指定区域内的所有键值对，该方法的语法格式如下：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 first 和 last 都是迭代器，它们的组合<code>&lt;first,last&gt;</code>可以表示某 map 容器中的指定区域。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;mymap&#123; &#123;<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    std::map&lt;string, string&gt;::iterator first = ++mymap.<span class="built_in">begin</span>();</span><br><span class="line">    std::map&lt;string, string&gt;::iterator last = mymap.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.<span class="built_in">insert</span>(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.<span class="built_in">begin</span>(); iter != copymap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java教程 http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>程序中，&lt;first,last&gt; 指定的区域是从 mumap 容器第 2 个键值对开始，之后所有的键值对，所以 copymap 容器中包含有 2 个键值对。</p><ol start="4"><li>除了以上一种格式外，insert() 方法还允许一次向 map 容器中插入多个键值对，其语法格式为：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，vali 都表示的是键值对变量。</p><hr><h3 id="map容器operator-和insert-效率对比"><a href="#map容器operator-和insert-效率对比" class="headerlink" title="map容器operator[]和insert()效率对比"></a>map容器operator[]和insert()效率对比</h3><p>通过前面的学习我们知道，map 容器模板类中提供有 operator[ ] 和 insert() 这 2 个成员方法，而值得一提的是，这 2 个方法具有相同的功能，它们既可以实现向 map 容器中添加新的键值对元素，也可以实现更新（修改）map 容器已存储键值对的值。 举个例子（程序一）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::map&lt;string, string&gt; mymap;</span><br><span class="line">  <span class="comment">//借用 operator[] 添加新键值对</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Bear\&quot;,\&quot;deviceid\&quot;:\&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">string</span>(<span class="string">&quot;old mymap：&quot;</span>) &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 operator[] 更新某个键对应的值</span></span><br><span class="line">  mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new mymap：&quot;</span> &lt;&lt; mymap[<span class="string">&quot;player_01&quot;</span>] &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//借用insert()添加新键值对</span></span><br><span class="line">  std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;Javaplayer_02&quot;</span>,<span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;C++\&quot;,\&quot;deviceid\&quot;:\&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span> &#125;;</span><br><span class="line">  std::pair&lt;std::map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret;</span><br><span class="line">  ret = mymap.<span class="built_in">insert</span>(STL);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;old ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//借用 insert() 更新键值对</span></span><br><span class="line">  mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;node js&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;new ret.iter = &lt;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">old mymap：&#123;&quot;username&quot;:&quot;Bear&quot;,&quot;deviceid&quot;:&quot;baf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">new mymap：&#123;&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;</span></span><br><span class="line"><span class="comment">old ret.iter = &lt;&#123;Javaplayer_02, &#123;&quot;username&quot;:&quot;C++&quot;,&quot;deviceid&quot;:&quot;qaf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;&#125;&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">new ret.iter = &lt;Javaplayer_02, node js&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;**当实现“向 map <a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>中添加新键值对元素”的操作时，insert() 成员方法的执行效率更高；而在实现“更新 map 容器指定键值对的值”的操作时，operator[ ] 的效率更高。 **&#x3D;&#x3D;</p><h4 id="向map容器中增添元素，insert-效率更高"><a href="#向map容器中增添元素，insert-效率更高" class="headerlink" title="向map容器中增添元素，insert()效率更高"></a>向map容器中增添元素，insert()效率更高</h4><p>首先解释一下，为什么实现向 map 容器中添加新键值对元素，insert() 方法的执行效率比 operator[ ] 更高？回顾程序一中，如下语句完成了向空 mymap 容器添加新的键值对元素：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap[<span class="string">&quot;player_01&quot;</span>] = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>mymap[“player_01”] 实际上是 mymap.operator<a href="%E2%80%9CSTL%E6%95%99%E7%A8%8B%E2%80%9D"> </a> 的缩写（底层调用的 operator[ ] 方法），该方法会返回一个指向 “STL教程” 对应的 value 值的引用。 但需要注意的是，由于此时 mymap 容器是空的，并没有 “STL教程” 对应的 value 值。这种情况下，operator[ ] 方法会默认构造一个 string 对象，并将其作为 “STL教程” 对应的 value 值，然后返回一个指向此 string 对象的引用。在此基础上，代码还会将 “{&quot;username&quot;:&quot;Horse&quot;,&quot;deviceid&quot;:&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)&quot;}” 赋值给这个 string 对象。 也就是说，上面这行代码的执行流程，可以等效为如下程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;string, string&gt; mstr;</span><br><span class="line"><span class="comment">//创建要添加的默认键值对元素</span></span><br><span class="line">pair&lt;mstr::iterator, <span class="type">bool</span>&gt;res = mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;player_01&quot;</span>, <span class="built_in">string</span>()));</span><br><span class="line"><span class="comment">//将新键值对的值赋值为指定的值</span></span><br><span class="line">res.first-&gt;second = <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;Horse\&quot;,\&quot;deviceid\&quot;:\&quot;caf8700ac280467fcaf581520dc510ebf1c61c42_3400_MS - 7C02(Micro - Star International Co., Ltd)\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意，这里的 value_type(K,T) 指的是 map 容器中存储元素的类型，其实际上就等同于 pair&lt;K,T&gt;。</p><p>可以看到，使用 operator[ ] 添加新键值对元素的流程是，<strong>先构造一个有默认值的键值对，然后再为其 value 赋值</strong>。 那么，为什么不直接构造一个要添加的键值对元素呢，比如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(mstr::<span class="built_in">value_type</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;脱发严重&quot;</span>));</span><br></pre></td></tr></table></figure><p>它省略了创建临时 string 对象的过程以及析构该对象的过程，同时还省略了调用 string 类重载的赋值运算符。由于可见，同样是完成向 map 容器添加新键值对，insert() 方法比 operator[ ] 的执行效率更高。</p><h4 id="更新map容器中的键值对，operator-效率更高"><a href="#更新map容器中的键值对，operator-效率更高" class="headerlink" title="更新map容器中的键值对，operator[]效率更高"></a>更新map容器中的键值对，operator[]效率更高</h4><p>仍以程序一中的代码为例，如下分别是 operator[ ] 和 insert() 实现更新 mymap 容器中指定键对应的值的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//operator[]</span></span><br><span class="line">mymap[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;脱发&quot;</span>;</span><br><span class="line"><span class="comment">//insert()</span></span><br><span class="line">std::pair&lt;string, string&gt; STL = &#123; <span class="string">&quot;node&quot;</span>,<span class="string">&quot;霸王洗发水&quot;</span> &#125;;</span><br><span class="line">mymap.<span class="built_in">insert</span>(STL).first-&gt;second = <span class="string">&quot;还是霸王洗发水好&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>仅仅从语法形式本身来考虑，或许已经促使很多读者选择 operator[ ] 了。接下来，我们再从执行效率的角度对比以上 2 种实现方式。从上面代码可以看到，insert() 方法在进行更新操作之前，需要有一个 pair 类型（也就是 map::value_type 类型）元素做参数。这意味着，该方法要多构造一个 pair 对象（附带要构造 2 个 string 对象），并且事后还要析构此 pair 对象（附带 2 个 string 对象的析构）。而和 insert() 方法相比，operator[ ] 就不需要使用 pair 对象，自然不需要构造（并析构）任何 pair 对象或者 string 对象。因此，对于更新已经存储在 map 容器中键值对的值，应优先使用 operator[ ] 方法。</code></p><h3 id="map-emplace-和emplace-hint-方法详解"><a href="#map-emplace-和emplace-hint-方法详解" class="headerlink" title="map emplace()和emplace_hint()方法详解"></a>map emplace()和emplace_hint()方法详解</h3><p><a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> map 类模板中还提供了 emplace() 和 emplace_hint() 成员函数，也可以实现向 map 容器中插入新的键值对。本节就来讲解这 2 个成员方法的用法。</p><p>值得一提的是，实现相同的插入操作，无论是用 emplace() 还是 emplace_hont()，都比 insert() 方法的效率高（后续章节会详细讲解）。</p><p>和 insert() 方法相比，emplace() 和 emplace_hint() 方法的使用要简单很多，因为它们各自只有一种语法格式。其中，emplace() 方法的语法格式如下：</p><p>template &lt;class… Args&gt;<br> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;… args);</p><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li><li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//插入键值对</span></span><br><span class="line">    pair&lt;map&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入新键值对</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//失败插入的样例</span></span><br><span class="line">    ret = mymap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">2、ret.iter = &lt;&#123;C语言教程, http://c.biancheng.net/c/&#125;, 1&gt;</span></span><br><span class="line"><span class="comment">3、ret.iter = &lt;&#123;STL教程, http://c.biancheng.net/stl/&#125;, 0&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，程序中共执行了 3 次向 map 容器插入键值对的操作，其中前 2 次都成功了，第 3 次由于要插入的键值对的键和 map 容器中已存在的键值对的键相同，因此插入失败。</p><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">  <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ol><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ol><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    std::map&lt;string, string&gt;mymap;</span><br><span class="line">    <span class="comment">//指定在 map 容器插入键值对</span></span><br><span class="line">    map&lt;string, string&gt;::iterator iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(),<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    iter = mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">C语言教程 http://c.biancheng.net/c/</span></span><br><span class="line"><span class="comment">STL教程 http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p><p>那么，为什么 emplace() 和 emplace_hint() 方法的执行效率，比 insert() 高呢？</p><p><strong>C++11新增的emplace() 和 emplace_hint()都比insert效率高</strong></p><p>使用 insert() 向 map 容器中插入键值对的过程是，先创建该键值对，然后再将该键值对复制或者移动到 map 容器中的指定位置；</p><p>使用 emplace() 或 emplace_hint() 插入键值对的过程是，直接在 map 容器中的指定位置构造该键值对。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testDemo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="type">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器</span></span><br><span class="line">    std::map&lt;std::string, testDemo&gt;mymap;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="built_in">testDemo</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace</span>( <span class="string">&quot;http://c.biancheng.net/stl/:&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_hint():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mymap.<span class="built_in">emplace_hint</span>(mymap.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">调用移动构造函数</span></span><br><span class="line"><span class="comment">emplace():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">emplace_hint():</span></span><br><span class="line"><span class="comment">调用构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>在使用 insert() 方法向 map 容器插入键值对时，整个插入过程调用了 1 次 tempDemo 类的构造函数，同时还调用了 2次移动构造函数。实际上，程序第 28 行代码底层的执行过程，可以分解为以下 3 步：</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造类对象</span></span><br><span class="line">testDemo val = <span class="built_in">testDemo</span>(<span class="number">1</span>); <span class="comment">//调用 1 次构造函数</span></span><br><span class="line"><span class="comment">//构造键值对</span></span><br><span class="line"><span class="keyword">auto</span> pai = <span class="built_in">make_pair</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>, val); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"><span class="comment">//完成插入操作</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(pai); <span class="comment">//调用 1 次移动构造函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>而完成同样的插入操作，emplace() 和 emplace_hint() 方法都只调用了 1 次构造函数，这足以证明，这 2 个方法是在map 容器内部直接构造的键值对。</strong></p><p>因此，<strong>在实现向 map 容器中插入键值对时，应优先考虑使用 emplace() 或者 emplace_hint()。</strong></p><hr><h2 id="multimap容器用法完全攻略"><a href="#multimap容器用法完全攻略" class="headerlink" title="multimap容器用法完全攻略"></a>multimap容器用法完全攻略</h2><p>掌握 <a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> map 容器的基础上，本节再讲一个和 map 相似的关联式容器，即 multimap 容器。</p><p>所谓“相似”，指的是 multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，<strong>multimap 容器中可以同时存储多（≥2）个键相同的键值对。</strong></p><p>和 map 容器一样，实现 multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件，并位于 std 命名空间中。因此，在使用 multimap 容器前，程序应包含如下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>multimap 容器类模板的定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                                   <span class="comment">// 指定键（key）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                                     <span class="comment">// 指定值（value）的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Compare</span> = less&lt;Key&gt;,                   <span class="comment">// 指定排序规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt;pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> multimap;</span><br></pre></td></tr></table></figure><h3 id="创建C-multimap容器的方法"><a href="#创建C-multimap容器的方法" class="headerlink" title="创建C++ multimap容器的方法"></a>创建C++ multimap容器的方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multimap&lt;std::string, std::string&gt;mymultimap;</span><br><span class="line"><span class="comment">//通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="comment">/*使用此方式初始化 multimap 容器时，其底层会先将每一个&#123;key, value&#125;创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：*/</span></span><br><span class="line"><span class="comment">//借助 pair 类模板的构造函数来生成各个pair类型的键值对</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    pair&lt;string,string&gt;&#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">    pair&lt;string,string&gt;&#123; <span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 make_pair() 函数，生成键值对元素</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(mymultimap);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。*/</span></span><br><span class="line"><span class="comment">//创建一个会返回临时 multimap 对象的函数</span></span><br><span class="line"><span class="function">multimap&lt;string, string&gt; <span class="title">dismultimap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    multimap&lt;string, string&gt;tempmultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,&#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 multimap 类模板的移动构造函数创建 newMultimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(<span class="built_in">dismultimap</span>());</span><br><span class="line"><span class="comment">/*上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数。</span></span><br><span class="line"><span class="comment">注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。*/</span></span><br><span class="line"><span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">multimap&lt;string, string&gt;mymultimap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>&#125; &#125;;</span><br><span class="line">multimap&lt;string, string&gt;<span class="built_in">newmultimap</span>(++mymultimap.<span class="built_in">begin</span>(), mymultimap.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为std::less&lt;T&gt;，这意味着以下 2 种创建 multimap 容器的方式是等价的：*/</span></span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">int</span>, std::less&lt;<span class="type">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="C-multimap容器包含的成员方法"><a href="#C-multimap容器包含的成员方法" class="headerlink" title="C++ multimap容器包含的成员方法"></a>C++ multimap容器包含的成员方法</h3><p>列出了 multimap 类模板提供的常用成员方法及各自的功能。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 multimap 容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>insert()</td><td>向 multimap 容器中插入键值对。</td></tr><tr><td>erase()</td><td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(key)</td><td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。</td></tr></tbody></table><p>&#x3D;&#x3D;和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。&#x3D;&#x3D;这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p><p><code>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到。</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>  <span class="comment">//map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    multimap&lt;<span class="type">char</span>, <span class="type">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    cout &lt;&lt; mymultimap.<span class="built_in">count</span>(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.<span class="built_in">begin</span>(); iter != mymultimap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">a 10</span></span><br><span class="line"><span class="comment">b 20</span></span><br><span class="line"><span class="comment">b 15</span></span><br><span class="line"><span class="comment">c 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="STL-set"><a href="#STL-set" class="headerlink" title="STL set"></a>STL set</h2><p>前面章节讲解了 map 容器和 multimap 容器的用法，类似地，<a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> 标准库中还提供有 set 和 multiset 这 2 个容器，它们也属于关联式容器。不过，本节先讲解 set 容器，后续章节再讲解 multiset 容器。</p><p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p><p>举个例子，如下有 2 组键值对数据：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>&gt;&#125;</span><br><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p><p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p><p>通过前面的学习我们知道，map、multimap 容器都会自行根据键的大小对存储的键值对进行排序，set 容器也会如此，只不过 set 容器中各键值对的键 key 和值 value 是相等的，根据 key 排序，也就等价为根据 value 排序。</p><p>另外，使用 set 容器存储的各个元素的值必须各不相同。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</p><p><code>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</code></p><h3 id="创建C-set容器的几种方法"><a href="#创建C-set容器的几种方法" class="headerlink" title="创建C++ set容器的几种方法"></a>创建C++ set容器的几种方法</h3><ol><li>调用默认构造函数，创建空的 set 容器。比如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset;</span><br></pre></td></tr></table></figure><blockquote><p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p></blockquote><p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p><ol start="2"><li>除此之外，set 类模板还支持在创建 set 容器的同时，对其进行初始化。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123;<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 myset 容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</T></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>set 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 set 容器的同时，将已有 set 容器中存储的所有元素全部复制到新 set 容器中。</li></ol><p>例如，在第 2 种方式创建的 myset 容器的基础上，执行如下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;<span class="comment">//等同于//std::set&lt;std::string&gt; copyset = myset</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copyset 容器的基础上，还会将 myset 容器中存储的所有元素，全部复制给 copyset 容器一份。</p><p>另外，C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">set&lt;string&gt; <span class="title">retSet</span><span class="params">()</span> </span>&#123;    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;    <span class="keyword">return</span> myset;&#125;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(retSet())</span></span>;<span class="comment">//或者//std::set&lt;std::string&gt; copyset = retSet();</span></span><br></pre></td></tr></table></figure><p>注意，由于 retSet() 函数的返回值是一个临时 set 容器，因此在初始化 copyset 容器时，其内部调用的是 set 类模板中的移动构造函数，而非拷贝构造函数。</p><blockquote><p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><ol start="4"><li>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;<span class="function">std::set&lt;std::string&gt; <span class="title">copyset</span><span class="params">(++myset.begin(), myset.end())</span></span>;</span><br></pre></td></tr></table></figure><p>由此初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br></pre></td></tr></table></figure><ol start="5"><li>以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;std::string,std::greater&lt;string&gt; &gt; myset&#123;    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过选用 std::greater<string> 降序规则，myset 容器中元素的存储顺序为:</string></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;http://c.biancheng.net/stl/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">&quot;http://c.biancheng.net/java/&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="C-STL-set容器包含的成员方法"><a href="#C-STL-set容器包含的成员方法" class="headerlink" title="C++ STL set容器包含的成员方法"></a>C++ STL set容器包含的成员方法</h3><p> 列出了 set 容器提供的常用成员方法以及各自的功能。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 set 容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>insert()</td><td>向 set 容器中插入元素。</td></tr><tr><td>erase()</td><td>删除 set 容器中存储的元素。</td></tr><tr><td>swap()</td><td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(val)</td><td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、myset size = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/java/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure><hr><h3 id="set容器迭代器"><a href="#set容器迭代器" class="headerlink" title="set容器迭代器"></a>set容器迭代器</h3><p>和 map 容器不同，<a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</p><p>值得一提的是，C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 &#x3D;&#x3D; 或者 !&#x3D; 运算符。</p><p>在 set 容器类模板提供的所有成员函数中，返回迭代器的成员函数如表 1 所示。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td></tr></tbody></table><blockquote><p>注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p></blockquote><p>图 2 演示了表 1 中除最后 4 个成员函数外，其它几个成员函数的具体功能。</p><p><img src="/../typora-user-images/set.png" alt="2-19112Q14QE40-1710858859716-3"></p><p>下面程序以 begin()&#x2F;end() 为例，演示了如何使用图 2 中相关迭代器遍历 set 容器：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://c.biancheng.net/java/</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line">http://c.biancheng.net/stl/</span><br></pre></td></tr></table></figure><p><code>如程序第 15 行代码所示的那样，因为 iter 迭代器指向的是 set 容器存储的某个元素，而不是键值对，因此通过 *iter 可以直接获取该迭代器指向的元素的值。</code></p><p>除此之外，如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。</p><p>需要特别指出的是，equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">find</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;iter != myset.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">http:<span class="comment">//c.biancheng.net/stl/</span></span><br></pre></td></tr></table></figure><p><code>值得一提的是，虽然 C++ STL 标准中，set 类模板中包含 lower_bound()、upper_bound()、equal_range() 这 3 个成员函数，但它们更适用于 multiset 容器，几乎不会用于操作 set 容器。</code></p><hr><h3 id="set-insert-方法"><a href="#set-insert-方法" class="headerlink" title="set insert()方法"></a>set insert()方法</h3><p>我们已经学会如何创建一个 set 容器。在此基础上，如果想向 set 容器中继续添加元素，可以借助 set 类模板提供的 insert() 方法。</p><p>为满足不同场景的需要，<a href="https://c.biancheng.net/cplus/">C++</a> 11 标准的 set 类模板中提供了多种不同语法格式的 insert() 成员方法，它们各自的功能和用法如下所示。</p><ol><li>只要给定目标元素的值，insert() 方法即可将该元素添加到 set 容器中，其语法格式如下：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//右值引用方式传参</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，val 表示要添加的新元素，该方法的返回值为 pair 类型。</p><p>可以看到，以上 2 种语法格式的 insert() 方法，返回的都是 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    pair&lt;set&lt;string&gt;::iterator, <span class="type">bool</span>&gt; retpair;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    retpair = myset.<span class="built_in">insert</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *(retpair.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;bool = &quot;</span> &lt;&lt; retpair.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/stl/ bool = 1</span></span><br><span class="line"><span class="comment">iter-&gt;http://c.biancheng.net/python/ bool = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>insert() 还可以指定将新元素插入到 set 容器中的具体位置，其语法格式如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以普通引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递 val 值</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, value_type&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>以上 2 种语法格式中，insert() 函数的返回值为迭代器：</p><ul><li><p>当向 set 容器添加元素成功时，该迭代器指向容器中新添加的元素；</p></li><li><p>当添加失败时，证明原 set 容器中已有相同的元素，该迭代器就指向 set 容器中相同的这个元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//准备接受 insert() 的返回值</span></span><br><span class="line">    set&lt;string&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//采用普通引用传值方式</span></span><br><span class="line">    string str = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">begin</span>(),str);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//采用右值引用传值方式</span></span><br><span class="line">    iter = myset.<span class="built_in">insert</span>(myset.<span class="built_in">end</span>(),<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size =&quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*myset size =1</span></span><br><span class="line"><span class="comment">myset size =2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>注意，使用 insert() 方法将目标元素插入到 set 容器指定位置后，如果该元素破坏了容器内部的有序状态，set 容器还会自行对新元素的位置做进一步调整。也就是说，insert() 方法中指定新元素插入的位置，并不一定就是该元素最终所处的位置。</code></p><ol start="3"><li>insert() 方法支持向当前 set 容器中插入其它 set 容器指定区域内的所有元素，只要这 2 个 set 容器存储的元素类型相同即可。</li></ol></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//创建一个同类型的空 set 容器</span></span><br><span class="line">    std::set&lt;std::string&gt; otherset;</span><br><span class="line">    <span class="comment">//利用 myset 初始化 otherset</span></span><br><span class="line">    otherset.<span class="built_in">insert</span>(++myset.<span class="built_in">begin</span>(), myset.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//输出 otherset 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = otherset.<span class="built_in">begin</span>(); iter != otherset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意，程序第 15 行在初始化 otherset 容器时，选取的是 myset 容器中从第 2 个元素开始（包括此元素）直到容器末尾范围内的所有元素，所以程序输出结果中只有 2 个字符串。</p><ol start="4"><li>采用如下格式的 insert() 方法，可实现一次向 set 容器中添加多个元素：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">( &#123;E1, E2,...,En&#125; )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化set容器</span></span><br><span class="line">    std::set&lt;std::string&gt; myset;</span><br><span class="line">    <span class="comment">//向 myset 中添加多个元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(&#123; <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/java/&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.<span class="built_in">begin</span>(); iter != myset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/java/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/python/</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即为 set 类模板中 insert() 成员方法的全部用法。指的一提的是，C++ 11 标准的 set 类模板中，还提供有另外 2 个成员方法，分别为 implace() 和 implace_hint() 方法，借助它们不但能实现向 set 容器添加新元素的功能，其实现效率也比 insert() 成员方法更高。</p><hr><h3 id="set-emplace-和emplace-hint"><a href="#set-emplace-和emplace-hint" class="headerlink" title="set emplace()和emplace_hint()"></a>set emplace()和emplace_hint()</h3><p>下面程序演示 emplace() 方法的具体用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//向 myset 容器中添加元素</span></span><br><span class="line">    pair&lt;set&lt;string, string&gt;::iterator, <span class="type">bool</span>&gt; ret = myset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret.iter = &lt;&quot;</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">ret.iter = &lt;http://c.biancheng.net/stl/, 1&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>显然，从执行结果可以看出，通过调用 emplace() 方法，成功向空 myset 容器中添加了一个元素，并且该方法的返回值中就包含指向新添加元素的迭代器。</p><p>emplace_hint() 方法的功能和 emplace() 类似</p><p>下面程序演示 emplace_hint() 方法的用法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;string&gt;myset;</span><br><span class="line">    <span class="comment">//在 set 容器的指定位置添加键值对</span></span><br><span class="line">    set&lt;string&gt;::iterator iter = myset.<span class="built_in">emplace_hint</span>(myset.<span class="built_in">begin</span>(), <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">myset size = 1</span></span><br><span class="line"><span class="comment">http://c.biancheng.net/stl/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上内容讲解了 emplace() 和 emplace_hint() 的用法，至于比 insert() 执行效率高的原因，可参照 map 容器 emplace() 和 emplace_hint() 比 insert() 效率高的原因，它们是完全一样的，这里不再赘述。</p><h3 id="set删除数据：erase-和clear"><a href="#set删除数据：erase-和clear" class="headerlink" title="set删除数据：erase()和clear()"></a>set删除数据：erase()和clear()</h3><p>如果想删除 set 容器存储的元素，可以选择用 erase() 或者 clear() 成员方法。</p><p>set 类模板中，erase() 方法有 3 种语法格式，分别如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除 set 容器中值为 val 的元素</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//删除 position 迭代器指向的元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="comment">//删除 [first,last) 区间内的所有元素</span></span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，第 1 种格式的 erase() 方法，其返回值为一个整数，表示成功删除的元素个数；后 2 种格式的 erase() 方法，返回值都是迭代器，其指向的是 set 容器中删除元素之后的第一个元素。</p><blockquote><p>注意，如果要删除的元素就是 set 容器最后一个元素，则 erase() 方法返回的迭代器就指向新 set 容器中最后一个元素之后的位置（等价于 end() 方法返回的迭代器）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 set 容器</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt;myset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1) 调用第一种格式的 erase() 方法</span></span><br><span class="line">    <span class="type">int</span> num = myset.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除元素 2，myset=&#123;1,3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2) 调用第二种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>()); <span class="comment">//删除元素 1，myset=&#123;3,4,5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter-&gt;&quot;</span> &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//3) 调用第三种格式的 erase() 方法</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter2 = myset.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());<span class="comment">//删除元素 3,4，myset=&#123;5&#125;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3、myset size = &quot;</span> &lt;&lt; myset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iter2-&gt;&quot;</span> &lt;&lt; *iter2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myset size = <span class="number">5</span></span><br><span class="line"><span class="number">1</span>、myset size = <span class="number">4</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="number">2</span>、myset size = <span class="number">3</span></span><br><span class="line">iter-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>、myset size = <span class="number">1</span></span><br><span class="line">iter2-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><p>如果需要删除 set 容器中存储的所有元素，可以使用 clear() 成员方法。该方法的语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h2><p>对 set 容器做了详细的讲解。回忆一下，set 容器具有以下几个特性：</p><ul><li>不再以键值对的方式存储数据，因为 set 容器专门用于存储键和值相等的键值对，因此该容器中真正存储的是各个键值对的值（value）；</li><li>set 容器在存储数据时，会根据各元素值的大小对存储的元素进行排序（默认做升序排序）；</li><li>存储到 set 容器中的元素，虽然其类型没有明确用 const 修饰，但正常情况下它们的值是无法被修改的；</li><li>set 容器存储的元素必须互不相等。</li></ul><p>在此基础上，<a href="https://c.biancheng.net/cplus/">C++</a> <a href="https://c.biancheng.net/stl/">STL</a> 标准库中还提供有一个和 set 容器相似的关联式容器，即 multiset 容器。所谓“相似”，是指 multiset 容器遵循 set 容器的前 3 个特性，仅在第 4 条特性上有差异。和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。</p><p><code>也就是说，multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。</code></p><h3 id="创建C-multiset容器的方法"><a href="#创建C-multiset容器的方法" class="headerlink" title="创建C++ multiset容器的方法"></a>创建C++ multiset容器的方法</h3><p>multiset 类模板中提供了 5 种构造函数，也就代表有 5 种创建 multiset 容器的方式</p><ol><li>调用默认构造函数，创建空的 multiset 容器。比如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset;</span><br></pre></td></tr></table></figure><blockquote><p>如果程序中已经默认指定了 std 命令空间，这里可以省略 std::。</p></blockquote><p>由此就创建好了一个 mymultiset 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。</p><blockquote><p>注意，由于 multiset 容器支持随时向内部添加新的元素，因此创建空 multiset 容器的方法比较常用。</p></blockquote><ol start="2"><li>除此之外，multiset 类模板还支持在创建 multiset 容器的同时，对其进行初始化。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>由此即创建好了包含 3 个 string 元素的 mymultiset 容器。由于其采用默认的<code>std::less&lt;T&gt;</code>规则，因此其内部存储 string 元素的顺序如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/java/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>multiset 类模板中还提供了拷贝（复制）构造函数，可以实现在创建新 multiset 容器的同时，将已有 multiset 容器中存储的所有元素全部复制到新 multiset 容器中。</li></ol><p>例如，在第 2 种方式创建的 mymultiset 容器的基础上，执行如下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::multiset&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(mymultiset)</span></span>;<span class="comment">//等同于//std::multiset&lt;std::string&gt; copymultiset = mymultiset;</span></span><br></pre></td></tr></table></figure><p>该行代码在创建 copymultiset 容器的基础上，还会将 mymultiset 容器中存储的所有元素，全部复制给 copymultiset 容器一份。</p><p>另外，C++ 11 标准还为 multiset 类模板新增了移动构造函数，其功能是实现创建新 multiset 容器的同时，利用临时的 multiset 容器为其初始化。比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">multiset&lt;string&gt; <span class="title">retMultiset</span><span class="params">()</span> </span>&#123;    std::multiset&lt;std::string&gt; tempmultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                            <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;    <span class="keyword">return</span> tempmultiset;&#125;<span class="function">std::multiset&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(retMultiset())</span></span>;<span class="comment">//等同于//std::multiset&lt;std::string&gt; copymultiset = retMultiset();</span></span><br></pre></td></tr></table></figure><p>注意，由于 retMultiset() 函数的返回值是一个临时 multiset 容器，因此在初始化 copymultiset 容器时，其内部调用的是 multiset 类模板中的移动构造函数，而非拷贝构造函数。</p><blockquote><p>显然，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致。</p></blockquote><ol start="4"><li>在第 3 种方式的基础上，multiset 类模板还支持取已有 multiset 容器中的部分元素，来初始化新 multiset 容器。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; mymultiset&#123; <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,                                       <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;<span class="function">std::set&lt;std::string&gt; <span class="title">copymultiset</span><span class="params">(++mymultiset.begin(), mymultiset.end())</span></span>;</span><br></pre></td></tr></table></figure><p>以上初始化的 copyset 容器，其内部仅存有如下 2 个 string 字符串：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>以上几种方式创建的 multiset 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 multiset 类模板定义中的第 2 个参数，我们完全可以手动修改 multiset 容器中的排序规则。</li></ol><p>下面样例中，使用了 STL 标准库提供的 std::greater<T> 排序方法，作为 multiset 容器内部的排序规则：</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string, std::greater&lt;string&gt; &gt; mymultiset&#123;    <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>,    <span class="string">&quot;http://c.biancheng.net/python/&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过选用<code>std::greater&lt;string&gt;</code>降序规则，mymultiset 容器中元素的存储顺序为:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;http://c.biancheng.net/stl/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="string">&quot;http://c.biancheng.net/java/&quot;</span></span><br></pre></td></tr></table></figure><h3 id="C-multiset容器提供的成员方法"><a href="#C-multiset容器提供的成员方法" class="headerlink" title="C++ multiset容器提供的成员方法"></a>C++ multiset容器提供的成员方法</h3><p>multiset 容器提供的成员方法，和 set 容器提供的完全一样.</p><p><code>注意，虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; mymultiset&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset size = &quot;</span> &lt;&lt; mymultiset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multiset count(2) =&quot;</span> &lt;&lt; mymultiset.<span class="built_in">count</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//向容器中添加元素 8</span></span><br><span class="line">    mymultiset.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//删除容器中所有值为 2 的元素</span></span><br><span class="line">    <span class="type">int</span> num = mymultiset.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除了 &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 个元素 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出容器中存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultiset.<span class="built_in">begin</span>(); iter != mymultiset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiset size = <span class="number">7</span></span><br><span class="line">multiset <span class="built_in">count</span>(<span class="number">2</span>) =<span class="number">3</span></span><br><span class="line">删除了 <span class="number">3</span> 个元素 <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><hr><h2 id="STL关联式容器自定义排序规则【函数对象】"><a href="#STL关联式容器自定义排序规则【函数对象】" class="headerlink" title="STL关联式容器自定义排序规则【函数对象】"></a>STL关联式容器自定义排序规则【函数对象】</h2><h3 id="1-使用函数对象"><a href="#1-使用函数对象" class="headerlink" title="1 - 使用函数对象"></a>1 - 使用函数对象</h3><p>无论关联式容器中存储的是基础类型（如 int、double、float 等）数据，还是自定义的结构体变量或类对象（包括 string 类），都可以使用<strong>函数对象</strong>的方式为该容器自定义排序规则。</p><p>如果一个类将<code>()</code>运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。</p><p>参考：<a href="http://c.biancheng.net/view/354.html">C++函数对象详解（附带实例）</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAverage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">average</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>()</code>是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</p><p><img src="/../typora-user-images/class.png" alt="函数对象类模板"></p><p>例如，如果要求两个 double 型变量 x、y 的乘积，可以写</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiplies</span>&lt;<span class="type">double</span>&gt; () (x, y)<span class="comment">//首先用multiplies实例化了一个暂时的对象，构造该对象时传入参数x y</span></span><br></pre></td></tr></table></figure><p>less 是 STL 中最常用的函数对象类模板，其定义如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(const_Tp &amp; __x, const_Tp &amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：</span></span><br><span class="line"><span class="comment">//if( less&lt;int&gt;()(x, y) ) &#123; 操作 &#125;</span></span><br></pre></td></tr></table></figure><p>常用的可供关联容器使用的排序规则为</p><p><img src="/../typora-user-images/so.png" alt="在这里插入图片描述"></p><h3 id="2-重载关系运算符实现自定义排序"><a href="#2-重载关系运算符实现自定义排序" class="headerlink" title="2 - 重载关系运算符实现自定义排序"></a>2 - 重载<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">关系运算符</a>实现自定义排序</h3><p>当关联式容器中存储的数据类型为自定义的结构体变量或者类对象时，通过对现有排序规则中所用的关系运算符进行重载，也能实现自定义排序规则的目的。</p><blockquote><p>注意，当关联式容器中存储的元素类型为<strong>结构体指针变量或者类的指针对象</strong>时，只能使用函数对象的方式自定义排序规则，此方法不再适用。</p></blockquote><hr><h2 id="如何修改关联式容器中键值对的键"><a href="#如何修改关联式容器中键值对的键" class="headerlink" title="如何修改关联式容器中键值对的键"></a>如何修改关联式容器中键值对的键</h2><p>首先可以明确的是，map 和 multimap 容器只能采用“先删除，再添加”的方式修改某个键值对的键。原因很简单，C++ STL 标准中明确规定，map 和 multimap 容器用于存储类型为 pair 的键值对。显然，只要目标键值对存储在当前容器中，键的值就无法被修改。</p><p>直接修改 map 或 multimap 容器中某个键值对的键是行不通的。但对于 set 或者 multiset 容器来说，却是可行的。</p><p>和 map、multimap 不同，C++ STL 标准中并没有用 const 限定 set 和 multiset 容器中存储元素的类型。换句话说，对于 set 或者 multiset 类型的容器，其存储元素的类型是 T 而不是 const T。</p><p>对 set 和 multiset 容器中的元素类型作 const 修饰，是违背常理的。举个例子，假设我们使用 set 容器存储多个学生信息，如下是一个表示学生的类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">student</span>(string name, <span class="type">int</span> id, <span class="type">int</span> age) :<span class="built_in">name</span>(name), <span class="built_in">id</span>(id), <span class="built_in">age</span>(age) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">getid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(<span class="type">const</span> string name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getname</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setage</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getage</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建 set 容器之前，我们还需要为其设计一个排序规则，这里假定以每个学生的 id 做升序排序，其排序规则如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> student &amp;stua, <span class="type">const</span> student &amp;stub)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符串的长度，做升序排序(即存储的字符串从短到长)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stua.<span class="built_in">getid</span>() &lt; stub.<span class="built_in">getid</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>做完以上所有的准备工作后，就可以创建一个可存储 student 对象的 set 容器了，比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set myset&#123; &#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>,<span class="number">21</span>&#125;,&#123;<span class="string">&quot;wangwu&quot;</span>,<span class="number">15</span>,<span class="number">19</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>由此创建的 myset 容器中，存储的数据依次为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>,<span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;wangwu&quot;</span>,<span class="number">15</span>,<span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>,<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><p>注意，set 容器中每个元素也可以看做是键和值相等的键值对，但对于这里的 myset 容器来说，其实每个 student 对象的 id 才是真正的键，其它信息(name 和 age)只不过是和 id 绑定在一起而已。因此，在不破坏 myset 容器中元素的有序性的前提下(即不修改每个学生的 id)，学生的其它信息是应该允许修改的，但有一个前提，即 myset 容器中存储的各个 student 对象不能被 const 修饰(这也是 set 容器中的元素类型不能被 const 修饰的原因)。</p><p>总之，set 和 multiset 容器的元素类型没有用 const 修饰。所以从语法的角度分析，&#x3D;&#x3D;我们可以直接修改容器中元素的值，但一定不要修改元素的键。&#x3D;&#x3D;</p><p>在已创建好的 myset 容器的基础上，如下代码尝试修改 myset 容器中某个学生的 name 名字：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set::iterator iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">(*iter).<span class="built_in">setname</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br></pre></td></tr></table></figure><p>它也是无法通过编译的。</p><p>虽然 C++ STL 标准没有用 const 修饰 set 或者 multiset 容器中元素的类型，但也做了其它工作来限制用户修改容器的元素。例如上面代码中，***iter 会调用 *operator，其返回的是一个 const T&amp; 类型元素。**这意味着，C++ STL 标准不允许用户借助迭代器来直接修改 set 或者 multiset 容器中的元素。<br>如何才能正确修改 set 或 multiset 容器中的元素呢？最直接的方式就是借助 const_cast运算符，该运算符可以去掉指针或者引用的 const 限定符。</p><p>比如，我们只需要借助 const_cast 运算符对上面程序稍作修改，就可以运行成功：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set::iterator iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">const_cast</span>(*iter).<span class="built_in">setname</span>(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此，mymap 容器中的 {“zhangsan”,10,20} 就变成了 {“xiaoming”,10,20}。</p><p>再次强调，&#x3D;&#x3D;虽然使用 const_cast 能直接修改 set 或者 multiset 容器中的元素，但一定不要修改元素的键！&#x3D;&#x3D;如果要修改，只能采用“先删除，再添加”的方式。另外，不要试图以同样的方式修改 map 或者 multimap 容器中键值对的键，这违反了 C++ STL 标准的规定。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，map 和 multimap 容器中元素的键是无法直接修改的，但借助 const_cast，我们可以直接修改 set 和 multiset 容器中元素的非键部分。</p><hr><h1 id="STL无序关联式容器"><a href="#STL无序关联式容器" class="headerlink" title="STL无序关联式容器"></a>STL无序关联式容器</h1><p>除了序列式容器和关联式容器之外，C++ 11 标准库又引入了一类容器，即无序关联式容器。</p><p>无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。</p><p>和其它类容器相比，无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。</p><h2 id="STL无序容器（哈希容器）是什么？"><a href="#STL无序容器（哈希容器）是什么？" class="headerlink" title="STL无序容器（哈希容器）是什么？"></a>STL无序容器（哈希容器）是什么？</h2><p>继 <strong>map、multimap、set、multiset</strong> 关联式容器之后，从本节开始，再讲解一类“特殊”的关联式容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。</p><p>&#x3D;&#x3D;注意，无序容器是 <a href="https://c.biancheng.net/cplus/">C++</a> 11 标准才正式引入到 <a href="https://c.biancheng.net/stl/">STL</a> 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。&#x3D;&#x3D;</p><p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，因为它们有本质上的不同：</p><ul><li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li><li>无序容器的底层实现采用的是哈希表的存储结构。</li></ul><p><code>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。</code></p><p>基于底层实现采用了不同的<a href="https://c.biancheng.net/data_structure/">数据结构</a>，因此和关联式容器相比，无序容器具有以下 2 个特点：</p><ol><li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li><li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ol><h3 id="C-STL无序容器种类"><a href="#C-STL无序容器种类" class="headerlink" title="C++ STL无序容器种类"></a>C++ STL无序容器种类</h3><p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为<strong>unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</strong></p><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr><tr><td>unordered_multiset</td><td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td></tr></tbody></table><p>以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了 “unordered_”。即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会。</p><p>既然无序容器和之前所学的关联式容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</p><h2 id="unordered-map容器"><a href="#unordered-map容器" class="headerlink" title="unordered_map容器"></a>unordered_map容器</h2><p>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p><p>unordered_map 容器模板的定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>,                        <span class="comment">//键值对中键的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">T</span>,                          <span class="comment">//键值对中值的类型</span></span><br><span class="line">           <span class="keyword">class</span> <span class="title class_">Hash</span> = hash&lt;Key&gt;,           <span class="comment">//容器内部存储键值对所用的哈希函数</span></span><br><span class="line">           <span class="keyword">class</span> Pred = equal_to&lt;Key&gt;,       <span class="comment">//判断各个键值对键相同的规则</span></span><br><span class="line">           <span class="keyword">class</span> Alloc = allocator&lt; pair&lt;<span class="type">const</span> Key,T&gt; &gt;  <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="keyword">class</span> unordered_map;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>&lt;key,T&gt;</td><td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td></tr><tr><td>Hash &#x3D; hash<Key></Key></td><td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</key></td></tr><tr><td>Pred &#x3D; equal_to<Key></Key></td><td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 &#x3D;&#x3D; 运算符做比较的数据类型。</key></td></tr></tbody></table><blockquote><p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。至于如何实现自定义，后续章节会做详细讲解。</p></blockquote><h3 id="创建C-unordered-map容器的方法"><a href="#创建C-unordered-map容器的方法" class="headerlink" title="创建C++ unordered_map容器的方法"></a>创建C++ unordered_map容器的方法</h3><ol><li>通过调用 unordered_map 模板类的默认构造函数，可以创建空的 unordered_map 容器。比如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap;</span><br></pre></td></tr></table></figure><p>由此，就创建好了一个可存储 &lt;string,string&gt; 类型键值对的 unordered_map 容器。</p><ol start="2"><li>当然，在创建 unordered_map 容器的同时，可以完成初始化操作。比如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::string&gt; umap&#123;    &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,    &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,    &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>通过此方法创建的 umap 容器中，就包含有 3 个键值对元素。</p><ol start="3"><li>另外，还可以调用 unordered_map 模板中提供的复制（拷贝）构造函数，将现有 unordered_map 容器中存储的键值对，复制给新建 unordered_map 容器。</li></ol><p>例如，在第二种方式创建好 umap 容器的基础上，再创建并初始化一个 umap2 容器：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unordered_map&lt;std::string, std::string&gt; <span class="title">umap2</span><span class="params">(umap)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，umap2 容器中就包含有 umap 容器中所有的键值对。</p><p>除此之外，C++ 11 标准中还向 unordered_map 模板类增加了移动构造函数，即以右值引用的方式将临时 unordered_map 容器中存储的所有键值对，全部复制给新建容器。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回临时 unordered_map 容器的函数</span></span><br><span class="line">std::unordered_map &lt;std::string, std::string &gt; <span class="built_in">retUmap</span>()&#123;    std::unordered_map&lt;std::string, std::string&gt;tempUmap&#123;        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;    <span class="keyword">return</span> tempUmap;&#125;<span class="comment">//调用移动构造函数，创建 umap2 容器std::unordered_map&lt;std::string, std::string&gt; umap2(retUmap());</span></span><br></pre></td></tr></table></figure><p>注意，无论是调用复制构造函数还是拷贝构造函数，必须保证 2 个容器的类型完全相同。</p><ol start="4"><li>当然，如果不想全部拷贝，可以使用 unordered_map 类模板提供的迭代器，在现有 unordered_map 容器中选择部分区域内的键值对，为新建 unordered_map 容器初始化。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入 2 个迭代器，</span></span><br><span class="line"><span class="function">std::unordered_map&lt;std::string, std::string&gt; <span class="title">umap2</span><span class="params">(++umap.begin(),umap.end())</span></span>;</span><br></pre></td></tr></table></figure><p>通过此方式创建的 umap2 容器，其内部就包含 umap 容器中除第 1 个键值对外的所有其它键值对。</p><h3 id="C-unordered-map容器的成员方法"><a href="#C-unordered-map容器的成员方法" class="headerlink" title="C++ unordered_map容器的成员方法"></a>C++ unordered_map容器的成员方法</h3><p>unordered_map 既可以看做是关联式容器，更属于自成一脉的无序容器。因此在该容器模板类中，既包含一些在学习关联式容器时常见的成员方法，还有一些属于无序容器特有的成员方法。</p><p>表 2 列出了 unordered_map 类模板提供的所有常用的成员方法以及各自的功能。</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[key]</td><td>该模板类中重载了 [] 运算符，其功能是可以向访问数组中元素那样，只要给定某个键值对的键 key，就可以获取该键对应的值。注意，如果当前容器中没有以 key 为键的键值对，则其会使用该键向当前容器中插入一个新键值对。</td></tr><tr><td>at(key)</td><td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找以 key 键的键值对的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新键值对。</td></tr><tr><td>erase()</td><td>删除指定键值对。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_map 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储键值对的数量。</td></tr><tr><td>bucket(key)</td><td>返回以 key 为键的键值对所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_map 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><p>注意，对于实现互换 2 个相同类型 unordered_map 容器的键值对，除了可以调用该容器模板类中提供的 swap() 成员方法外，STL 标准库还提供了同名的 swap() 非成员函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="C-无序容器的底层实现机制"><a href="#C-无序容器的底层实现机制" class="headerlink" title="C++无序容器的底层实现机制"></a>C++无序容器的底层实现机制</h2><p>我们先考虑最简单的情况，<strong>仅用一个数组来实现哈希表</strong>。在哈希表中，我们将数组中的每个空位称为「桶 bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 <code>key</code> 对应的桶，并在桶中获取 <code>value</code> 。</p><p>那么，如何基于 <code>key</code> 定位对应的桶呢？这是通过「哈希函数 hash function」实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 <code>key</code> ，输出空间是所有桶（数组索引）。换句话说，输入一个 <code>key</code> ，<strong>我们可以通过哈希函数得到该 <code>key</code> 对应的键值对在数组中的存储位置</strong>。</p><p>输入一个 <code>key</code> ，哈希函数的计算过程分为以下两步。</p><ol><li>通过某种哈希算法 <code>hash()</code> 计算得到哈希值。</li><li>将哈希值对桶数量（数组长度）<code>capacity</code> 取模，从而获取该 <code>key</code> 对应的数组索引 <code>index</code> 。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">index = <span class="built_in">hash</span>(key) % capacity</span><br></pre></td></tr></table></figure><p>随后，我们就可以利用 <code>index</code> 在哈希表中访问对应的桶，从而获取 <code>value</code> 。</p><p>设数组长度 <code>capacity = 100</code>、哈希算法 <code>hash(key) = key</code> ，易得哈希函数为 <code>key % 100</code> 。图 6-2 以 <code>key</code> 学号和 <code>value</code> 姓名为例，展示了哈希函数的工作原理。</p><p><img src="/../typora-user-images/hash_function.png" alt="哈希函数工作原理"></p><p>以下代码实现了一个简单哈希表。其中，我们将 <code>key</code> 和 <code>value</code> 封装成一个类 <code>Pair</code> ，以表示键值对。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 键值对 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">int</span> key, string val) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于数组实现的哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Pair *&gt; buckets;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化数组，包含 100 个桶</span></span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">delete</span> bucket;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = key % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        Pair *pair = buckets[index];</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        Pair *pair = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        buckets[index] = pair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 释放内存并置为 nullptr</span></span><br><span class="line">        <span class="keyword">delete</span> buckets[index];</span><br><span class="line">        buckets[index] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键值对 */</span></span><br><span class="line">    <span class="function">vector&lt;Pair *&gt; <span class="title">pairSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;Pair *&gt; pairSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pairSet.<span class="built_in">push_back</span>(pair);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keySet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                keySet.<span class="built_in">push_back</span>(pair-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有值 */</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">valueSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; valueSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                valueSet.<span class="built_in">push_back</span>(pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *kv : <span class="built_in">pairSet</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h3><p>从本质上看，哈希函数的作用是将所有 <code>key</code> 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，<strong>理论上一定存在“多个输入对应相同输出”的情况</strong>。</p><p>对于上述示例中的哈希函数，当输入的 <code>key</code> 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12836 % 100 = 36</span><br><span class="line">20336 % 100 = 36</span><br></pre></td></tr></table></figure><p>如图 6-3 所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为「哈希冲突 hash collision」。</p><p><img src="/../typora-user-images/hash_collision.png" alt="哈希冲突示例"></p><p>容易想到，哈希表容量 n 越大，多个 <code>key</code> 被分配到同一个桶中的概率就越低，冲突就越少。因此，<strong>我们可以通过扩容哈希表来减少哈希冲突</strong>。</p><p>扩容前键值对 <code>(136, A)</code> 和 <code>(236, D)</code> 发生冲突，扩容后冲突消失。</p><p><img src="/../typora-user-images/hash_table_reshash.png" alt="哈希表扩容"></p><p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 <code>capacity</code> 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p><p>「负载因子 load factor」是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，<strong>也常作为哈希表扩容的触发条件</strong>。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表扩容至原先的 2 倍。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p><strong>通常情况下哈希函数的输入空间远大于输出空间</strong>，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</p><p>哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。</p><ol><li>改良哈希表数据结构，<strong>使得哈希表可以在出现哈希冲突时正常工作</strong>。</li><li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li></ol><p>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</p><h4 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h4><p>在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图 6-5 展示了一个链式地址哈希表的例子。</p><p><img src="/../typora-user-images/hash_table_chaining.png" alt="链式地址哈希表"></p><p>基于链式地址实现的哈希表的操作方法发生了以下变化。</p><ul><li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li><li><strong>添加元素</strong>：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。</li><li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。</li></ul><p>链式地址存在以下局限性。</p><ul><li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加耗费内存空间。</li><li><strong>查询效率降低</strong>：因为需要线性遍历链表来查找对应元素。</li></ul><p>以下代码给出了链式地址哈希表的简单实现，需要注意两点。</p><ul><li>使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</li><li>以下实现包含哈希表扩容方法。当负载因子超过 2&#x2F;3 时，我们将哈希表扩容至原先的 2 倍。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3.0</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapChaining</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key ，则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key ，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key) &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是，当链表很长时，查询效率 O(n) 很差。<strong>此时可以将链表转换为“AVL 树”或“红黑树”</strong>，从而将查询操作的时间复杂度优化至 O(log⁡n) 。</p><h4 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h4><p>「开放寻址 open addressing」不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p><p>下面以线性探测为例，介绍开放寻址哈希表的工作机制。</p><h5 id="1-线性探测¶"><a href="#1-线性探测¶" class="headerlink" title="1.  线性探测¶"></a>1.  线性探测<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#1">¶</a></h5><p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p><ul><li><strong>插入元素</strong>：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 1 ），直至找到空桶，将元素插入其中。</li><li><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</li></ul><p>图 6-6 展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 <code>key</code> 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。</p><p><img src="/../typora-user-images/hash_table_linear_probing.png" alt="开放寻址（线性探测）哈希表的键值对分布"></p><p>然而，<strong>线性探测容易产生“聚集现象”</strong>。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</p><p>值得注意的是，<strong>我们不能在开放寻址哈希表中直接删除元素</strong>。这是因为删除元素会在数组内产生一个空桶 <code>None</code> ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如图 6-7 所示。</p><p><img src="/../typora-user-images/hash_table_open_addressing_deletion.png" alt="在开放寻址中删除元素导致的查询问题"></p><p>为了解决该问题，我们可以采用「懒删除 lazy deletion」机制：它不直接从哈希表中移除元素，<strong>而是利用一个常量 <code>TOMBSTONE</code> 来标记这个桶</strong>。在该机制下，<code>None</code> 和 <code>TOMBSTONE</code> 都代表空桶，都可以放置键值对。但不同的是，线性探测到 <code>TOMBSTONE</code> 时应该继续遍历，因为其之下可能还存在键值对。</p><p>然而，<strong>懒删除可能会加速哈希表的性能退化</strong>。这是因为每次删除操作都会产生一个删除标记，随着 <code>TOMBSTONE</code> 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 <code>TOMBSTONE</code> 才能找到目标元素。</p><p>为此，考虑在线性探测中记录遇到的首个 <code>TOMBSTONE</code> 的索引，并将搜索到的目标元素与该 <code>TOMBSTONE</code> 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。</p><p>以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                             <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity = <span class="number">4</span>;                     <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;     <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> extendRatio = <span class="number">2</span>;            <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets;               <span class="comment">// 桶数组</span></span><br><span class="line">    Pair *TOMBSTONE = <span class="keyword">new</span> <span class="built_in">Pair</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapOpenAddressing</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">buckets</span>(capacity, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapOpenAddressing</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> TOMBSTONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 搜索 key 对应的桶索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBucket</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="type">int</span> firstTombstone = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 线性探测，当遇到空桶时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 若遇到 key ，返回对应的桶索引</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index]-&gt;key == key) &#123;</span><br><span class="line">                <span class="comment">// 若之前遇到了删除标记，则将键值对移动至该索引处</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != <span class="number">-1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone; <span class="comment">// 返回移动后的桶索引</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 返回桶索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的首个删除标记</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == <span class="number">-1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部则返回头部</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 key 不存在，则返回添加点的索引</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == <span class="number">-1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则返回对应 val</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则返回空字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则覆盖 val 并返回</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index]-&gt;val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若键值对不存在，则添加该键值对</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索 key 对应的桶索引</span></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">findBucket</span>(key);</span><br><span class="line">        <span class="comment">// 若找到键值对，则用删除标记覆盖它</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">nullptr</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">delete</span> buckets[index];</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;Pair *&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="literal">nullptr</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;TOMBSTONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-平方探测¶"><a href="#2-平方探测¶" class="headerlink" title="2.  平方探测¶"></a>2.  平方探测<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#2">¶</a></h5><p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。</p><p>平方探测主要具有以下优势。</p><ul><li>平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。</li></ul><p>然而，平方探测并不是完美的。</p><ul><li>仍然存在聚集现象，即某些位置比其他位置更容易被占用。</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。</li></ul><h5 id="3-多次哈希¶"><a href="#3-多次哈希¶" class="headerlink" title="3.  多次哈希¶"></a>3.  多次哈希<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#3">¶</a></h5><p>顾名思义，多次哈希方法使用多个哈希函数 f1(x)、f2(x)、f3(x)、… 进行探测。</p><ul><li><strong>插入元素</strong>：若哈希函数 f1(x) 出现冲突，则尝试 f2(x) ，以此类推，直到找到空位后插入元素。</li><li><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 <code>None</code> 。</li></ul><p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量。</p><p>&#x3D;&#x3D;请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题.&#x3D;&#x3D;</p><hr><p>各种编程语言采取了不同的哈希表实现策略，下面举几个例子。</p><ul><li>Python 采用开放寻址。字典 <code>dict</code> 使用伪随机数进行探测。</li><li>Java 采用链式地址。自 JDK 1.8 以来，当 <code>HashMap</code> 内数组长度达到 64 且链表长度达到 8 时，链表会转换为红黑树以提升查找性能。</li><li>Go 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。</li></ul><hr><h2 id="unordered-map迭代器的用法"><a href="#unordered-map迭代器的用法" class="headerlink" title="unordered_map迭代器的用法"></a>unordered_map迭代器的用法</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr></tbody></table><p>值得一提的是，equal_range(key) 很少用于 unordered_map 容器，因为该容器中存储的都是键不相等的键值对，即便调用该成员方法，得到的 2 个迭代器所表示的范围中，最多只包含 1 个键值对。事实上，该成员方法更适用于 unordered_multimap 容器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap 存储的键值对包括：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历输出 umap 容器中所有的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指向指定键值对的前向迭代器</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">&quot;Java教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;umap.find(\&quot;Java教程\&quot;) = &quot;</span> &lt;&lt; <span class="string">&quot;&lt;&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行结果为：</span></span><br><span class="line">umap 存储的键值对包括：</span><br><span class="line">&lt;Python教程, http:<span class="comment">//c.biancheng.net/python/&gt;</span></span><br><span class="line">&lt;Linux教程, http:<span class="comment">//c.biancheng.net/linux/&gt;</span></span><br><span class="line">&lt;Java教程, http:<span class="comment">//c.biancheng.net/java/&gt;</span></span><br><span class="line">umap.<span class="built_in">find</span>(<span class="string">&quot;Java教程&quot;</span>) = &lt;Java教程, http:<span class="comment">//c.biancheng.net/java/&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在操作 unordered_map 容器过程（尤其是向容器中添加新键值对）中，一旦当前容器的负载因子超过最大负载因子（默认值为 1.0），该容器就会适当增加桶的数量（通常是翻一倍），并自动执行 rehash() 成员方法，重新调整各个键值对的存储位置（此过程又称“重哈希”），此过程很可能导致之前创建的迭代器失效。</p><blockquote><p>所谓迭代器失效，针对的是那些用于表示容器内某个范围的迭代器，由于重哈希会重新调整每个键值对的存储位置，所以容器重哈希之后，之前表示特定范围的迭代器很可能无法再正确表示该范围。但是，重哈希并不会影响那些指向单个键值对元素的迭代器。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加 50 个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        umap.<span class="built_in">emplace</span>(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取键为 49 的键值对所在的范围</span></span><br><span class="line">    <span class="keyword">auto</span> pair = umap.<span class="built_in">equal_range</span>(<span class="number">49</span>);</span><br><span class="line">    <span class="comment">//输出 pair 范围内的每个键值对的键的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//手动调整最大负载因子数</span></span><br><span class="line">    umap.<span class="built_in">max_load_factor</span>(<span class="number">3.0</span>);</span><br><span class="line">    <span class="comment">//手动调用 rehash() 函数重哈希</span></span><br><span class="line">    umap.<span class="built_in">rehash</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//重哈希之后，pair 的范围可能会发生变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pair.first; iter != pair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">49</span></span><br><span class="line"><span class="comment">49 17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>经测试，用于遍历整个容器的 begin()/end() 和 cbegin()/cend() 迭代器对，重哈希只会影响遍历容器内键值对的顺序，整个遍历的操作仍然可以顺利完成。</code></p><h2 id="unordered-map获取元素的4种方法"><a href="#unordered-map获取元素的4种方法" class="headerlink" title="unordered_map获取元素的4种方法"></a>unordered_map获取元素的4种方法</h2><ol><li>unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//获取 &quot;Java教程&quot; 对应的值</span></span><br><span class="line">    string str = umap[<span class="string">&quot;Java教程&quot;</span>];</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对。</p><ol start="2"><li>unordered_map 类模板中，还提供有 at() 成员方法，和使用 [ ] 运算符一样，at() 成员方法也需要根据指定的键，才能从容器中找到该键对应的值；不同之处在于，如果在当前容器中查找失败，该方法不会向容器中添加新的键值对，而是直接抛出<code>out_of_range</code>异常。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//获取指定键对应的值</span></span><br><span class="line">    string str = umap.<span class="built_in">at</span>(<span class="string">&quot;Python教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//执行此语句会抛出 out_of_range 异常</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; umap.at(&quot;GO教程&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><input disabled type="checkbox"> 运算符和 at() 成员方法基本能满足大多数场景的需要。除此之外，还可以借助 unordered_map 模板中提供的 find() 成员方法。</li></ol><p>和前面方法不同的是，通过 find() 方法得到的是一个正向迭代器，该迭代器的指向分以下 2 种情况：</p><p>当 find() 方法成功找到以指定元素作为键的键值对时，其返回的迭代器就指向该键值对；</p><p>当 find() 方法查找失败时，其返回的迭代器和 end() 方法返回的迭代器一样，指向容器中最后一个键值对之后的位置。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找成功</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter = umap.<span class="built_in">find</span>(<span class="string">&quot;Python教程&quot;</span>);</span><br><span class="line">    cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//查找失败</span></span><br><span class="line">    unordered_map&lt;string, string&gt;::iterator iter2 = umap.<span class="built_in">find</span>(<span class="string">&quot;GO教程&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iter2 == umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前容器中没有以\&quot;GO教程\&quot;为键的键值对&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>除了 find() 成员方法之外，甚至可以借助 begin()&#x2F;end() 或者 cbegin()&#x2F;cend()，通过遍历整个容器中的键值对来找到目标键值对。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Linux教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//遍历整个容器中存储的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="comment">//判断当前的键值对是否就是要找的</span></span><br><span class="line">        <span class="keyword">if</span> (!iter-&gt;first.<span class="built_in">compare</span>(<span class="string">&quot;Java教程&quot;</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="unordered-multimap容器"><a href="#unordered-multimap容器" class="headerlink" title="unordered_multimap容器"></a>unordered_multimap容器</h2><p>unordered_multimap 类模板提供的成员方法如表 2 所示。 </p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个键值对的正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，即该方法返回的迭代器不能用于修改容器内存储的键值对。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找以 key 键的键值对的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中键为 key 的键值对所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新键值对，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新键值对。</td></tr><tr><td>erase()</td><td>删除指定键值对。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有键值对。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_multimap 容器存储的键值对，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_multimap 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储键值对的数量。</td></tr><tr><td>bucket(key)</td><td>返回以 key 为键的键值对所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_multimap 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_multimap 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><hr><h2 id="unordered-set容器"><a href="#unordered-set容器" class="headerlink" title="unordered_set容器"></a>unordered_set容器</h2><p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p><p>总的来说，unordered_set 容器具有以下几个特性：</p><ol><li><p>不再以键值对的形式存储数据，而是直接存储数据的值；</p></li><li><p>容器内部存储的各个元素的值都互不相等，且不能被修改。</p></li><li><p>不会对内部存储的数据进行排序</p><h4 id="C-unordered-set容器的成员方法"><a href="#C-unordered-set容器的成员方法" class="headerlink" title="C++ unordered_set容器的成员方法"></a>C++ unordered_set容器的成员方法</h4></li></ol><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器。</td></tr><tr><td>end();</td><td>返回指向容器中最后一个元素之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找值为 key 的元素的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新元素。</td></tr><tr><td>erase()</td><td>删除指定元素。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有元素。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_set 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_set 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储元素的数量。</td></tr><tr><td>bucket(key)</td><td>返回值为 key 的元素所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_set 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() &#x3D; size() &#x2F; bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_set 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳 count 个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的unordered_set容器</span></span><br><span class="line">    std::unordered_set&lt;std::string&gt; uset;</span><br><span class="line">    <span class="comment">//给 uset 容器添加数据</span></span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    uset.<span class="built_in">emplace</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    <span class="comment">//查看当前 uset 容器存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;uset size = &quot;</span> &lt;&lt; uset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历输出 uset 容器存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = uset.<span class="built_in">begin</span>(); iter != uset.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="unordered-multiset容器"><a href="#unordered-multiset容器" class="headerlink" title="unordered_multiset容器"></a>unordered_multiset容器</h2><p>前面章节详细地介绍了 unordered_set 容器的特定和用法，在此基础上，本节再介绍一个类似的 C++ STL 无序容器，即 unordered_multiset 容器。</p><p>所谓“类似”，指的是 unordered_multiset 容器大部分的特性都和 unordered_set 容器相同，包括：</p><ol><li>unordered_multiset 不以键值对的形式存储数据，而是直接存储数据的值；</li><li>该类型容器底层采用的也是哈希表存储结构（可阅读《<a href="https://c.biancheng.net/view/7235.html">C++ STL无序容器底层实现原理</a>》一文做详细了解），它不会对内部存储的数据进行排序；</li><li>unordered_multiset 容器内部存储的元素，其值不能被修改。</li></ol><p>和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。</p><blockquote><p>读者可以这样认为，unordered_multiset 除了能存储相同值的元素外，它和 unordered_set 容器完全相同。</p></blockquote><p>值得一提的是，unordered_multiset 模板类中提供的成员方法，无论是种类还是数量，都和 unordered_set 类模板一样</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="/2024/09/26/socket/"/>
      <url>/2024/09/26/socket/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="socket是什么？套接字是什么？"><a href="#socket是什么？套接字是什么？" class="headerlink" title="socket是什么？套接字是什么？"></a>socket是什么？套接字是什么？</h1><p>网络编程就是编写程序使两台联网的计算机相互交换数据。这就是全部内容了吗？是的！网络编程要比想象中的简单许多。</p><p>那么，这两台计算机之间用什么传输数据呢？首先需要物理连接。如今大部分计算机都已经连接到互联网，因此不用担心这一点。</p><p>在此基础上，只需要考虑如何编写数据传输程序。但实际上这点也不用愁，因为操作系统已经提供了 <a href="https://c.biancheng.net/socket/">socket</a>。即使对网络数据传输的原理不太熟悉，我们也能通过 socket 来编程。</p><h2 id="什么是-socket？"><a href="#什么是-socket？" class="headerlink" title="什么是 socket？"></a>什么是 socket？</h2><p>&#x3D;&#x3D;<strong>socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</strong>&#x3D;&#x3D;</p><p>我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。</p><p>socket 的典型应用就是 Web 服务器和浏览器：浏览器获取用户输入的 URL，向服务器发起请求，服务器分析接收到的 URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。</p><p>学习 socket，也就是学习计算机之间如何通信，并编写出实用的程序。</p><h2 id="UNIX-Linux-中的-socket-是什么？"><a href="#UNIX-Linux-中的-socket-是什么？" class="headerlink" title="UNIX&#x2F;Linux 中的 socket 是什么？"></a>UNIX&#x2F;Linux 中的 socket 是什么？</h2><p>为了表示和区分已经打开的文件，UNIX&#x2F;Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：</p><ul><li>通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；</li><li>通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。</li></ul><p>UNIX&#x2F;Linux 程序在执行任何形式的 I&#x2F;O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p><p>&#x3D;&#x3D;<strong>网络连接也是一个文件，它也有文件描述符！</strong>&#x3D;&#x3D;</p><p>我们可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p><ul><li>用 read() 读取从远程计算机传来的数据；</li><li>用 write() 向远程计算机写入数据。</li></ul><h2 id="Window-系统中的-socket-是什么？"><a href="#Window-系统中的-socket-是什么？" class="headerlink" title="Window 系统中的 socket 是什么？"></a>Window 系统中的 socket 是什么？</h2><p>Windows 也有类似“文件描述符”的概念，但通常被称为“文件句柄”。因此，本教程如果涉及 Windows 平台将使用&#x3D;&#x3D;“句柄”&#x3D;&#x3D;，如果涉及 Linux 平台则使用<strong>“描述符”</strong>。</p><p>与 UNIX&#x2F;Linux 不同的是，Windows 会区分 socket 和文件，Windows 就把 socket 当做一个网络连接来对待，因此需要调用专门针对 socket 而设计的数据传输函数，针对普通文件的输入输出函数就无效了。</p><h1 id="套接字有哪些类型？socket有哪些类型？"><a href="#套接字有哪些类型？socket有哪些类型？" class="headerlink" title="套接字有哪些类型？socket有哪些类型？"></a>套接字有哪些类型？socket有哪些类型？</h1><p>有很多种套接字（<a href="https://c.biancheng.net/socket/">socket</a>），比如 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）等。nternet 套接字，它是最具代表性的，也是最经典最常用的。以后我们提及套接字，指的都是 Internet 套接字。</p><h2 id="流格式套接字（SOCK-STREAM）"><a href="#流格式套接字（SOCK-STREAM）" class="headerlink" title="流格式套接字（SOCK_STREAM）"></a>流格式套接字（SOCK_STREAM）</h2><p>流格式套接字（Stream Sockets）也叫“面向连接的套接字”，在代码中使用 SOCK_STREAM 表示。</p><p><strong>SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。</strong></p><p>SOCK_STREAM 有以下几个特征：</p><ul><li>数据在传输过程中不会消失；</li><li>数据是按照顺序传输的；</li><li>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。</li></ul><p> SOCK_STREAM 比喻成一条传送带，只要传送带本身没有问题（不会断网），就能保证数据不丢失；同时，较晚传送的数据不会先到达，较早传送的数据不会晚到达，这就保证了数据是按照顺序传递的。</p><p><img src="https://c.biancheng.net/uploads/allimg/190123/1-1Z1232154153L.gif" alt="将面向连接的套接字比喻成传送带"></p><p>为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议（The Transmission Control Protocol，传输控制协议），TCP 协议会控制你的数据按照顺序到达并且没有错误。</p><p>TCP&#x2F;IP”。TCP 用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。</p><p><strong>“数据的发送和接收不同步”</strong></p><p>假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。</p><p>流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。</p><p>不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。</p><p>浏览器所使用的 http 协议就基于面向连接的套接字，因为必须要确保数据准确无误，否则加载的 HTML 将无法解析。</p><h2 id="数据报格式套接字（SOCK-DGRAM）"><a href="#数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="数据报格式套接字（SOCK_DGRAM）"></a>数据报格式套接字（SOCK_DGRAM）</h2><p>数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”，在代码中使用 SOCK_DGRAM 表示。</p><p>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p><p>因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。</p><p>可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：</p><ul><li>强调快速传输而非传输顺序；</li><li>传输的数据可能丢失也可能损毁；</li><li>限制每次传输的数据大小；</li><li>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</li></ul><p>速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度交给客户就行。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，想要传递大量包裹，就得分配发送。用两辆摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以<strong>“数据的发送和接收是同步的”；换句话说，接收次数应该和发送次数相同。</strong></p><p>&#x3D;&#x3D;<strong>总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。</strong>&#x3D;&#x3D;</p><p>数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p><p>QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响</p><h1 id="面向连接和无连接的套接字到底有什么区别？"><a href="#面向连接和无连接的套接字到底有什么区别？" class="headerlink" title="面向连接和无连接的套接字到底有什么区别？"></a>面向连接和无连接的套接字到底有什么区别？</h1><p>从字面上理解，面向连接好像有一条管道，它连接发送端和接收端，数据包都通过这条管道来传输。当然，两台计算机在通信之前必须先搭建好管道。</p><p>无连接好像没头苍蝇乱撞，数据包从发送端到接收端并没有固定的线路，爱怎么走就怎么走，只要能到达就行。每个数据包都比较自私，不和别人分享自己的线路，但是，大家最终都能殊途同归，到达接收端。</p><p><img src="http://c.biancheng.net/uploads/allimg/190125/1-1Z1251140543K.gif" alt="一个简化的互联网模型"></p><p>假设 H1 要发送若干个数据包给 H6，那么有多条路径可以选择，比如：</p><ul><li>路径①：H1 –&gt; A –&gt; C –&gt; E –&gt; H6</li><li>路径②：H1 –&gt; A –&gt; B –&gt; E –&gt; H6</li><li>路径③：H1 –&gt; A –&gt; B –&gt; D –&gt; E –&gt; H6</li><li>路径④：H1 –&gt; A –&gt; B –&gt; C –&gt; E –&gt; H6</li><li>路径⑤：H1 –&gt; A –&gt; C –&gt; B –&gt; D –&gt; E –&gt; H6</li></ul><p>数据包的传输路径是路由器根据算法来计算出来的，算法会考虑很多因素，比如网络的拥堵状况、下一个路由器是否忙碌等。</p><h3 id="无连接的套接字"><a href="#无连接的套接字" class="headerlink" title="无连接的套接字"></a><strong>无连接的套接字</strong></h3><p>于无连接的套接字，每个数据包可以选择不同的路径，比如第一个数据包选择路径④，第二个数据包选择路径①，第三个数据包选择路径②……当然，它们也可以选择相同的路径，那也只不过是巧合而已。</p><p>每个数据包之间都是独立的，各走各的路，谁也不影响谁，除了迷路的或者发生意外的数据包，最后都能到达 H6。但是，到达的顺序是不确定的，比如：</p><ul><li>第一个数据包选择了一条比较长的路径（比如路径⑤），第三个数据包选择了一条比较短的路径（比如路径①），虽然第一个数据包很早就出发了，但是走的路比较远，最终还是晚于第三个数据包达到。</li><li>第一个数据包选择了一条比较短的路径（比如路径①），第三个数据包选择了一条比较长的路径（比如路径⑤），按理说第一个数据包应该先到达，但是非常不幸，第一个数据包走的路比较拥堵，这条路上的数据量非常大，路由器处理得很慢，所以它还是晚于第三个数据包达到了。</li></ul><p>还有一些意外情况会发生，比如：</p><ul><li>第一个数据包选择了路径①，但是路由器C突然断电了，那它就到不了 H6 了。</li><li>第三个数据包选择了路径②，虽然路不远，但是太拥堵，以至于它等待的时间太长，路由器把它丢弃了。</li></ul><p>对于无连接的套接字，数据包在传输过程中会发生各种不测，也会发生各种奇迹。H1 只负责把数据包发出，至于它什么时候到达，先到达还是后到达，有没有成功到达，H1 都不管了；H6 也没有选择的权利，只能被动接收，收到什么算什么，爱用不用。</p><p>无连接套接字遵循的是「尽最大努力交付」的原则，就是尽力而为，实在做不到了也没办法。无连接套接字提供的没有质量保证的服务。</p><h3 id="面向连接的套接字"><a href="#面向连接的套接字" class="headerlink" title="面向连接的套接字"></a>面向连接的套接字</h3><p>面向连接的套接字在正式通信之前要先确定一条路径，没有特殊情况的话，以后就固定地使用这条路径来传递数据包了。当然，路径被破坏的话，比如某个路由器断电了，那么会重新建立路径。</p><p><img src="http://c.biancheng.net/uploads/allimg/190125/1-1Z1251F50LS.gif" alt="选好的路径"></p><p>这条路径是由路由器维护的，路径上的所有路由器都要存储该路径的信息（实际上只需要存储上游和下游的两个路由器的位置就行），所以路由器是有开销的。</p><p>H1 和 H6 通信完毕后，要断开连接，销毁路径，这个时候路由器也会把之前存储的路径信息擦除。</p><p>在很多网络通信教程中，这条预先建立好的路径被称为“虚电路”，就是一条虚拟的通信电路。</p><p>为了保证数据包准确、顺序地到达，发送端在发送数据包以后，必须得到接收端的确认才发送下一个数据包；如果数据包发出去了，一段时间以后仍然没有得到接收端的回应，那么发送端会重新再发送一次，直到得到接收端的回应。这样一来，发送端发送的所有数据包都能到达接收端，并且是按照顺序到达的。</p><p>&#x3D;&#x3D;<strong>发送端发送一个数据包，如何得到接收端的确认呢？很简单，为每一个数据包分配一个 ID，接收端接收到数据包以后，再给发送端返回一个数据包，告诉发送端我接收到了 ID 为 xxx 的数据包。</strong>&#x3D;&#x3D;</p><p>面向连接的套接字会比无连接的套接字多出很多数据包，因为发送端每发送一个数据包，接收端就会返回一个数据包。此外，建立连接和断开连接的过程也会传递很多数据包。</p><p>不但是数量多了，每个数据包也变大了：除了源端口和目的端口，面向连接的套接字还包括序号、确认信号、数据偏移、控制标志（通常说的 URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息；而无连接的套接字则只包含长度和校验和信息。</p><p>有连接的数据包比无连接大很多，这意味着更大的负载和更大的带宽。许多即时聊天软件采用 UDP 协议（无连接套接字），与此有莫大的关系。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种套接字各有优缺点：</p><ul><li>无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险；</li><li>有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。</li></ul><p>两种套接字的特点决定了它们的应用场景，有些服务对可靠性要求比较高，必须数据包能够完整无误地送达，那就得选择有连接的套接字（TCP 服务），比如 HTTP、FTP 等；而另一些服务，并不需要那么高的可靠性，效率和实时才是它们所关心的，那就可以选择无连接的套接字（UDP 服务），比如 DNS、即时聊天工具等。</p><h1 id="OSI网络七层模型简明教程"><a href="#OSI网络七层模型简明教程" class="headerlink" title="OSI网络七层模型简明教程"></a>OSI网络七层模型简明教程</h1><p><img src="https://c.biancheng.net/uploads/allimg/190124/1-1Z1241445324H.jpg" alt="OSI 七层网络模型和 TCP/IP 四层网络模型的对比"></p><p><strong>这个网络模型究竟是干什么呢？简而言之就是进行数据封装的。</strong></p><p>我们平常使用的程序（或者说软件）一般都是通过应用层来访问网络的，程序产生的数据会一层一层地往下传输，直到最后的网络接口层，就通过网线发送到互联网上去了。数据每往下走一层，就会被这一层的协议增加一层包装，等到发送到互联网上时，已经比原始数据多了四层包装。整个数据封装的过程就像俄罗斯套娃。</p><p>当另一台计算机接收到数据包时，会从网络接口层再一层一层往上传输，每传输一层就拆开一层包装，直到最后的应用层，就得到了最原始的数据，这才是程序要使用的数据。</p><p>给数据加包装的过程，实际上就是在数据的头部增加一个标志（一个数据块），表示数据经过了这一层，我已经处理过了。给数据拆包装的过程正好相反，就是去掉数据头部的标志，让它逐渐现出原形。</p><p>&#x3D;&#x3D;<strong>我们所说的 <a href="https://c.biancheng.net/socket/">socket</a> 编程，是站在传输层的基础上，所以可以使用 TCP&#x2F;UDP 协议，但是不能干「访问网页」这样的事情，因为访问网页所需要的 http 协议位于应用层。</strong>&#x3D;&#x3D;</p><p>两台计算机进行通信时，必须遵守以下原则：</p><ul><li>必须是同一层次进行通信，比如，A 计算机的应用层和 B 计算机的传输层就不能通信，因为它们不在一个层次，数据的拆包会遇到问题。</li><li>每一层的功能都必须相同，也就是拥有完全相同的网络模型。如果网络模型都不同，那不就乱套了，谁都不认识谁。</li><li>数据只能逐层传输，不能跃层。</li><li>每一层可以使用下层提供的服务，并向上层提供服务。</li></ul><h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h1><p>目前实际使用的网络模型是 TCP&#x2F;IP 模型，它对 OSI 模型进行了简化，只包含了四层，从上到下分别是应用层、传输层、网络层和链路层（网络接口层），每一层都包含了若干协议。</p><p>协议（Protocol）就是网络通信过程中的约定或者合同，通信的双方必须都遵守才能正常收发数据。协议有很多种，例如 TCP、UDP、IP 等，通信的双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。</p><p>&#x3D;&#x3D;<strong>协议仅仅是一种规范，必须由计算机软件来实现。例如 IP 协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵守该协议，不能另起炉灶。</strong>&#x3D;&#x3D;</p><p>TCP&#x2F;IP 模型包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百个互为关联的协议，其中 TCP 和 IP 是最常用的两种底层协议，所以把它们统称为“TCP&#x2F;IP 协议族”。</p><p>也就是说，“TCP&#x2F;IP模型”中所涉及到的协议称为“TCP&#x2F;IP协议族”，你可以区分这两个概念，也可以认为它们是等价的</p><p><img src="https://c.biancheng.net/uploads/allimg/190126/1-1Z126104435N0.gif" alt="TCP/IP协议的层次图"></p><h1 id="IP、MAC和端口号——网络通信中确认身份信息的三要素"><a href="#IP、MAC和端口号——网络通信中确认身份信息的三要素" class="headerlink" title="IP、MAC和端口号——网络通信中确认身份信息的三要素"></a>IP、MAC和端口号——网络通信中确认身份信息的三要素</h1><p>在茫茫的互联网海洋中，要找到一台计算机非常不容易，有三个要素必须具备，它们分别是 IP 地址、MAC 地址和端口号。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是 Internet Protocol Address 的缩写，译为“网际协议地址”。</p><p>目前大部分软件使用 IPv4 地址，但 IPv6 也正在被人们接受，尤其是在教育网中，已经大量使用。</p><p>一台计算机可以拥有一个独立的 IP 地址，一个局域网也可以拥有一个独立的 IP 地址（对外就好像只有一台计算机）。对于目前广泛使用 IPv4 地址，它的资源是非常有限的，一台计算机一个 IP 地址是不现实的，往往是一个局域网才拥有一个 IP 地址。</p><p>在因特网上进行通信时，必须要知道对方的 IP 地址。实际上数据包中已经附带了 IP 地址，把数据包发送给路由器以后，路由器会根据 IP 地址找到对方的地里位置，完成一次数据的传递。路由器有非常高效和智能的算法，很快就会找到目标计算机。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>现实的情况是，一个局域网往往才能拥有一个独立的 IP；换句话说，IP 地址只能定位到一个局域网，无法定位到具体的一台计算机。这可怎么办呀？这样也没法通信啊。</p><p>其实，真正能唯一标识一台计算机的是 MAC 地址，每个网卡的 MAC 地址在全世界都是独一无二的。计算机出厂时，MAC 地址已经被写死到网卡里面了（当然通过某些“奇巧淫技”也是可以修改的）。局域网中的路由器&#x2F;交换机会记录每台计算机的 MAC 地址。</p><p>&#x3D;&#x3D;<strong>MAC 地址是 Media Access Control Address 的缩写，直译为“媒体访问控制地址”，也称为局域网地址（LAN Address），以太网地址（Ethernet Address）或物理地址（Physical Address）。</strong>&#x3D;&#x3D;</p><p>数据包中除了会附带对方的 IP 地址，还会附带对方的 MAC 地址，当数据包达到局域网以后，路由器&#x2F;交换机会根据数据包中的 MAC 地址找到对应的计算机，然后把数据包转交给它，这样就完成了数据的传递。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>有了 IP 地址和 MAC 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等，仅有 IP 地址和 MAC 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。</p><p>为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。</p><p>端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。如下图所示：</p><p><img src="https://c.biancheng.net/uploads/allimg/190126/15060130Z-0.jpg" alt="img"></p><h1 id="Linux下的socket演示程序"><a href="#Linux下的socket演示程序" class="headerlink" title="Linux下的socket演示程序"></a>Linux下的socket演示程序</h1><p>server.cpp</p><p><img src="/../../typora-user-images/image-20240316101556455.png" alt="image-20240316101556455"></p><p>client.cpp</p><p><img src="/../../typora-user-images/image-20240316101626733.png" alt="image-20240316101626733"></p><p>启动一个终端（Shell），先编译 server.cpp 并运行：</p><p><img src="/../../typora-user-images/image-20240316101653780.png" alt="image-20240316101653780"></p><p>正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。</p><p>接下再启动一个终端，编译 client.cpp 并运行：</p><p><img src="/../../typora-user-images/image-20240316101722680.png" alt="image-20240316101722680"></p><p>client 接收到从 server发送过来的字符串就运行结束了，同时，server 完成发送字符串的任务也运行结束了。大家可以通过两个打开的终端来观察。</p><p>client 运行后，通过 connect() 函数向 server 发起请求，处于监听状态的 server 被激活，执行 accept() 函数，接受客户端的请求，然后执行 write() 函数向 client 传回数据。client 接收到传回的数据后，connect() 就运行结束了，然后使用 read() 将数据读取出来。</p><p>源码解析</p><p>server.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="comment">/*通过 socket() 函数创建了一个套接字，参数 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向连接的套接字，IPPROTO_TCP 表示使用 TCP 协议。在 Linux 中，socket 也是一种文件，有文件描述符，可以使用 write() / read() 函数进行 I/O 操作，这一点已在《socket是什么》中进行了讲解。*/</span></span><br><span class="line">    <span class="type">int</span> serv_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">/*通过 bind() 函数将套接字 serv_sock 与特定的 IP 地址和端口绑定，IP 地址和端口都保存在 sockaddr_in 结构体中。socket() 函数确定了套接字的各种属性，bind() 函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="comment">/*让套接字处于被动监听状态。所谓被动监听，是指套接字一直处于“睡眠”中，直到客户端发起请求才会被“唤醒”*/</span></span><br><span class="line">    <span class="built_in">listen</span>(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clnt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">/* accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。*/</span></span><br><span class="line">    <span class="type">int</span> clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;http://c.biancheng.net/socket/&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="comment">/* accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。*/</span></span><br><span class="line">    <span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">read</span>(sock, buffer, <span class="built_in">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   <span class="comment">//通过 read() 从套接字文件中读取数据。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Windows下终端g-执行socket需要带动态链接库后缀-lws2-32"><a href="#Windows下终端g-执行socket需要带动态链接库后缀-lws2-32" class="headerlink" title="&#x3D;&#x3D;Windows下终端g++执行socket需要带动态链接库后缀        -lws2_32&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>Windows下终端g++执行socket需要带动态链接库后缀        -lws2_32</strong>&#x3D;&#x3D;</h1><h1 id="Windows下的socket演示程序"><a href="#Windows下的socket演示程序" class="headerlink" title="Windows下的socket演示程序"></a>Windows下的socket演示程序</h1><p>服务器端代码 server.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化 DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET servSock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    <span class="built_in">listen</span>(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    SOCKET clntSock = <span class="built_in">accept</span>(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">//char *str=&quot;Hello World!&quot;;error&quot;Hello World!&quot;是常量不能修改，char*指针类型是可以修改数据的所以不能使用，要加const</span></span><br><span class="line">    <span class="built_in">send</span>(clntSock, str, <span class="built_in">strlen</span>(str)+<span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clntSock);</span><br><span class="line">    <span class="built_in">closesocket</span>(servSock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止 DLL 的使用</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> szBuffer[MAXBYTE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(sock, szBuffer, MAXBYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, szBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止使用 DLL</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="/../../typora-user-images/image-20240316142343404.png" alt="image-20240316142343404"></p><p>Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别：</p><ol><li><p>Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。DLL 有两种加载方式</p></li><li><p>Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。</p></li><li><p>Linux 下使用 read() &#x2F; write() 函数读写，而 Windows 下使用 recv() &#x2F; send() 函数发送和接收。</p></li><li><p>关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。</p></li></ol><h1 id="Windows下使用WSAStartup-函数加载DLL"><a href="#Windows下使用WSAStartup-函数加载DLL" class="headerlink" title="Windows下使用WSAStartup()函数加载DLL"></a>Windows下使用WSAStartup()函数加载DLL</h1><ul><li>较早的DLL是 wsock32.dll，大小为 28KB，对应的头文件为 winsock1.h；</li><li>最新的DLL是 ws2_32.dll，大小为 69KB，对应的头文件为 winsock2.h。</li></ul><p>几乎所有的 Windows 操作系统都已经支持 ws2_32.dll，包括个人操作系统 Windows 95 OSR2、Windows 98、Windows Me、Windows 2000、XP、Vista、Win7、Win8、Win10 以及服务器操作系统 Windows NT 4.0 SP4、Windows Server 2003、Windows Server 2008 等，所以你可以毫不犹豫地使用最新的 ws2_32.dll。<br>使用<code>#pragma</code>命令，在编译时加载：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><h2 id="WSAStartup-函数"><a href="#WSAStartup-函数" class="headerlink" title="WSAStartup() 函数"></a>WSAStartup() 函数</h2><p>使用 DLL 之前，还需要调用 WSAStartup() 函数进行初始化，以指明 WinSock 规范的版本，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA lpWSAData)</span></span>;</span><br></pre></td></tr></table></figure><p>wVersionRequested 为 WinSock 规范的版本号，低字节为主版本号，高字节为副版本号（修正版本号）；lpWSAData 为指向 WSAData 结构体的指针。</p><p><strong>关于 WinSock 规范</strong><br>WinSock 规范的最新版本号为 2.2，较早的有 2.1、2.0、1.1、1.0，ws2_32.dll 支持所有的规范，而 wsock32.dll 仅支持 1.0 和 1.1。</p><p>wsock32.dll 已经能够很好的支持 TCP&#x2F;IP 通信程序的开发，ws2_32.dll 主要增加了对其他协议的支持，不过建议使用最新的 2.2 版本。</p><p>wVersionRequested 参数用来指明我们希望使用的版本号，它的类型为 WORD，等价于 unsigned short，是一个整数，所以需要用 MAKEWORD() 宏函数对版本号进行转换。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MAKEWORD</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//主版本号为1，副版本号为2，返回 0x0201</span></span><br><span class="line"><span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">//主版本号为2，副版本号为2，返回 0x0202</span></span><br></pre></td></tr></table></figure><p><strong>关于 WSAData 结构体</strong></p><p>WSAStartup() 函数执行成功后，会将与 ws2_32.dll 有关的信息写入 WSAData 结构体变量。WSAData 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">    WORD           wVersion;  <span class="comment">//ws2_32.dll 建议我们使用的版本号</span></span><br><span class="line">    WORD           wHighVersion;  <span class="comment">//ws2_32.dll 支持的最高版本号</span></span><br><span class="line">    <span class="comment">//一个以 null 结尾的字符串，用来说明 ws2_32.dll 的实现以及厂商信息</span></span><br><span class="line">    <span class="type">char</span>           szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//一个以 null 结尾的字符串，用来说明 ws2_32.dll 的状态以及配置信息</span></span><br><span class="line">    <span class="type">char</span>           szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxSockets;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> iMaxUdpDg;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">    <span class="type">char</span> FAR       *lpVendorInfo;  <span class="comment">//2.0以后不再使用</span></span><br><span class="line">&#125; WSADATA, *LPWSADATA;</span><br><span class="line"><span class="comment">/*只需关注前两个成员即可*/</span></span><br></pre></td></tr></table></figure><h1 id="socket-函数用法详解：创建套接字"><a href="#socket-函数用法详解：创建套接字" class="headerlink" title="socket()函数用法详解：创建套接字"></a>socket()函数用法详解：创建套接字</h1><p>不管是 Windows 还是 Linux，都使用 <a href="https://c.biancheng.net/socket/">socket</a>() 函数来创建套接字。socket() 在两个平台下的参数是相同的，不同的是返回值</p><p>Linux 中的一切都是文件，每个文件都有一个整数类型的文件描述符；socket 也是一个文件，也有文件描述符。使用 socket() 函数创建套接字以后，返回值就是一个 int 类型的文件描述符。</p><p>Windows 会区分 socket 和普通文件，它把 socket 当做一个网络连接来对待，调用 socket() 以后，返回值是 SOCKET 类型，用来表示一个套接字。</p><h2 id="Linux-下的-socket-函数"><a href="#Linux-下的-socket-函数" class="headerlink" title="Linux 下的 socket() 函数"></a>Linux 下的 socket() 函数</h2><p>在 Linux 下使用 &#x3D;&#x3D;&lt;sys&#x2F;socket.h&gt;&#x3D;&#x3D;头文件中 socket() 函数来创建套接字，原型为</p><ol><li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</li></ol><p>大家需要记住&#x3D;&#x3D;<strong><code>127.0.0.1</code></strong>&#x3D;&#x3D;，它是一个特殊IP地址，表示本机地址，后面的教程会经常用到。</p><p><code>可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</code></p><ol start="2"><li><p>type 为数据传输方式&#x2F;套接字类型，常用的有 SOCK_STREAM（流格式套接字&#x2F;面向连接的套接字） 和 SOCK_DGRAM（数据报套接字&#x2F;无连接的套接字），我们已经在《<a href="https://c.biancheng.net/view/2124.html">套接字有哪些类型</a>》一节中进行了介绍。</p></li><li><p>protocol 表示传输协议，常用的有 &#x3D;&#x3D;IPPROTO_TCP&#x3D;&#x3D; 和 &#x3D;&#x3D;IPPTOTO_UDP&#x3D;&#x3D;，分别表示 TCP 传输协议和 UDP 传输协议。</p></li></ol><p>有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？</p><p>正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：&#x3D;&#x3D;<strong>有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</strong>&#x3D;&#x3D;</p><p>使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用 SOCK_STREAM 传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用 socket() 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="comment">//IPPROTO_TCP表示TCP协议</span></span><br></pre></td></tr></table></figure><p>这种套接字称为 TCP 套接字。</p><p>如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket() 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);  <span class="comment">//IPPROTO_UDP表示UDP协议</span></span><br></pre></td></tr></table></figure><p>这种套接字称为 UDP 套接字。</p><p>面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tcp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br><span class="line"><span class="type">int</span> udp_socket = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  <span class="comment">//创建UDP套接字</span></span><br></pre></td></tr></table></figure><p>后面的教程中多采用这种简化写法。</p><h2 id="在Windows下创建socket"><a href="#在Windows下创建socket" class="headerlink" title="在Windows下创建socket"></a>在Windows下创建socket</h2><p>Windows 下也使用 socket() 函数来创建套接字，原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>除了返回值类型不同，其他都是相同的。Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br></pre></td></tr></table></figure><h1 id="bind-和connect-函数：绑定套接字并建立连接"><a href="#bind-和connect-函数：绑定套接字并建立连接" class="headerlink" title="bind()和connect()函数：绑定套接字并建立连接"></a>bind()和connect()函数：绑定套接字并建立连接</h1><p><a href="https://c.biancheng.net/socket/">socket</a>() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 bind() 函数将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理。类似地，客户端也要用 connect() 函数建立连接。</p><h2 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind() 函数"></a>bind() 函数</h2><p>bind() 函数的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>Linux为例</p><p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。</p><p><img src="/../../typora-user-images/image-20240316150402739.png" alt="image-20240316150402739"></p><h3 id="sockaddr-in-结构体"><a href="#sockaddr-in-结构体" class="headerlink" title="sockaddr_in 结构体"></a>sockaddr_in 结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;     <span class="comment">//16位的端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>            sin_zero[<span class="number">8</span>];  <span class="comment">//不使用，一般用0填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>sin_family 和 socket() 的第一个参数的含义相同，取值也要保持一致。</p></li><li><p>sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0<del>65536，但 0</del>1023 的端口一般由系统分配给特定的服务程序，例如 <strong>Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。</strong></p></li></ol><p>&#x3D;&#x3D;端口号需要用 htons() 函数转换，后面会讲解为什么。&#x3D;&#x3D;</p><ol start="3"><li><p>sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。</p></li><li><p>sin_zero[8] 是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。</p></li></ol><h3 id="in-addr-结构体"><a href="#in-addr-结构体" class="headerlink" title="in_addr 结构体"></a>in_addr 结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">in_addr_t</span>  s_addr;  <span class="comment">//32位的IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>in_addr_t 在头文件 &#x3D;&#x3D;&lt;netinet&#x2F;in.h&gt;&#x3D;&#x3D; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ip = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ip);</span><br></pre></td></tr></table></figure><p><img src="https://c.biancheng.net/uploads/allimg/190219/112P63295-0.jpg" alt="img"></p><h3 id="为什么使用-sockaddr-in-而不使用-sockaddr"><a href="#为什么使用-sockaddr-in-而不使用-sockaddr" class="headerlink" title="为什么使用 sockaddr_in 而不使用 sockaddr"></a>为什么使用 sockaddr_in 而不使用 sockaddr</h3><p>bind() 第二个参数的类型为 sockaddr，而代码中却使用 sockaddr_in，然后再强制转换为 sockaddr，这是为什么呢？</p><p>sockaddr 结构体的定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;    </span><br><span class="line">    <span class="type">sa_family_t</span>  sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">char</span>         sa_data[<span class="number">14</span>];      <span class="comment">//IP地址和端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://c.biancheng.net/uploads/allimg/190219/112PA615-1.jpg" alt="img"></p><p>sockaddr 和 sockaddr_in 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，&#x3D;&#x3D;没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。&#x3D;&#x3D;这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。</p><p><strong>可以认为，&#x3D;&#x3D;sockaddr 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，而 sockaddr_in 是专门用来保存 IPv4 地址的结构体。&#x3D;&#x3D;另外还有 sockaddr_in6，用来保存 IPv6 地址，它的定义如下：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123; </span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;  <span class="comment">//(2)地址类型，取值为AF_INET6</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;  <span class="comment">//(2)16位端口号</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;  <span class="comment">//(4)IPv6流信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class="comment">//(4)具体的IPv6地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;  <span class="comment">//(4)接口范围ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>正是由于通用结构体 sockaddr 使用不便，才针对不同的地址类型定义了不同的结构体。</strong></p><h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect() 函数"></a>connect() 函数</h2><p>connect() 函数用来建立连接，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>各个参数的说明和 bind() 相同</p><h1 id="listen-和accept-函数：让套接字进入监听状态并响应客户端请求"><a href="#listen-和accept-函数：让套接字进入监听状态并响应客户端请求" class="headerlink" title="listen()和accept()函数：让套接字进入监听状态并响应客户端请求"></a>listen()和accept()函数：让套接字进入监听状态并响应客户端请求</h1><p>对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。</p><h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen() 函数"></a>listen() 函数</h2><p>通过 listen() 函数可以让套接字进入被动监听状态，它的原型为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int listen(int sock, int backlog);  //Linuxint listen(SOCKET sock, int backlog);  //Windows</span><br></pre></td></tr></table></figure><p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。</p><p>所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p><h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p><p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p><p>如果将 backlog 的值设置为 <strong>SOMAXCONN</strong>，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p><p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</p><p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p><h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept() 函数"></a>accept() 函数</h2><p>当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//LinuxSOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen);  //Windows</span></span><br></pre></td></tr></table></figure><p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p><p>&#x3D;&#x3D;accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。&#x3D;&#x3D;</p><p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p><h1 id="send-recv-和write-read-：发送数据和接收数据"><a href="#send-recv-和write-read-：发送数据和接收数据" class="headerlink" title="send()&#x2F;recv()和write()&#x2F;read()：发送数据和接收数据"></a>send()&#x2F;recv()和write()&#x2F;read()：发送数据和接收数据</h1><h2 id="Linux下数据的接收和发送"><a href="#Linux下数据的接收和发送" class="headerlink" title="Linux下数据的接收和发送"></a>Linux下数据的接收和发送</h2><p>&#x3D;&#x3D;Linux 不区分套接字文件和普通文件&#x3D;&#x3D;，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p><p>&#x3D;&#x3D;<strong>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</strong>&#x3D;&#x3D;</p><p>write() 的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>fd 为要写入的文件的描述符(就是socket套接字)，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。</p><blockquote><p>size_t 是通过 typedef 声明的 unsigned int 类型；ssize_t 在 “size_t” 前面加了一个”s”，代表 signed，即 ssize_t 是通过 typedef 声明的 signed int 类型。</p></blockquote><p>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。</p><p>read() 的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p><p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p><h2 id="Windows下数据的接收和发送"><a href="#Windows下数据的接收和发送" class="headerlink" title="Windows下数据的接收和发送"></a>Windows下数据的接收和发送</h2><p>Windows 和 Linux 不同，Windows 区分普通文件和套接字，并定义了专门的接收和发送的函数。</p><p>从服务器端发送数据使用 send() 函数，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>sock 为要发送数据的套接字，buf 为要发送的数据的缓冲区地址，len 为要发送的数据的字节数，flags 为发送数据时的选项。</p><p>返回值和前三个参数不再赘述，最后的 flags 参数一般设置为 0 或 NULL，初学者不必深究。</p><p>在客户端接收数据使用 recv() 函数，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(SOCKET sock, <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="socket缓冲区以及阻塞模式详解"><a href="#socket缓冲区以及阻塞模式详解" class="headerlink" title="socket缓冲区以及阻塞模式详解"></a>socket缓冲区以及阻塞模式详解</h1><h2 id="socket缓冲区"><a href="#socket缓冲区" class="headerlink" title="socket缓冲区"></a><a href="https://c.biancheng.net/socket/">socket</a>缓冲区</h2><p><strong>&#x3D;&#x3D;每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。&#x3D;&#x3D;</strong></p><p>write()&#x2F;send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p><p>TCP协议独立于 write()&#x2F;send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p><p>read()&#x2F;recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p><p><img src="https://c.biancheng.net/uploads/allimg/190219/1149355056-0.jpg" alt="TCP套接字的I/O缓冲区示意图"></p><p>这些I&#x2F;O缓冲区特性可整理如下：</p><ul><li>I&#x2F;O缓冲区在每个TCP套接字中单独存在；</li><li>I&#x2F;O缓冲区在创建套接字时自动生成；</li><li>即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</li><li>关闭套接字将丢失输入缓冲区中的数据。(剩下的没接收)</li></ul><p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> optVal;</span><br><span class="line"><span class="type">int</span> optLen = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">getsockopt</span>(servSock, SOL_SOCKET, SO_SNDBUF, (<span class="type">char</span>*)&amp;optVal, &amp;optLen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Buffer length: %d\n&quot;</span>, optVal);</span><br></pre></td></tr></table></figure><h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><p>对于TCP套接字（默认情况下），当使用 write()&#x2F;send() 发送数据时：</p><ol><li><p>首先会检查缓冲区，如果缓冲区的可用空间长度&#x3D;&#x3D;小于&#x3D;&#x3D;要发送的数据，那么 write()&#x2F;send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()&#x2F;send() 函数继续写入数据。</p></li><li><p>如果TCP协议&#x3D;&#x3D;正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()&#x2F;send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()&#x2F;send() 才会被唤醒。&#x3D;&#x3D;</p></li><li><p>如果要写入的数据大于缓冲区的最大长度，那么将分批写入。</p></li><li><p>直到所有数据被写入缓冲区 write()&#x2F;send() 才能返回。</p></li></ol><p>当使用 read()&#x2F;recv() 读取数据时：</p><ol><li><p>首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。</p></li><li><p>如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()&#x2F;recv() 函数再次读取。</p></li><li><p>直到读取到数据后 read()&#x2F;recv() 函数才会返回，否则就一直被阻塞。</p></li></ol><p>这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。</p><blockquote><p>TCP套接字默认情况下是阻塞模式，也是最常用的。当然你也可以更改为非阻塞模式，后续我们会讲解。</p></blockquote><h1 id="TCP协议的粘包问题（数据的无边界性）"><a href="#TCP协议的粘包问题（数据的无边界性）" class="headerlink" title="TCP协议的粘包问题（数据的无边界性）"></a>TCP协议的粘包问题（数据的无边界性）</h1><p>上节我们讲到了<a href="https://c.biancheng.net/socket/">socket</a>缓冲区和数据的传递过程，可以看到数据的接收和发送是无关的，read()&#x2F;recv() 函数不管数据发送了多少次，都会尽可能多的接收数据。也就是说，read()&#x2F;recv() 和 write()&#x2F;send() 的执行次数可能不同。</p><p>例如，write()&#x2F;send() 重复执行三次，每次都发送字符串”abc”，那么目标机器上的 read()&#x2F;recv() 可能分三次接收，每次都接收”abc”；也可能分两次接收，第一次接收”abcab”，第二次接收”cabc”；也可能一次就接收到字符串”abcabcabc”。</p><p>假设我们希望客户端每次发送一位学生的学号，让服务器端返回该学生的姓名、住址、成绩等信息，这时候可能就会出现问题，服务器端不能区分学生的学号。例如第一次发送 1，第二次发送 3，服务器可能当成 13 来处理，返回的信息显然是错误的。</p><p>&#x3D;&#x3D;这就是数据的“粘包”问题，客户端发送的多个数据包被当做一个数据包接收。也称数据的无边界性，read()&#x2F;recv() 函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），只把它们当做连续的数据流来处理。&#x3D;&#x3D;</p><p>下面的代码演示了粘包问题，客户端连续三次向服务器端发送数据，服务器端却一次性接收到所有数据。</p><p>server.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET servSock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    <span class="built_in">listen</span>(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//缓冲区</span></span><br><span class="line">    SOCKET clntSock = <span class="built_in">accept</span>(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">10000</span>);  <span class="comment">//注意这里，让程序暂停10秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端发来的数据，并原样返回</span></span><br><span class="line">    <span class="type">int</span> recvLen = <span class="built_in">recv</span>(clntSock, buffer, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">send</span>(clntSock, buffer, recvLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字并终止DLL的使用</span></span><br><span class="line">    <span class="built_in">closesocket</span>(clntSock);</span><br><span class="line">    <span class="built_in">closesocket</span>(servSock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发起请求</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户输入的字符串并发送给服务器</span></span><br><span class="line">    <span class="type">char</span> bufSend[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span>(bufSend);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">send</span>(sock, bufSend, <span class="built_in">strlen</span>(bufSend), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> bufRecv[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">recv</span>(sock, bufRecv, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, bufRecv);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);  <span class="comment">//关闭套接字</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();  <span class="comment">//终止使用 DLL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 server，再运行 client，并在10秒内输入字符串”abc”，再等数秒，服务器就会返回数据。</p><p><img src="/../../typora-user-images/image-20240316155829752.png" alt="image-20240316155829752"></p><p>本程序的关键是 server.cpp 第31行的代码<code>Sleep(10000);</code>，它让程序暂停执行10秒。在这段时间内，client 连续三次发送字符串”abc”，由于 server 被阻塞，数据只能堆积在缓冲区中，10秒后，server 开始运行，从缓冲区中一次性读出所有积压的数据，并返回给客户端。</p><p>另外还需要说明的是 client.cpp 第34行代码。client 执行到 recv() 函数，由于输入缓冲区中没有数据，所以会被阻塞，直到10秒后 server 传回数据才开始执行。用户看到的直观效果就是，client 暂停一段时间才输出 server 返回的结果。</p><p>client 的 send() 发送了三个数据包，而 server 的 recv() 却只接收到一个数据包，这很好的说明了数据的粘包问题。</p><h1 id="图解TCP数据报结构以及三次握手（非常详细）"><a href="#图解TCP数据报结构以及三次握手（非常详细）" class="headerlink" title="图解TCP数据报结构以及三次握手（非常详细）"></a>图解TCP数据报结构以及三次握手（非常详细）</h1><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。</p><p>客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。</p><p>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p><ul><li>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”</li><li>[Shake 2] 套接字B：“好的，我这边已准备就绪。”</li><li>[Shake 3] 套接字A：“谢谢你受理我的请求。”</li></ul><h2 id="TCP数据报结构"><a href="#TCP数据报结构" class="headerlink" title="TCP数据报结构"></a>TCP数据报结构</h2><p>我们先来看一下TCP数据报的结构：<br><img src="https://c.biancheng.net/uploads/allimg/190219/1155315343-0.jpg" alt="img"></p><p>带阴影的几个字段需要重点说明一下：</p><ol><li><p>序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</p></li><li><p>确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，&#x3D;&#x3D;Ack &#x3D; Seq + 1。&#x3D;&#x3D;</p></li><li><p>标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p></li></ol><ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号有效。</li><li>PSH：接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。</li><li>SYN：建立一个新连接。</li><li>FIN：断开一个连接。</li></ul><blockquote><p>对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p></blockquote><h2 id="连接的建立（三次握手）"><a href="#连接的建立（三次握手）" class="headerlink" title="连接的建立（三次握手）"></a>连接的建立（三次握手）</h2><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：</p><p><img src="https://c.biancheng.net/uploads/allimg/190219/1155312401-1.jpg" alt="img"></p><p>客户端调用 <a href="https://c.biancheng.net/socket/">socket</a>() 函数创建套接字后，因为没有建立连接，所以套接字处于<code>CLOSED</code>状态；服务器端调用 listen() 函数后，套接字进入<code>LISTEN</code>状态，开始监听客户端请求。</p><p>这个时候，客户端开始发起请求：</p><ol><li><p>当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了<code>SYN-SEND</code>状态。</p></li><li><p>服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。</p></li></ol><p>服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。</p><p>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。</p><p>服务器将数据包发出，进入<code>SYN-RECV</code>状态。</p><ol start="3"><li>客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。</li></ol><p>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。</p><p>客户端将数据包发出，进入<code>ESTABLISED</code>状态，表示连接已经成功建立。</p><ol start="4"><li>服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入<code>ESTABLISED</code>状态。</li></ol><p>至此，客户端和服务器都进入了<code>ESTABLISED</code>状态，连接建立成功，接下来就可以收发数据了。</p><h2 id="最后的说明"><a href="#最后的说明" class="headerlink" title="最后的说明"></a>最后的说明</h2><p>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看<code>Ack = Seq + 1</code>是否成立，如果成立说明对方正确收到了自己的数据包。</p><h1 id="详细分析TCP数据的传输过程"><a href="#详细分析TCP数据的传输过程" class="headerlink" title="详细分析TCP数据的传输过程"></a>详细分析TCP数据的传输过程</h1><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：</p><p><img src="https://c.biancheng.net/uploads/allimg/190219/115A462I-0.jpg" alt="TCP 套接字的数据交换过程"><br>图1：TCP 套接字的数据交换过程</p><p>上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。</p><blockquote><p>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。</p></blockquote><p>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：</p><p>&#x3D;&#x3D;<strong>Ack号 &#x3D; Seq号 + 传递的字节数 + 1</strong>&#x3D;&#x3D;</p><p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。</p><p>下面分析传输过程中数据包丢失的情况，如下图所示：</p><p><img src="https://c.biancheng.net/uploads/allimg/190219/115A453O-1.jpg" alt="img"><br>图2：TCP套接字数据传输过程中发生错误</p><p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。</p><p>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。</p><blockquote><p>上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。</p></blockquote><h4 id="重传超时时间（RTO-Retransmission-Time-Out）"><a href="#重传超时时间（RTO-Retransmission-Time-Out）" class="headerlink" title="重传超时时间（RTO, Retransmission Time Out）"></a>重传超时时间（RTO, Retransmission Time Out）</h4><p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。</p><blockquote><p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。</p></blockquote><h4 id="重传次数"><a href="#重传次数" class="headerlink" title="重传次数"></a>重传次数</h4><p>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p><p>&#x3D;&#x3D;最后需要说明的是，发送端只有在收到对方的 ACK 确认包后，才会清空输出缓冲区中的数据。&#x3D;&#x3D;</p><h1 id="图解TCP四次握手断开连接"><a href="#图解TCP四次握手断开连接" class="headerlink" title="图解TCP四次握手断开连接"></a>图解TCP四次握手断开连接</h1><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。</p><p>建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：</p><ul><li>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”</li><li>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”</li><li>等待片刻后……</li><li>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”</li><li>[Shake 4] 套接字A：“好的，谢谢合作。”</li></ul><p>下图演示了客户端主动断开连接的场景：</p><p><img src="https://c.biancheng.net/uploads/allimg/190219/115T13926-0.jpg" alt="img"></p><p>建立连接后，客户端和服务器都处于<code>ESTABLISED</code>状态。这时，客户端发起断开连接的请求：</p><ol><li><p>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入<code>FIN_WAIT_1</code>状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p></li><li><p>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入<code>CLOSE_WAIT</code>状态。</p></li></ol><p>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p><ol start="3"><li><p>客户端收到“确认包”后进入<code>FIN_WAIT_2</code>状态，等待服务器准备完毕后再次发送数据包。</p></li><li><p>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入<code>LAST_ACK</code>状态。</p></li><li><p>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入<code>TIME_WAIT</code>状态。</p></li><li><p>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入<code>CLOSED</code>状态。</p></li></ol><h2 id="关于-TIME-WAIT-状态的说明"><a href="#关于-TIME-WAIT-状态的说明" class="headerlink" title="关于 TIME_WAIT 状态的说明"></a>关于 TIME_WAIT 状态的说明</h2><p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p><p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p><p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，&#x3D;&#x3D;服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。&#x3D;&#x3D;那么，要等待多久呢？</p><p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为&#x3D;&#x3D;报文最大生存时间（MSL，Maximum Segment Lifetime）&#x3D;&#x3D;。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，&#x3D;&#x3D;2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。&#x3D;&#x3D;</p><h1 id="shutdown-函数：优雅地断开TCP连接"><a href="#shutdown-函数：优雅地断开TCP连接" class="headerlink" title="shutdown()函数：优雅地断开TCP连接"></a>shutdown()函数：优雅地断开TCP连接</h1><p>调用 close()&#x2F;close<a href="http://c.biancheng.net/socket/">socket</a>() 函数意味着完全断开连接，即不能发送数据也不能接收数据，这种“生硬”的方式有时候会显得不太“优雅”。</p><p><img src="http://c.biancheng.net/uploads/allimg/190219/1350141P8-0.jpg" alt="close()/closesocket() 断开连接"><br>图1：close()&#x2F;closesocket() 断开连接</p><p>上图演示了两台正在进行双向通信的主机。主机A发送完数据后，单方面调用 close()&#x2F;closesocket() 断开连接，之后主机A、B都不能再接受对方传输的数据。实际上，是完全无法调用与数据收发有关的函数。</p><p>一般情况下这不会有问题，但有些特殊时刻，需要只断开一条数据传输通道，而保留另一条。</p><p>使用 shutdown() 函数可以达到这个目的，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span></span>; <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(SOCKET s, <span class="type">int</span> howto)</span></span>; <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>sock 为需要断开的套接字，howto 为断开方式。</p><p>howto 在 Linux 下有以下取值：</p><ul><li>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。</li><li>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。</li><li>SHUT_RDWR：同时断开 I&#x2F;O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。</li></ul><p>howto 在 Windows 下有以下取值：</p><ul><li>SD_RECEIVE：关闭接收操作，也就是断开输入流。</li><li>SD_SEND：关闭发送操作，也就是断开输出流。</li><li>SD_BOTH：同时关闭接收和发送操作。</li></ul><p>至于什么时候需要调用 shutdown() 函数，下节我们会以文件传输为例进行讲解。</p><p><strong>close()&#x2F;closesocket()和shutdown()的区别</strong></p><p>确切地说，close() &#x2F; closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与<a href="http://c.biancheng.net/c/">C语言</a>中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p><p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</p><p>调用 close()&#x2F;closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p><p>默认情况下，close()&#x2F;closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()&#x2F;closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。</p><h1 id="再谈UDP和TCP"><a href="#再谈UDP和TCP" class="headerlink" title="再谈UDP和TCP"></a>再谈UDP和TCP</h1><p>TCP 是面向连接的传输协议，建立连接时要经过三次握手，断开连接时要经过四次握手，中间传输数据时也要回复 ACK 包确认，多种机制保证了数据能够正确到达，不会丢失或出错。</p><p>UDP 是非连接的传输协议，没有建立连接和断开连接的过程，它只是简单地把数据丢到网络中，也不需要 ACK 包确认。</p><p>UDP 传输数据就好像我们邮寄包裹，邮寄前需要填好寄件人和收件人地址，之后送到快递公司即可，但包裹是否正确送达、是否损坏我们无法得知，也无法保证。UDP 协议也是如此，它只管把数据包发送到网络，然后就不管了，如果数据丢失或损坏，发送端是无法知道的，当然也不会重发。</p><p>既然如此，TCP 应该是更加优质的传输协议吧？</p><p>如果只考虑可靠性，TCP 的确比 UDP 好。但 UDP 在结构上比 TCP 更加简洁，不会发送 ACK 的应答消息，也不会给数据包分配 Seq 序号，所以 UDP 的传输效率有时会比 TCP 高出很多，编程中实现 UDP 也比 TCP 简单。</p><p>UDP 的可靠性虽然比不上TCP，但也不会像想象中那么频繁地发生数据损毁，在更加重视传输效率而非可靠性的情况下，UDP 是一种很好的选择。比如视频通信或音频通信，就非常适合采用 UDP 协议；通信时数据必须高效传输才不会产生“卡顿”现象，用户体验才更加流畅，如果丢失几个数据包，视频画面可能会出现“雪花”，音频可能会夹带一些杂音，这些都是无妨的。</p><p>与 UDP 相比，TCP 的生命在于流控制，这保证了数据传输的正确性。</p><p>最后需要说明的是：TCP 的速度无法超越 UDP，但在收发某些类型的数据时有可能接近 UDP。例如，每次交换的数据量越大，TCP 的传输速率就越接近于 UDP。</p><h1 id="基于UDP的服务器端和客户端"><a href="#基于UDP的服务器端和客户端" class="headerlink" title="基于UDP的服务器端和客户端"></a>基于UDP的服务器端和客户端</h1><h2 id="UDP中的服务器端和客户端没有连接"><a href="#UDP中的服务器端和客户端没有连接" class="headerlink" title="UDP中的服务器端和客户端没有连接"></a>UDP中的服务器端和客户端没有连接</h2><p>UDP 不像 TCP，无需在连接状态下交换数据，因此基于 UDP 的服务器端和客户端也无需经过连接过程。也就是说，不必调用 listen() 和 accept() 函数。UDP 中只有创建套接字的过程和数据交换的过程。</p><h2 id="UDP服务器端和客户端均只需1个套接字"><a href="#UDP服务器端和客户端均只需1个套接字" class="headerlink" title="UDP服务器端和客户端均只需1个套接字"></a>UDP服务器端和客户端均只需1个套接字</h2><p>TCP 中，套接字是一对一的关系。如要向 10 个客户端提供服务，那么除了负责监听的套接字外，还需要创建 10 套接字。但在 UDP 中，不管是服务器端还是客户端都只需要 1 个套接字。之前解释 UDP 原理的时候举了邮寄包裹的例子，负责邮寄包裹的快递公司可以比喻为 UDP 套接字，只要有 1 个快递公司，就可以通过它向任意地址邮寄包裹。同样，只需 1 个 UDP 套接字就可以向任意主机传送数据。</p><h2 id="基于UDP的接收和发送函数"><a href="#基于UDP的接收和发送函数" class="headerlink" title="基于UDP的接收和发送函数"></a>基于UDP的接收和发送函数</h2><p>创建好 TCP 套接字后，传输数据时无需再添加地址信息，因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态，每次传输数据都要添加目标地址信息，这相当于在邮寄包裹前填写收件人地址。</p><p>发送数据使用 sendto() 函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;  <span class="comment">//Linuxint </span></span><br><span class="line"><span class="built_in">sendto</span>(SOCKET sock, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> nbytes, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockadr *to, <span class="type">int</span> addrlen);  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>Linux 和 Windows 下的 sendto() 函数类似，下面是详细参数说明：</p><ul><li>sock：用于传输 UDP 数据的套接字；</li><li>buf：保存待传输数据的缓冲区地址；</li><li>nbytes：带传输数据的长度（以字节计）；</li><li>flags：可选项参数，若没有可传递 0；</li><li>to：存有目标地址信息的 sockaddr 结构体变量的地址；</li><li>addrlen：传递给参数 to 的地址值结构体变量的长度。</li></ul><p>UDP 发送函数 sendto() 与TCP发送函数 write()&#x2F;send() 的最大区别在于，sendto() 函数需要向他传递目标地址信息。</p><p>接收数据使用 recvfrom() 函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockadr *from, <span class="type">socklen_t</span> *addrlen)</span></span>;  <span class="comment">//Linux</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recvfrom</span><span class="params">(SOCKET sock, <span class="type">char</span> *buf, <span class="type">int</span> nbytes, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *from, <span class="type">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>由于 UDP 数据的发送端不定，所以 recvfrom() 函数定义为可接收发送端信息的形式，具体参数如下：</p><ul><li>sock：用于接收 UDP 数据的套接字；</li><li>buf：保存接收数据的缓冲区地址；</li><li>nbytes：可接收的最大字节数（不能超过 buf 缓冲区的大小）；</li><li>flags：可选项参数，若没有可传递 0；</li><li>from：存有发送端地址信息的 sockaddr 结构体变量的地址；</li><li>addrlen：保存参数 from 的结构体变量长度的变量地址值。</li></ul><h2 id="基于UDP的回声服务器端-客户端"><a href="#基于UDP的回声服务器端-客户端" class="headerlink" title="基于UDP的回声服务器端&#x2F;客户端"></a>基于UDP的回声服务器端&#x2F;客户端</h2><p>下面结合之前的内容实现回声客户端。需要注意的是，UDP 不同于 TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端，只是因为其提供服务而称为服务器端，希望各位读者不要误解。</p><p>下面给出 Windows 下的代码，Linux 与此类似，不再赘述。</p><p>服务器端 server.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>( <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    servAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">//自动获取IP地址</span></span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    <span class="built_in">bind</span>(sock, (SOCKADDR*)&amp;servAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;  <span class="comment">//客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> nSize = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];  <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> strLen = <span class="built_in">recvfrom</span>(sock, buffer, BUF_SIZE, <span class="number">0</span>, &amp;clntAddr, &amp;nSize);</span><br><span class="line">        <span class="built_in">sendto</span>(sock, buffer, strLen, <span class="number">0</span>, &amp;clntAddr, nSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><p>第 12 行代码在创建套接字时，向 socket() 第二个参数传递 SOCK_DGRAM，以指明使用 UDP 协议。</p></li><li><p>第 18 行代码中使用<code>htonl(INADDR_ANY)</code>来自动获取 IP 地址。</p></li></ol><p>利用常数 INADDR_ANY 自动获取 IP 地址有一个明显的好处，就是当软件安装到其他服务器或者服务器 IP 地址改变时，不用再更改源码重新编译，也不用在启动软件时手动输入。而且，如果一台计算机中已分配多个 IP 地址（例如路由器），那么只要端口号一致，就可以从不同的 IP 地址接收数据。所以，服务器中优先考虑使用 INADDR_ANY；而客户端中除非带有一部分服务器功能，否则不会采用。</p><p>客户端 client.cpp：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(servAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    servAddr.sin_family = PF_INET;</span><br><span class="line">    servAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    servAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断获取用户输入并发送给服务器，然后接受服务器数据</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span> fromAddr;</span><br><span class="line">    <span class="type">int</span> addrLen = <span class="built_in">sizeof</span>(fromAddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">        <span class="built_in">gets</span>(buffer);</span><br><span class="line">        <span class="built_in">sendto</span>(sock, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;servAddr, <span class="built_in">sizeof</span>(servAddr));</span><br><span class="line">        <span class="type">int</span> strLen = <span class="built_in">recvfrom</span>(sock, buffer, BUF_SIZE, <span class="number">0</span>, &amp;fromAddr, &amp;addrLen);</span><br><span class="line">        buffer[strLen] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(sock);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行 server，再运行 client，client 输出结果为：</p><p>Input a string: C语言中文网<br>Message form server: C语言中文网<br>Input a string: c.biancheng.net Founded in 2012<br>Message form server: c.biancheng.net Founded in 2012<br>Input a string:</p><p>从代码中可以看出，server.cpp 中没有使用 listen() 函数，client.cpp 中也没有使用 connect() 函数，因为 UDP 不需要连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Qt基础</title>
      <link href="/2024/09/26/Qt%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/09/26/Qt%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="1-Qt概述"><a href="#1-Qt概述" class="headerlink" title="1. Qt概述"></a>1. Qt概述</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>是一个跨平台的C++应用程序开发框架<br>具有短平快的优秀特质: 投资少、周期短、见效快、效益高<br>几乎支持所有的平台, 可用于桌面程序开发以及嵌入式开发<br>有属于自己的事件处理机制<br>可以搞效率的开发基于窗口的应用程序。<br>Qt是标准 C++ 的扩展, C++的语法在Qt中都是支持的<br>良好封装机制使得 Qt 的模块化程度非常高，可重用性较好，可以快速上手。<br>Qt 提供了一种称为 signals&#x2F;slots 的安全类型来替代 callback（回调函数），这使得各个元件 之间的协同工作变得十分简单。</p><h2 id="1-2-Qt的特点"><a href="#1-2-Qt的特点" class="headerlink" title="1.2 Qt的特点"></a>1.2 Qt的特点</h2><p>广泛用于开发GUI程序，也可用于开发非GUI程序。<br>GUI &#x3D; Graphical User Interface<br>也就是基于窗口的应用程序开发。<br>有丰富的 API<br>Qt 包括多达 250 个以上的 C++ 类<br>可以处理正则表达式。<br>支持 2D&#x2F;3D 图形渲染，支持 OpenGL<br>Qt给程序猿提供了非常详细的官方文档<br>支持XML，Json<br>框架底层模块化， 使用者可以根据需求选择相应的模块来使用<br>可以轻松跨平台<br>和Java的跨平台方式不同<br>在不同的平台使用的是相同的上层接口，但是在底层封装了不同平台对应的API（暗度陈仓）。</p><h2 id="1-3-Qt中的模块"><a href="#1-3-Qt中的模块" class="headerlink" title="1.3 Qt中的模块"></a>1.3 Qt中的模块</h2><p>Qt 基本模块（Qt Essentials)：提供了 Qt 在所有平台上的基本功能。<br>Qt 附加模块（Qt Add-Ons)：实现一些特定功能的提供附加价值的模块。<br>增值模块（Value-AddModules)：单独发布的提供额外价值的模块或工具。<br>技术预览模块（Technology Preview Modules）：一些处于开发阶段，但是可以作为技术预览使用的模块。<br>Qt 工具（Qt Tools)：帮助应用程序开发的一些工具。</p><table><thead><tr><th>模块</th><th>描述</th></tr></thead><tbody><tr><td>Qt Core</td><td>Qt 类库的核心，所有其他模块都依赖于此模块</td></tr><tr><td>Qt GUI</td><td>设计 GUI 界面的基础类，包括 OpenGL</td></tr><tr><td>Qt Multimedia</td><td>音频、视频、摄像头和广播功能的类</td></tr><tr><td>Qt Multimedia Widgets</td><td>实现多媒体功能的界面组件类</td></tr><tr><td>Qt Network</td><td>使网络编程更简单和轻便的类</td></tr><tr><td>Qt QML</td><td>用于 QML 和 JavaScript语言的类</td></tr><tr><td>Qt Quick</td><td>用于构建具有定制用户界面的动态应用程序的声明框架</td></tr><tr><td>Qt Quick Controls</td><td>创建桌面样式用户界面，基于 Qt Quick 的用户界面控件</td></tr><tr><td>Qt Quick Dialogs</td><td>用于 Qt Quick 的系统对话框类型</td></tr><tr><td>Qt Quick Layouts</td><td>用于 Qt Quick 2 界面元素的布局项</td></tr><tr><td>Qt SQL</td><td>使用 SQL 用于数据库操作的类</td></tr><tr><td>Qt Test</td><td>用于应用程序和库进行单元测试的类</td></tr><tr><td>Qt Widgets</td><td>用于构建 GUI 界面的 C++ 图形组件类</td></tr></tbody></table><h2 id="1-4-Qt案例"><a href="#1-4-Qt案例" class="headerlink" title="1.4 Qt案例"></a>1.4 Qt案例</h2><p>VirtualBox：虚拟机软件。<br>VLC多媒体播放器：一个体积小巧、功能强大的开源媒体播放器。<br>YY语音：又名“歪歪语音”，是一个可以进行在线多人语音聊天和语音会议的免费软件。<br>咪咕音乐：咪咕音乐是中国移动倾力打造的正版音乐播放器<br>WPS Office：金山公司（Kingsoft）出品的办公软件，与微软Office兼容性良好，个人版免费。<br>Skype：一个使用人数众多的基于P2P的VOIP聊天软件。</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-安装包下载"><a href="#2-1-安装包下载" class="headerlink" title="2.1 安装包下载"></a>2.1 安装包下载</h2><p>Qt官方下载地址：<a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a></p><p>通过上边提供的地址打开Qt的下载页面，如下图：</p><p><img src="https://subingwen.cn/qt/qt-primer/Qt%E7%9A%84%E7%89%88%E6%9C%AC-b931e047c4ba41dca1e30b6db1204bf5.jpg" alt="Qt的版本"></p><p>选择需要的版本，通过链接进入下载页面</p><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909110702957-97e06c9ef302421ca21100e9f79044aa.png" alt="Qt安装包下载"></p><p>据自己的需求下载不同平台对应的版本就可以了。</p><p>由于官方服务器在国外, 不太稳定, 有时候无法访问, 可以通过国内几个著名的高校提供的 Qt 镜像网站进行下载:</p><p>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/qtproject/">http://mirrors.ustc.edu.cn/qtproject/</a><br>清华大学：<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/">https://mirrors.tuna.tsinghua.edu.cn/qt/</a><br>北京理工大学：<a href="https://mirrors.bit.edu.cn/qtproject/">https://mirrors.bit.edu.cn/qtproject/</a><br>中国互联网络信息中心：<a href="https://mirrors.cnnic.cn/qt/">https://mirrors.cnnic.cn/qt/</a></p><p>找到archive&#x2F;目录下载离线安装包即可, 以中国互联网络信息中心为例:</p><p><img src="https://subingwen.cn/qt/qt-primer/image-3d90549cdb6c462288f8246efcb12b83.png" alt="img"></p><h2 id="2-2-安装（windows）"><a href="#2-2-安装（windows）" class="headerlink" title="2.2 安装（windows）"></a>2.2 安装（windows）</h2><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909111608469-f10686a30af341b9859aa655f1d4c965.png" alt="img"></p><p>填写Qt账号登录信息, 如果没有就注册一个</p><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909111958261-ebafb49c8bb244e0bc6049430619e977.png" alt="账号登录"></p><p>指定Qt的安装目录, 安装文件需要占用比较大的磁盘空间</p><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909112238150-1d9c70ebb75545d1970b2ac143d018c9.png" alt="指定安装目录"></p><p>接下来需要选择IDE使用的编译套件的版本:</p><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909112910533-322d51b5b2b743e8bd99f1e924038aeb.png" alt="选择编译套件"></p><p>关于这些编译套件跟大家做一个介绍，安装过程中根据自己的情况酌情选择即可。</p><p>MSVC2015 64-bit: Visual Studio 2015 使用的64位编译套件</p><p>MSVC2017 32-bit: Visual Studio 2017 使用的32位编译套件</p><p>MSVC2017 64-bit: Visual Studio 2017 使用的64位编译套件</p><p>MinGW7.3.0 32-bit: QtCreator 使用的32位编译套件</p><p>MinGW7.3.0 64-bit: QtCreator 使用的64位编译套件</p><p>UWP –&gt; Universal Windows Platform: 用于window平台应用程序开发的编译套件</p><p>UWP 即Windows通用应用平台，在Windows 10 Mobile&#x2F;Surface（Windows平板电脑）&#x2F; PC&#x2F;Xbox&#x2F;HoloLens等平台上运行，uwp不同于传统pc上的exe应用，也跟只适用于手机端的app有本质区别。它并不是为某一个终端而设计，而是可以在所有Windows10设备上运行。</p><p>在这个窗口中除了选择必要的编译套件，还有一些非必要组件，常用的有以下两个：</p><p>Source: Qt源码, 另外Qt的一些模块运行需要的驱动没有提供现成的动态库需要自己编译, 建议安装</p><p>Qt Charts: 用于绘制统计数据对应的图表, 比如: 折线图&#x2F;曲线图等</p><h2 id="2-3-环境变量设置"><a href="#2-3-环境变量设置" class="headerlink" title="2.3 环境变量设置"></a>2.3 环境变量设置</h2><p><code>当我们编写一个Qt程序，并且生成了可执行程序，这个可执行程序运行的时候默认需要加载相关的Qt动态库（因为默认是动态链接，静态链接则不需要）。为了保证可执行程序在任何目录执行都能链接到对应的动态库，我们可以将Qt模块对应的动态库目录设置到系统的环境变量中（这一点对于Linux系统也是一样的）。</code></p><p>1.在桌面找到我的电脑（此电脑）图标，鼠标右键，打开属性窗口</p><p><img src="https://subingwen.cn/qt/qt-primer/image-20200909132112058-4f113593749148d596ace60593f33e82.png" alt="img"></p><p>在属性窗口中选择 “高级系统设置”</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011100506.png" alt="image-20200909132259861-ec26d0d5c2574940a1d0c59193401761"></p><p>打开环境变量窗口</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011100410.png" alt="img"></p><p>新建环境变量</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011101334.png" alt="img"></p><p>将Qt的相关目录添加到系统环境变量中</p><p>环境变量说明:</p><p>找到Qt的安装目录: C:</p><p>在安装目录中找到Qt库的bin目录: C:\Qt\Qt5.14.2\5.14.2\mingw73_32\bin</p><p>在安装目录中找到编译套件的bin目录: C:\Qt\Qt5.14.2\Tools\mingw730_32\bin</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011101072.png" alt="img"></p><h2 id="2-4-QtCreator"><a href="#2-4-QtCreator" class="headerlink" title="2.4 QtCreator"></a>2.4 QtCreator</h2><p>QtCreator是编写Qt程序默认使用的一款 IDE，使用VS写Qt程序也是可以的，在此不做介绍。</p><p>使用QtCreator创建的项目目录中不能包含中文</p><p>QtCreator默认使用Utf8格式编码对文件字符进行编码</p><p>字符必须编码后才能被计算机处理</p><p>为了处理汉字，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。</p><p>GB2312 支持的汉字太少，1995年的汉字扩展规范GBK1.0，支持了更多的汉字。</p><p>2000年的 GB18030取代了GBK1.0成为了正式的国家标准。</p><p>Unicode 也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案</p><p>utf8<br>utf16<br>vs写Qt程序默认使用的本地编码 -&gt; gbk</p><p>修改QtCreator的编码, 菜单栏 -&gt; 工具</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011101368.png" alt="img"></p><p>在弹出的选项窗口中设置文件编码, 默认为 utf8</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011102011.png" alt="查看或修改QtCreator编码"></p><p>QtCreator主界面介绍</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011102466.png" alt="QtCreator主界面"></p><p>通过QtCreator可以直接查阅Qt的帮助文档, 里边对Qt框架提供的API做了非常详尽的介绍, 查询方式如下图所示:</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011103376.png" alt="查阅帮助文档"></p><p>默认的编译套件</p><p>MinGW -&gt; Minimalist GNU for Windows</p><p>MinGW 提供了一套简单方便的Windows下的基于GCC 程序开发环境。MinGW 收集了一系列免费的Windows 使用的头文件和库文件；<br>整合了GNU的工具集，特别是GNU 程序开发工具，如经典gcc, g++, make等。<br>MinGW是完全免费的自由软件，它在Windows平台上模拟了Linux下GCC的开发环境，为C++ 的跨平台开发提供了良好基础支持，为了在Windows下工作的程序员熟悉Linux下的C++工程组织提供了条件。</p><h1 id="3-第一个Qt项目"><a href="#3-第一个Qt项目" class="headerlink" title="3. 第一个Qt项目"></a>3. 第一个Qt项目</h1><h2 id="3-1-创建项目"><a href="#3-1-创建项目" class="headerlink" title="3.1 创建项目"></a>3.1 创建项目</h2><p>创建基于窗口的Qt应用程序</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011115406.png" alt="img"></p><p>指定项目的存储路径</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011115067.png" alt="img"></p><p>项目名称根据需求自己指定即可<br>&#x3D;&#x3D;在指定项目的存储路径的时候, 路径中不能包含中文, 不能包含中文, 不能包含中文&#x3D;&#x3D;</p><p>指定默认的窗口类的名字以及窗口的类型</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011117619.png" alt="img"></p><p>选择编译套件, 编译套件用于项目文件的编译, 如果安装了多个编译套件, 在这里选择其中一个就可以了。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011118959.png" alt="img"></p><p>选择版本控制工具, 比如: git, svn 等, 可以不指定。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011121508.png" alt="img"></p><h2 id="3-2-项目文件（-pro）"><a href="#3-2-项目文件（-pro）" class="headerlink" title="3.2 项目文件（.pro）"></a>3.2 项目文件（.pro）</h2><p>在创建的Qt项目中自动生成了一个后缀为 .pro 的项目文件，该文件中记录着项目的一些属性信息，具体信息如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line">CONFIG += c++11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following define makes your compiler emit warnings <span class="keyword">if</span> you use</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">any Qt feature that has been marked deprecated (the exact warnings</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">depend on your compiler). Please consult the documentation of the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deprecated API <span class="keyword">in</span> order to know how to port your code away from it.</span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also make your code fail to compile <span class="keyword">if</span> it uses deprecated APIs.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">In order to <span class="keyword">do</span> so, uncomment the following line.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also <span class="keyword">select</span> to <span class="built_in">disable</span> deprecated APIs only up to a certain version of Qt.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    <span class="comment"># disables all the APIs deprecated before Qt 6.0.0</span></span></span><br><span class="line"></span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mainwindow.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += \</span><br><span class="line">    mainwindow.h</span><br><span class="line"></span><br><span class="line">FORMS += \</span><br><span class="line">    mainwindow.ui</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default rules <span class="keyword">for</span> deployment.</span></span><br><span class="line">qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin</span><br><span class="line">else: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin</span><br><span class="line">!isEmpty(target.path): INSTALLS += target</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3-main-cpp"><a href="#3-3-main-cpp" class="headerlink" title="3.3 main.cpp"></a>3.3 main.cpp</h2><p>在这个源文件中有程序的入口函数 main()，下面给大家介绍下这个文件中自动生成的几行代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span><span class="comment">// 生成的窗口类头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">// 应用程序类头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建应用程序对象, 在一个Qt项目中实例对象有且仅有一个</span></span><br><span class="line">    <span class="comment">// 类的作用: 检测触发的事件, 进行事件循环并处理</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">// 创建窗口类对象</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// 应用程序对象开始事件循环, 保证应用程序不退出</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-4-mainwindow-ui"><a href="#3-4-mainwindow-ui" class="headerlink" title="3.4 mainwindow.ui"></a>3.4 mainwindow.ui</h2><p><code>在Qt中每一个窗口都对应一个可编辑的可视化界面（*.ui）, 这个界面对应的是一个xml格式的文件, 一般情况下不需要在xml格式下对这个文件进行编辑, 关于这个文件结构了解即可。</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui</span> <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">class</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMainWindow&quot;</span> <span class="attr">name</span>=<span class="string">&quot;MainWindow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span>&gt;</span>600<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;windowTitle&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>MainWindow<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QWidget&quot;</span> <span class="attr">name</span>=<span class="string">&quot;centralwidget&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QMenuBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;menubar&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;geometry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">x</span>&gt;</span>0<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">y</span>&gt;</span>0<span class="tag">&lt;/<span class="name">y</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">width</span>&gt;</span>800<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">height</span>&gt;</span>26<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">widget</span> <span class="attr">class</span>=<span class="string">&quot;QStatusBar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;statusbar&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">widget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">resources</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">connections</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-5-mainwindow-h"><a href="#3-5-mainwindow-h" class="headerlink" title="3.5 mainwindow.h"></a>3.5 mainwindow.h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span><span class="comment">// Qt标准窗口类头文件</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="comment">// mainwindow.ui 文件中也有一个类叫 MainWindow, 将这个类放到命名空间 Ui 中</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT<span class="comment">// 这个宏是为了能够使用Qt中的信号槽机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;<span class="comment">// 定义指针指向窗口的 UI 对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-6-mainwindow-cpp"><a href="#3-6-mainwindow-cpp" class="headerlink" title="3.6 mainwindow.cpp"></a>3.6 mainwindow.cpp</h2><p>这个文件是窗口界面对应的类的源文件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)<span class="comment">// 基于mainwindow.ui创建一个实例对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 mainwindow.ui 的实例对象和 当前类的对象进行关联</span></span><br><span class="line">    <span class="comment">// 这样同名的连个类对象就产生了关联, 合二为一了</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-Qt中的窗口类"><a href="#4-Qt中的窗口类" class="headerlink" title="4. Qt中的窗口类"></a>4. Qt中的窗口类</h1><h2 id="4-1-基础窗口类"><a href="#4-1-基础窗口类" class="headerlink" title="4.1 基础窗口类"></a>4.1 基础窗口类</h2><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011137511.png" alt="窗口类继承关系"></p><p>常用的窗口类有3个<br>在创建Qt窗口的时候, 需要让自己的窗口类继承上述三个窗口类的其中一个<br><strong>QWidget</strong><br>所有窗口类的基类<br>Qt中的控件(按钮, 输入框, 单选框…)也属于窗口, 基类都是QWidget<br>可以内嵌到其他窗口中: 没有边框<br>可以不内嵌单独显示: 独立的窗口, 有边框<br><strong>QDialog</strong><br>对话框类, 后边的章节会具体介绍这个窗口<br>不能内嵌到其他窗口中<br><strong>QMainWindow</strong><br>有工具栏, 状态栏, 菜单栏, 后边的章节会具体介绍这个窗口<br>不能内嵌到其他窗口中</p><h2 id="4-2-窗口的显示"><a href="#4-2-窗口的显示" class="headerlink" title="4.2 窗口的显示"></a>4.2 窗口的显示</h2><p><strong>内嵌窗口</strong></p><p>依附于某一个大的窗口, 作为了大窗口的一部分<br>大窗口就是这个内嵌窗口的父窗口<br>父窗口显示的时候, 内嵌的窗口也就被显示出来了<br><strong>不内嵌窗口</strong></p><p>这类窗口有边框, 有标题栏</p><p>需要调用函数才可以显示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QWidget是所有窗口类的基类, 调用这个提供的 show() 方法就可以显示将任何窗口显示出来</span></span><br><span class="line"><span class="comment">// 非模态显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::show</span><span class="params">()</span></span>;<span class="comment">// 显示当前窗口和它的子窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框窗口的非模态显示: 还是调用show() 方法</span></span><br><span class="line"><span class="comment">// 对话框窗口的模态显示</span></span><br><span class="line">[<span class="keyword">virtual</span> slot] <span class="function"><span class="type">int</span> <span class="title">QDialog::exec</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="5-坐标体系"><a href="#5-坐标体系" class="headerlink" title="5. 坐标体系"></a>5. 坐标体系</h1><p>在Qt关于窗口的显示是需要指定位置的，这个位置是通过坐标来确定的，所有坐标的选取又都是基于坐标原点来确定的，关于这些细节的确定，下面依次给大家进行讲解。</p><h2 id="5-1-窗口的坐标原点"><a href="#5-1-窗口的坐标原点" class="headerlink" title="5.1 窗口的坐标原点"></a>5.1 窗口的坐标原点</h2><p>所有坐标的确定都需要先找到坐标原点, Qt的坐标原点在窗口的左上角</p><p>x轴向右递增</p><p>y轴向下递增</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011156128.png" alt="坐标原点"></p><h2 id="5-2-窗口的相对坐标"><a href="#5-2-窗口的相对坐标" class="headerlink" title="5.2 窗口的相对坐标"></a>5.2 窗口的相对坐标</h2><p>在一个Qt窗口中一般都有很多子窗口内嵌到这个父窗口中，其中每个窗口都有自己的坐标原点，子窗口的位置也就是其使用的坐标点就是它的父窗口坐标体系中的坐标点。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404011157163.png" alt="子窗口使用父窗口的坐标体系"></p><p>在Qt的某一个窗口中有可能有若干个控件, 这个控件都是嵌套的关系</p><p>A窗口包含B窗口, B窗口包含C窗口<br>每个窗口都有坐标原点, 在左上角</p><p>子窗口的位置是基于父窗口的坐标体系来确定的, 也就是说通过父窗口左上角的坐标点来确定自己的位置<br>Qt中窗口显示的时候使用的相对坐标, 相对于自己的父窗口</p><p>将子窗口移动到父窗口的某个位置</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有窗口类的基类: QWidget</span></span><br><span class="line"><span class="comment">// QWidget中提供了移动窗口的 API函数</span></span><br><span class="line"><span class="comment">// 参数 x, y是要移动的窗口的左上角的点, 窗口的左上角移动到这个坐标点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidget::move</span><span class="params">(<span class="type">const</span> QPoint &amp;)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/26/hello-world/"/>
      <url>/2024/09/26/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VS2022远程连接ubuntu使用Cmake</title>
      <link href="/2024/09/26/Cmake%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/09/26/Cmake%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="如何使用VS2022远程连接ubuntu使用Cmake"><a href="#如何使用VS2022远程连接ubuntu使用Cmake" class="headerlink" title="如何使用VS2022远程连接ubuntu使用Cmake"></a>如何使用VS2022远程连接ubuntu使用Cmake</h1><h2 id="安装Cmake"><a href="#安装Cmake" class="headerlink" title="安装Cmake"></a>安装Cmake</h2><blockquote><ul><li><p>Windows端</p></li><li><p>首先在CMake官网下载安装包，官网地址：<a href="https://cmake.org/%EF%BC%8C%E7%82%B9%E5%87%BBDownload%E3%80%82">https://cmake.org/，点击Download。</a></p></li><li><p>安装完毕，进行测试。<br>打开cmd黑窗，输入命令查看版本</p><p>cmake &#x2F;V</p></li></ul></blockquote><blockquote><ul><li><p>Ubuntu</p></li><li><p>方法1，使用apt（不建议，版本过低）<br>sudo apt-get install cmake</p></li><li><p>方法2，官网下载压缩包根据版本下载后缀是.tar.gz（可用wget下载）</p><p>执行下面命令<br>tar -xzvf cmake-3.xx.x-Linux-x86_64.tar.gz<br>看自己版本</p><p>如何再进入解压的文件夹里执行<br>.&#x2F;bootstrap<br>或者<br>.&#x2F;configure</p><p>再执行<br>make -j8</p><p>sudo make install</p><p>最后检查版本是否安装成功</p><p>cmake –version</p></li></ul></blockquote><p>使用Cmake远程连接Ubuntu要求两端都要有Cmake</p><h2 id="安装ninja"><a href="#安装ninja" class="headerlink" title="安装ninja"></a>安装ninja</h2><p>方法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ninja-build</span><br></pre></td></tr></table></figure><p>方法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ninja-build/ninja.git</span><br><span class="line">cd ninja</span><br><span class="line">./configure.py --bootstrap</span><br><span class="line">sudo install ninja /usr/local/bin/</span><br></pre></td></tr></table></figure><h2 id="建立连接及一些设置"><a href="#建立连接及一些设置" class="headerlink" title="建立连接及一些设置"></a>建立连接及一些设置</h2><p>然后在VS2022新建一个Cmake项目</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162110036.png" alt="image-20240416211007880"></p><p>在工具栏里点击工具-》选项》跨平台-》连接管理器添加连接</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162112285.png" alt="image-20240416211223195"></p><p>添加连接 HostName是Ubuntu的ip地址，username是Ubuntu的账号名，但是Cmake在远程连接执行的时候需要ninja的，需要管理员权限，最好使用管理员账号</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162112126.png" alt="image-20240416211252042"></p><p>然后在连接管理器下面的远程标头管理器中点击下载或者更新</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162118684.png" alt="image-20240416211837617"></p><p>再更改一些设置</p><p><strong>选择Cmake-》常规</strong></p><p>选择从不使用cmake预设</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162123514.png" alt="image-20240416212310461"></p><p>打开项目的cmake设置</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162119542.png" alt="image-20240416211935485"></p><p>点击红叉删除默认的再点击加号添加你所需的配置，例如我的Linux-GCC-Debug</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162121875.png" alt="image-20240416212114762"></p><p>选择启动项运行即可，可以自己更改CmakeList.txt根据自己所需</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202404162125195.png" alt="image-20240416212523149"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程</title>
      <link href="/2024/09/26/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/09/26/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++多线程"></a>C++多线程</h1><h2 id="处理日期和时间的chrono类"><a href="#处理日期和时间的chrono类" class="headerlink" title="处理日期和时间的chrono类"></a>处理日期和时间的chrono类</h2><h3 id="时间间隔duration"><a href="#时间间隔duration" class="headerlink" title="时间间隔duration"></a>时间间隔duration</h3><p>1.1 常用类成员<br>duration表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。duration的原型如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;chrono&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rep</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>class duration;<br>Rep：这是一个数值类型，表示时钟数（周期）的类型（默认为整形）。若 Rep 是浮点数，则 duration 能使用小数描述时钟周期的数目。</p></blockquote><p>Period：表示时钟的周期，它的原型如下：</p><p>C++<br>&#x2F;&#x2F; 定义于头文件 <ratio><br>template&lt;<br>    std::intmax_t Num,<br>    std::intmax_t Denom &#x3D; 1</ratio></p><blockquote><p>class ratio;<br>ratio类表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，该分母值默认为1，因此，ratio代表的是一个分子除以分母的数值，比如：ratio&lt;2&gt;代表一个时钟周期是2秒，ratio&lt;60&gt;代表一分钟，ratio&lt;60*60&gt;代表一个小时，ratio&lt;60*60*24&gt;代表一天。而ratio&lt;1,1000&gt;代表的是1&#x2F;1000秒，也就是1毫秒，ratio&lt;1,1000000&gt;代表一微秒，ratio&lt;1,1000000000&gt;代表一纳秒。</p><p>&#x3D;&#x3D;为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于chrono命名空间下，定义如下：&#x3D;&#x3D;</p></blockquote><p><img src="/../typora-user-images/image-20240314141213268.png" alt="image-20240314141213268"></p><p>duration类的构造函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 拷贝构造函数</span></span><br><span class="line"><span class="built_in">duration</span>( <span class="type">const</span> duration&amp; ) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 2. 通过指定时钟周期的类型来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> Rep2&amp; r )</span></span>;</span><br><span class="line"><span class="comment">// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep2, <span class="keyword">class</span> Period2 &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">duration</span><span class="params">( <span class="type">const</span> duration&lt;Rep2,Period2&gt;&amp; d )</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314141322076.png" alt="image-20240314141322076"></p><p>&#x3D;&#x3D;duration类还提供了获取时间间隔的时钟周期数的方法count()，函数原型如下：&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::hours <span class="title">h</span><span class="params">(<span class="number">1</span>)</span></span>;                          <span class="comment">// 一小时</span></span><br><span class="line">    chrono::milliseconds ms&#123; <span class="number">3</span> &#125;;                <span class="comment">// 3 毫秒</span></span><br><span class="line">    chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">1000</span>&gt;&gt; <span class="built_in">ks</span>(<span class="number">3</span>);    <span class="comment">// 3000 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// chrono::duration&lt;int, ratio&lt;1000&gt;&gt; d3(3.5);  // error</span></span><br><span class="line">    <span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">dd</span><span class="params">(<span class="number">6.6</span>)</span></span>;               <span class="comment">// 6.6 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用小数表示时钟周期的次数</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz</span>(<span class="number">3.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314141527863.png" alt="image-20240314141527863"></p><p>由于在duration类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理</p><p><img src="/../typora-user-images/image-20240314141606792.png" alt="image-20240314141606792"></p><p>&#x3D;&#x3D;注意事项：duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有ratio&lt;x1,y1&gt; 和 ratio&lt;x2,y2&gt;两个时钟周期，首先需要求出x1，x2的最大公约数X，然后求出y1，y2的最小公倍数Y，统一之后的时钟周期ratio为ratio&lt;X,Y&gt;.&#x3D;&#x3D;</p><p><img src="/../typora-user-images/image-20240314141751975.png" alt="image-20240314141751975"></p><h3 id="时间的time-point"><a href="#时间的time-point" class="headerlink" title="时间的time point"></a>时间的time point</h3><p><img src="/../typora-user-images/image-20240314141931338.png" alt="image-20240314141931338"></p><p>&#x3D;&#x3D;在这个类中除了构造函数还提供了另外一个time_since_epoch()函数，用来获得1970年1月1日到time_point对象中记录的时间经过的时间间隔（duration），函数原型如下：&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">duration <span class="title">time_since_epoch</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>除此之外，时间点time_point对象和时间段对象duration之间还支持直接进行算术运算（即加减运算），时间点对象之间可以进行逻辑运算，具体细节可以参考下面的表格：</strong>&#x3D;&#x3D;</p><p>其中 tp 和 tp2 是time_point 类型的对象， dtn 是duration类型的对象。</p><p><img src="/../typora-user-images/image-20240314142349407.png" alt="image-20240314142349407"></p><h3 id="时钟clocks"><a href="#时钟clocks" class="headerlink" title="时钟clocks"></a>时钟clocks</h3><p>chrono库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：</p><p>​·system_clock：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。<br>​·steady_clock：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时<br>​·high_resolution_clock：和时钟类 steady_clock 是等价的（是它的别名）。<br>在这些时钟类的内部有time_point、duration、Rep、Period等信息，基于这些信息来获取当前时间，以及实现time_t和time_point之间的相互转换。</p><p><img src="/../typora-user-images/image-20240314142628642.png" alt="image-20240314142628642"></p><p>&#x3D;&#x3D;在使用chrono提供的时钟类的时候，不需要创建类对象，直接调用类的静态方法就可以得到想要的时间了。&#x3D;&#x3D;</p><h4 id="system-clock"><a href="#system-clock" class="headerlink" title="system_clock"></a>system_clock</h4><p>底层源码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">system_clock</span> &#123; <span class="comment">// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = ratio&lt;<span class="number">1</span>, <span class="number">10&#x27;000&#x27;000</span>&gt;; <span class="comment">// 100 nanoseconds</span></span><br><span class="line">    <span class="keyword">using</span> duration                  = chrono::duration&lt;rep, period&gt;;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;system_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 返回表示当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 time_point 时间点类型转换为 std::time_t 类型</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 将 std::time_t 类型转换为 time_point 时间点类型</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// get current time</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Xtime_get_ticks()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> <span class="type">__time64_t</span> <span class="title">to_time_t</span><span class="params">(<span class="type">const</span> time_point&amp; _Time)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// convert to __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;seconds&gt;(_Time.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">from_time_t</span><span class="params">(<span class="type">__time64_t</span> _Tm)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// convert from __time64_t</span></span><br><span class="line">        <span class="keyword">return</span> time_point&#123;seconds&#123;_Tm&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314143107042.png" alt="image-20240314143107042"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;thread&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system_clock::time_point epoch;</span><br><span class="line"></span><br><span class="line">    duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; <span class="built_in">day</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 1天</span></span><br><span class="line">    <span class="function">system_clock::time_point <span class="title">ppt</span><span class="params">(day)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> dday = duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt;;</span><br><span class="line">    <span class="comment">// 新纪元1970.1.1时间 + 10天</span></span><br><span class="line">    <span class="function">time_point&lt;system_clock, dday&gt; <span class="title">t</span><span class="params">(dday(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统当前时间</span></span><br><span class="line">    system_clock::time_point today = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为time_t时间类型</span></span><br><span class="line">    <span class="type">time_t</span> tm = system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;今天的日期是:    &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm1 = system_clock::<span class="built_in">to_time_t</span>(today+day);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;明天的日期是:    &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm1);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm2 = system_clock::<span class="built_in">to_time_t</span>(epoch);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间:      &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm2);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm3 = system_clock::<span class="built_in">to_time_t</span>(ppt);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间+1天:  &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm3);</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> tm4 = system_clock::<span class="built_in">to_time_t</span>(t);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;新纪元时间+10天: &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;tm4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314143808026.png" alt="image-20240314143808026"></p><h4 id="steady-clock"><a href="#steady-clock" class="headerlink" title="steady_clock"></a>steady_clock</h4><p>通过时钟不是为了获取当前的系统时间，而是进行程序耗时的时长，此时使用syetem_clock就不合适了，因为这个时间可以跟随系统的设置发生变化。在C++11中提供的时钟类steady_clock相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。</p><p>底层源码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">steady_clock</span> &#123; <span class="comment">// wraps QueryPerformanceCounter</span></span><br><span class="line">    <span class="keyword">using</span> rep                       = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> period                    = nano;</span><br><span class="line">    <span class="keyword">using</span> duration                  = nanoseconds;</span><br><span class="line">    <span class="keyword">using</span> time_point                = chrono::time_point&lt;steady_clock&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get current time</span></span><br><span class="line">    <span class="function">_NODISCARD <span class="type">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// doesn&#x27;t change after system boot</span></span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Freq = _Query_perf_frequency(); </span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Ctr  = _Query_perf_counter();</span><br><span class="line">        <span class="built_in">static_assert</span>(period::num == <span class="number">1</span>, <span class="string">&quot;This assumes period::num == 1.&quot;</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Whole = (_Ctr / _Freq) * period::den;</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> _Part  = (_Ctr % _Freq) * period::den / _Freq;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">time_point</span>(<span class="built_in">duration</span>(_Whole + _Part));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取开始时间点</span></span><br><span class="line">    steady_clock::time_point start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 执行业务流程</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print 1000 stars ....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    steady_clock::time_point last = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算差值</span></span><br><span class="line">    <span class="keyword">auto</span> dt = last - start;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总共耗时: &quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;纳秒&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314144855863.png" alt="image-20240314144855863"></p><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="duration-cast"><a href="#duration-cast" class="headerlink" title="duration_cast"></a>duration_cast</h4><p>duration_cast是chrono库提供的一个模板函数，这个函数不属于duration类。通过这个函数可以对duration类对象内部的时钟周期Period，和周期次数的类型Rep进行修改，该函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print 1000 stars ....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数时长：时钟周期纳秒转毫秒，要求 duration_cast</span></span><br><span class="line">    <span class="keyword">auto</span> int_ms = <span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(t2 - t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小数时长：不要求 duration_cast</span></span><br><span class="line">    duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; fp_ms = t2 - t1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f() took &quot;</span> &lt;&lt; fp_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms, &quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;or &quot;</span> &lt;&lt; int_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; whole milliseconds\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314145140151.png" alt="image-20240314145140151"></p><h4 id="time-point-cast"><a href="#time-point-cast" class="headerlink" title="time_point_cast"></a>time_point_cast</h4><p>time_point_cast也是chrono库提供的一个模板函数，这个函数不属于time_point类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期Period，和周期次数的类型Rep可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Clock = chrono::high_resolution_clock;</span><br><span class="line"><span class="keyword">using</span> Ms = chrono::milliseconds;</span><br><span class="line"><span class="keyword">using</span> Sec = chrono::seconds;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="keyword">using</span> TimePoint = chrono::time_point&lt;Clock, Duration&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ms</span><span class="params">(<span class="type">const</span> TimePoint&lt;Ms&gt;&amp; time_point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; time_point.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TimePoint&lt;Sec&gt; <span class="title">time_point_sec</span><span class="params">(Sec(<span class="number">6</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 无精度损失, 可以进行隐式类型转换</span></span><br><span class="line">    <span class="function">TimePoint&lt;Ms&gt; <span class="title">time_point_ms</span><span class="params">(time_point_sec)</span></span>;</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_ms);    <span class="comment">// 6000 ms</span></span><br><span class="line"></span><br><span class="line">    time_point_ms = <span class="built_in">TimePoint</span>&lt;Ms&gt;(<span class="built_in">Ms</span>(<span class="number">6789</span>));</span><br><span class="line">    <span class="comment">// error，会损失精度，不允许进行隐式的类型转换</span></span><br><span class="line">    <span class="comment">//TimePoint&lt;Sec&gt; sec(time_point_ms);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示类型转换,会损失精度。6789 truncated to 6000</span></span><br><span class="line">    time_point_sec = std::chrono::<span class="built_in">time_point_cast</span>&lt;Sec&gt;(time_point_ms);</span><br><span class="line">    <span class="built_in">print_ms</span>(time_point_sec); <span class="comment">// 6000 ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314145726379.png" alt="image-20240314145726379"></p><h2 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1. 线程概述"></a>1. 线程概述</h2><p>线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p><p>先从概念上了解一下线程和进程之间的区别：</p><p>&#x3D;&#x3D;进程有自己独立的地址空间, 多个线程共用同一个地址空间&#x3D;&#x3D;</p><p>&#x3D;&#x3D;线程更加节省系统资源, 效率不仅可以保持的, 而且能够更高<br>在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)&#x3D;&#x3D;<br>&#x3D;&#x3D;在一个地址空间中多个线程共享: 代码段, 堆区, 全局数据区, 打开的文件(文件描述符表)都是线程共享的&#x3D;&#x3D;<br>&#x3D;&#x3D;线程是程序的最小执行单位, 进程是操作系统中最小的资源分配单位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片<br>一个地址空间中可以划分出多个线程, 在有效的资源基础上, 能够抢更多的CPU时间片&#x3D;&#x3D;</p><p><img src="https://subingwen.cn/linux/thread/1048430-20170710134655212-558296442.png" alt="img"></p><p>&#x3D;&#x3D;CPU的调度和切换: 线程的上下文切换比进程要快的多&#x3D;&#x3D;</p><p>&#x3D;&#x3D;上下文切换：进程&#x2F;线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存, 下次切换回这个任务的时候, 加载这个状态继续运行，<strong>任务从保存到再次加载这个过程就是一次上下文切换。</strong>&#x3D;&#x3D;</p><p>&#x3D;&#x3D;线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>在处理多任务程序的时候使用多线程比使用多进程要更有优势</strong>&#x3D;&#x3D;，但是线程并不是越多越好，如何控制线程的个数呢？</p><p>文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片, 线程的个数 &#x3D; 2 * CPU核心数 (效率最高)</p><p>处理复杂的算法(主要是CPU进行运算, 压力大)，线程的个数 &#x3D; CPU的核心数 (效率最高)</p><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="built_in">thread</span>( thread&amp;&amp; other ) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">( Function&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br><span class="line"><span class="comment">// ④</span></span><br><span class="line"><span class="built_in">thread</span>( <span class="type">const</span> thread&amp; ) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314201134078.png" alt="image-20240314201134078"></p><h2 id="3-公共成员函数"><a href="#3-公共成员函数" class="headerlink" title="3.公共成员函数"></a>3.公共成员函数</h2><h3 id="2-1-get-id"><a href="#2-1-get-id" class="headerlink" title="2.1 get_id()"></a>2.1 get_id()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> num, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;num: &quot;</span> </span><br><span class="line">             &lt;&lt; num &lt;&lt; <span class="string">&quot;, str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314201259570.png" alt="image-20240314201259570"></p><h3 id="2-2-join"><a href="#2-2-join" class="headerlink" title="2.2 join()"></a>2.2 join()</h3><p><img src="/../typora-user-images/image-20240314201406337.png" alt="image-20240314201406337"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314201444013.png" alt="image-20240314201444013"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时500ms，阻塞线程500ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程1: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, 找到历史正文....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟下载, 总共耗时300ms，阻塞线程300ms</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程2: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, 找到历史正文....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集齐历史正文, 呼叫罗宾....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;历史正文解析中....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;起航，前往拉夫德尔....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到OnePiece, 成为海贼王, 哈哈哈!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;若干年后，草帽全员卒....&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大海贼时代再次被开启....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(download1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(download2)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">子线程<span class="number">2</span>: <span class="number">72540</span>, 找到历史正文....</span><br><span class="line">子线程<span class="number">1</span>: <span class="number">79776</span>, 找到历史正文....</span><br><span class="line">集齐历史正文, 呼叫罗宾....</span><br><span class="line">历史正文解析中....</span><br><span class="line">起航，前往拉夫德尔....</span><br><span class="line">找到OnePiece, 成为海贼王, 哈哈哈!!!</span><br><span class="line">若干年后，草帽全员卒....</span><br><span class="line">大海贼时代再次被开启....</span><br></pre></td></tr></table></figure><h3 id="2-3-detach"><a href="#2-3-detach" class="headerlink" title="2.3 detach()"></a>2.3 detach()</h3><p><img src="/../typora-user-images/image-20240314201552552.png" alt="image-20240314201552552"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程的线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func, <span class="number">520</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t 的线程ID: &quot;</span> &lt;&lt; t.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程t1的线程ID: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// 让主线程休眠, 等待子线程执行完毕</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意事项：线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或者调用get_id()获取子线程的线程ID。有利就有弊，鱼和熊掌不可兼得，建议使用join()。&#x3D;&#x3D;</p><h3 id="2-5-joinable"><a href="#2-5-joinable" class="headerlink" title="2.5 joinable()"></a>2.5 joinable()</h3><p>joinable()函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：</p><p>返回值为true：主线程和子线程之间有关联（连接）关系<br>返回值为false：主线程和子线程之间没有关联（连接）关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">thread</span>(foo);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after joining, joinable: &quot;</span> &lt;&lt; t.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after starting, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after detaching, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">before starting, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after joining, joinable: <span class="number">0</span></span><br><span class="line">after starting, joinable: <span class="number">1</span></span><br><span class="line">after detaching, joinable: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314201747244.png" alt="image-20240314201747244"></p><h3 id="2-6-operator"><a href="#2-6-operator" class="headerlink" title="2.6 operator&#x3D;"></a>2.6 operator&#x3D;</h3><p>&#x3D;&#x3D;线程中的资源是不能被复制的&#x3D;&#x3D;，因此通过&#x3D;操作符进行赋值操作最终并不会得到两个完全相同的对象。</p><p><img src="/../typora-user-images/image-20240314201843472.png" alt="image-20240314201843472"></p><h2 id="3-静态函数"><a href="#3-静态函数" class="headerlink" title="3. 静态函数"></a>3. 静态函数</h2><p><img src="/../typora-user-images/image-20240314201918760.png" alt="image-20240314201918760"></p><h2 id="命名空间this-thread"><a href="#命名空间this-thread" class="headerlink" title="命名空间this_thread\"></a>命名空间this_thread\</h2><h3 id="get-id"><a href="#get-id" class="headerlink" title="get_id()"></a>get_id()</h3><p><img src="/../typora-user-images/image-20240314202033833.png" alt="image-20240314202033833"></p><h3 id="sleep-for"><a href="#sleep-for" class="headerlink" title="sleep_for()"></a>sleep_for()</h3><p>同样地线程被创建后也有这五种状态：&#x3D;&#x3D;创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)&#x3D;&#x3D; ，关于状态之间的转换是一样的，请参考进程，在此不再过多的赘述。</p><p>线程和进程的执行有很多相似之处，在计算机中启动的多个线程都需要占用CPU资源，但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。&#x3D;&#x3D;为了能够实现并发处理，多个线程都是分时复用CPU时间片，快速的交替处理各个线程中的任务。因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行&#x3D;&#x3D;（因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况）。</p><p>命名空间<strong>this_thread</strong>中提供了一个休眠函数<strong>sleep_for()<strong>，调用这个函数的线程会马上从</strong>运行态</strong>变成<strong>阻塞态</strong>并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。这个函数是函数原型如下，参数需要指定一个休眠时长，是一个时间段：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240314202306189.png" alt="image-20240314202306189"></p><h3 id="sleep-until"><a href="#sleep-until" class="headerlink" title="sleep_until()"></a>sleep_until()</h3><p>命名空间this_thread中提供了另一个休眠函数sleep_until()，和sleep_for()不同的是它的参数类型不一样</p><p>sleep_until()：指定线程阻塞到某一个指定的时间点time_point类型，之后解除阻塞<br>sleep_for()：指定线程阻塞一定的时间长度duration 类型，之后解除阻塞</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">        <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">// 时间间隔为2s</span></span><br><span class="line">        <span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 当前时间点之后休眠两秒</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_until</span>(now + sec);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep_until()和sleep_for()函数的功能是一样的，只不过前者是基于时间点去阻塞线程，后者是基于时间段去阻塞线程，项目开发过程中根据实际情况选择最优的解决方案即可。</p><h3 id="4-yield"><a href="#4-yield" class="headerlink" title="4. yield()"></a>4. yield()</h3><p>命名空间this_thread中提供了一个非常绅士的函数yield()，在线程中调用这个函数之后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。使用这个函数的时候需要注意一点，线程调用了yield()之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的程序中，执行func()中的for循环会占用大量的时间，在极端情况下，如果当前线程占用CPU资源不释放就会导致其他线程中的任务无法被处理，或者该线程每次都能抢到CPU时间片，导致其他线程中的任务没有机会被执行。解决方案就是每执行一次循环，让该线程主动放弃CPU资源，重新和其他线程再次抢夺CPU时间片，如果其他线程抢到了CPU时间片就可以执行相应的任务了。</p><h1 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h1><p>在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次，就可以使用std::call_once()来保证函数在多线程环境下只能被调用一次。使用call_once()的时候，需要一个once_flag作为call_once()的传入参数，该函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure><p>flag：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到<br>f：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数<br>args：作为实参传递给回调函数</p><p>多线程操作过程中，std::call_once()内部的回调函数只会被执行一次，示例代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag g_flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> age, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">call_once</span>(g_flag, do_once, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something() function num = &quot;</span> &lt;&lt; num++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;ace&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;sabo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(do_something, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="C-线程同步之互斥锁"><a href="#C-线程同步之互斥锁" class="headerlink" title="C++线程同步之互斥锁"></a>C++线程同步之互斥锁</h1><p><img src="https://subingwen.cn/cpp/mutex/image-20210410084100031.png" alt="img"></p><p><img src="/../typora-user-images/image-20240315091001120.png" alt="image-20240315091001120"></p><h2 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. std::mutex</h2><h3 id="1-1-成员函数"><a href="#1-1-成员函数" class="headerlink" title="1.1 成员函数"></a>1.1 成员函数</h3><p>lock()函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>独占互斥锁对象有两种状态：锁定和未锁定。如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。</p><p>除了使用lock()还可以使用try_lock()获取互斥锁的所有权并对互斥锁加锁，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>二者的区别在于&#x3D;&#x3D;try_lock()不会阻塞线程&#x3D;&#x3D;，lock()会阻塞线程：</p><p>如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true<br>如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false</p><p>当互斥锁被锁定之后可以通过unlock()进行解锁，但是需要注意的是只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。该函数的函数原型如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>通过介绍以上三个函数，使用互斥锁进行线程同步的大致思路差不多就能搞清楚了，主要分为以下几步：</p><p>&#x3D;&#x3D;<strong>找到多个线程操作的共享资源（全局变量、堆内存、类成员变量等），也可以称之为临界资源</strong>&#x3D;&#x3D;<br>找到和共享资源有关的上下文代码，也就是临界区（下图中的黄色代码部分）<br>在临界区的上边调用互斥锁类的lock()方法<br>在临界区的下边调用互斥锁的unlock()方法</p><p>线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问效率降低了，但是保证了数据的正确性。</p><p><img src="https://subingwen.cn/cpp/mutex/image-20210410100224910.png" alt="img"></p><p>&#x3D;&#x3D;<strong>当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。</strong>&#x3D;&#x3D;</p><h3 id="1-2-线程同步"><a href="#1-2-线程同步" class="headerlink" title="1.2 线程同步"></a>1.2 线程同步</h3><p>举个栗子，我们让两个线程共同操作同一个全局变量，二者交替数数，将数值存储到这个全局变量里边并打印出来。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_num = <span class="number">0</span>;  <span class="comment">// 为 g_num_mutex 所保护</span></span><br><span class="line">mutex g_num_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        g_num_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        g_num_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(slow_increment, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(slow_increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例程序中，两个子线程执行的任务的一样的（其实也可以不一样，不同的任务中也可以对共享资源进行读写操作），在任务函数中把与全局变量相关的代码加了锁，两个线程只能顺序访问这部分代码（如果不进行线程同步打印出的数据是混乱且无序的）。另外需要强调一点：</p><p>在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。<br>&#x3D;&#x3D;互斥锁的个数和共享资源的个数相等&#x3D;&#x3D;，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。</p><h2 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. std::lock_guard</h2><p>lock_guard是C++11新增的一个模板类，使用这个类，可以简化互斥锁lock()和unlock()的写法，同时也更安全。这个模板类的定义和常用的构造函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的定义，定义于头文件 &lt;mutex&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Mutex</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">( mutex_type&amp; m )</span></span>;</span><br></pre></td></tr></table></figure><p>lock_guard在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。lock_guard使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><p>使用lock_guard对上面的例子进行修改，代码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_increment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用哨兵锁管理互斥锁</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(g_num_mutex)</span></span>;</span><br><span class="line">        ++g_num;</span><br><span class="line">        cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁，但是&#x3D;&#x3D;这种方式也有弊端，在上面的示例程序中整个for循环的体都被当做了临界区，多个线程是线性的执行临界区代码的，因此临界区越大程序效率越低&#x3D;&#x3D;，还是需要根据实际情况选择最优的解决方案。</p><h2 id="3-std-recursive-mutex"><a href="#3-std-recursive-mutex" class="headerlink" title="3. std::recursive_mutex"></a>3. std::recursive_mutex</h2><p>递归互斥锁std::recursive_mutex允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题，在下面的例子中使用独占非递归互斥量会发生死锁：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中执行了cal.both(6, 3);调用之后，程序就会发生死锁，在both()中已经对互斥锁加锁了，继续调用mult()函数，已经得到互斥锁所有权的线程再次获取这个互斥锁的所有权就会造成死锁（在C++中程序会异常退出，使用C库函数会导致这个互斥锁永远无法被解锁，最终阻塞所有的线程）。要解决这个死锁的问题，一个简单的办法就是使用递归互斥锁std::recursive_mutex，它允许一个线程多次获得互斥锁的所有权。修改之后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Calculate</span>() : <span class="built_in">m_i</span>(<span class="number">6</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_i /= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">both</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">mul</span>(x);</span><br><span class="line">        <span class="built_in">div</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    recursive_mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculate cal;</span><br><span class="line">    cal.<span class="built_in">both</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;cal.m_i = &quot;</span> &lt;&lt; cal.m_i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315101617369.png" alt="image-20240315101617369"></p><h2 id="4-std-timed-mutex"><a href="#4-std-timed-mutex" class="headerlink" title="4. std::timed_mutex"></a>4. std::timed_mutex</h2><p>std::timed_mutex是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。</p><p>std::timed_mutex比std::_mutex多了两个成员函数：try_lock_for()和try_lock_until()：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::timed_mutex比std::_mutex多出的两个成员函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure><p>try_lock_for函数是当线程获取不到互斥锁资源的时候，让线程阻塞一定的时间长度<br>try_lock_until函数是当线程获取不到互斥锁资源的时候，让线程阻塞到某一个指定的时间点<br>关于两个函数的返回值：当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true，如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">timed_mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::seconds <span class="title">timeout</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过阻塞一定的时长来争取得到互斥锁所有权</span></span><br><span class="line">        <span class="keyword">if</span> (g_mutex.<span class="built_in">try_lock_for</span>(timeout))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="comment">// 互斥锁解锁</span></span><br><span class="line">            g_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;当前线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, 没有得到互斥锁所有权...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 模拟处理其他任务用了一定的时长</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315102544984.png" alt="image-20240315102544984"></p><p>通过一个while循环不停的去获取超时互斥锁的所有权，如果得不到就阻塞1秒钟，1秒之后如果还是得不到阻塞50毫秒，然后再次继续尝试，直到获得互斥锁的所有权，跳出循环体。</p><p>关于递归超时互斥锁std::recursive_timed_mutex的使用方式和std::timed_mutex是一样的，只不过它可以允许一个线程多次获得互斥锁所有权，而std::timed_mutex只允许线程获取一次互斥锁所有权。另外，递归超时互斥锁std::recursive_timed_mutex也拥有和std::recursive_mutex一样的弊端，不建议频繁使用。</p><h1 id="C-线程同步之条件变量"><a href="#C-线程同步之条件变量" class="headerlink" title="C++线程同步之条件变量"></a>C++线程同步之条件变量</h1><p>条件变量是C++11提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用，C++11提供了两种条件变量</p><p>condition_variable：需要配合std::unique_lock<a href="std::mutex">std::mutex</a>进行wait操作，也就是阻塞线程的操作。<br>condition_variable_any：可以和任意带有lock()、unlock()语义的mutex搭配使用，也就是说有四种：<br>std::mutex：独占的非递归互斥锁<br>std::timed_mutex：带超时的独占非递归互斥锁<br>std::recursive_mutex：不带超时功能的递归互斥锁<br>std::recursive_timed_mutex：带超时的递归互斥锁</p><p>条件变量通常用于生产者和消费者模型，大致使用过程如下：</p><p>拥有条件变量的线程获取互斥量<br>循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行<br>产品的数量达到上限，生产者阻塞，否则生产者一直生产。。。<br>产品的数量为零，消费者阻塞，否则消费者一直消费。。。<br>条件满足之后，可以调用notify_one()或者notify_all()唤醒一个或者所有被阻塞的线程<br>由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产。。。<br>由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费。。。</p><h2 id="1-condition-variable"><a href="#1-condition-variable" class="headerlink" title="1. condition_variable"></a>1. condition_variable</h2><h3 id="1-1-成员函数-1"><a href="#1-1-成员函数-1" class="headerlink" title="1.1 成员函数"></a>1.1 成员函数</h3><p>condition_variable的成员函数主要分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 <condition_variable>。</condition_variable></p><p><strong>等待函数</strong></p><p>调用wait()函数的线程会被阻塞</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315120221222.png" alt="image-20240315120221222"></p><p><img src="/../typora-user-images/image-20240315120244058.png" alt="image-20240315120244058"></p><p><img src="/../typora-user-images/image-20240315120426054.png" alt="image-20240315120426054"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>&gt;</span><br><span class="line"><span class="function">cv_status <span class="title">wait_for</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315120553050.png" alt="image-20240315120553050"></p><p>notify_one()：唤醒一个被当前条件变量阻塞的线程<br>notify_all()：唤醒全部被当前条件变量阻塞的线程</p><h3 id="1-2-生产者和消费者模型"><a href="#1-2-生产者和消费者模型" class="headerlink" title="1.2 生产者和消费者模型"></a>1.2 生产者和消费者模型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SyncQueue</span>(<span class="type">int</span> maxSize) : <span class="built_in">m_maxSize</span>(maxSize) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 判断任务队列是不是已经满了</span></span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">size</span>() == m_maxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已满, 请耐心等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 阻塞线程</span></span><br><span class="line">            m_notFull.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">        m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="comment">// 通知消费者去消费</span></span><br><span class="line">        m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (m_queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务队列已空，请耐心等待。。。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_notEmpty.<span class="built_in">wait</span>(locker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">        <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 通知生产者去生产</span></span><br><span class="line">        m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; m_queue;     <span class="comment">// 存储队列数据</span></span><br><span class="line">    mutex m_mutex;         <span class="comment">// 互斥锁</span></span><br><span class="line">    condition_variable m_notEmpty;   <span class="comment">// 不为空的条件变量</span></span><br><span class="line">    condition_variable m_notFull;    <span class="comment">// 没有满的条件变量</span></span><br><span class="line">    <span class="type">int</span> m_maxSize;         <span class="comment">// 任务队列的最大任务个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SyncQueue <span class="title">taskQ</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> produce = <span class="built_in">bind</span>(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1);<span class="comment">//绑定函数，使用了C++标准库中的bind函数，它用于创建一个函数对象，将SyncQueue类的put成员函数与特定对象taskQ绑定，并将函数参数通过placeholders::_1进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;SyncQueue::take, &amp;taskQ);</span><br><span class="line">    thread t1[<span class="number">3</span>];</span><br><span class="line">    thread t2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i] = <span class="built_in">thread</span>(produce, i+<span class="number">100</span>);</span><br><span class="line">        t2[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[i].<span class="built_in">join</span>();</span><br><span class="line">        t2[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件变量condition_variable类的wait()还有一个重载的方法，可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足，如果满足条件（布尔值为true），则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；如果不满足条件（布尔值为false），当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 根据条件阻塞线程</span></span><br><span class="line">    m_notFull.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() != m_maxSize;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 将任务放入到任务队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被生产&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 通知消费者去消费</span></span><br><span class="line">    m_notEmpty.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_notEmpty.<span class="built_in">wait</span>(locker, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 从任务队列中取出任务(消费)</span></span><br><span class="line">    <span class="type">int</span> x = m_queue.<span class="built_in">front</span>();</span><br><span class="line">    m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 通知生产者去生产</span></span><br><span class="line">    m_notFull.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; 被消费&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;true继续向下执行,false阻塞停住。&#x3D;&#x3D;</p><h2 id="2-condition-variable-any"><a href="#2-condition-variable-any" class="headerlink" title="2. condition_variable_any"></a>2. condition_variable_any</h2><h3 id="2-1-成员函数"><a href="#2-1-成员函数" class="headerlink" title="2.1 成员函数"></a>2.1 成员函数</h3><p>condition_variable_any的成员函数也是分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 <condition_variable></condition_variable></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>&gt; <span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck)</span></span>;</span><br><span class="line"><span class="comment">// ②</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Lock</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(Lock&amp; lck, Predicate pred)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315144134141.png" alt="image-20240315144134141"></p><p><img src="/../typora-user-images/image-20240315144309162.png" alt="image-20240315144309162"></p><p><img src="/../typora-user-images/image-20240315144648575.png" alt="image-20240315144648575"></p><h1 id="多线程异步操作"><a href="#多线程异步操作" class="headerlink" title="多线程异步操作"></a>多线程异步操作</h1><h2 id="1-std-future"><a href="#1-std-future" class="headerlink" title="1. std::future"></a>1. std::future</h2><p><img src="https://subingwen.cn/cpp/async/image-20210412104358831.png" alt="img"></p><p><img src="/../typora-user-images/image-20240315165243054.png" alt="image-20240315165243054"></p><p><img src="/../typora-user-images/image-20240315165309709.png" alt="image-20240315165309709"></p><p><img src="/../typora-user-images/image-20240315165335796.png" alt="image-20240315165335796"></p><p><img src="/../typora-user-images/image-20240315171230710.png" alt="image-20240315171230710"></p><p><img src="/../typora-user-images/image-20240315171349356.png" alt="image-20240315171349356"></p><h2 id="2-std-promise"><a href="#2-std-promise" class="headerlink" title="2. std::promise"></a>2. std::promise</h2><p><img src="/../typora-user-images/image-20240315171429633.png" alt="image-20240315171429633"></p><p><img src="/../typora-user-images/image-20240315171611231.png" alt="image-20240315171611231"></p><p><img src="/../typora-user-images/image-20240315171944734.png" alt="image-20240315171944734"></p><hr><p>示例程序的中子线程的任务函数指定的是一个匿名函数，在这个匿名的任务函数执行期间通过p.set_value(100);传出了数据并且激活了状态，数据就绪后，外部主线程中的int value &#x3D; f.get();解除阻塞，并将得到的数据打印出来，5秒钟之后子线程休眠结束，匿名的任务函数执行完毕。</p><p><img src="/../typora-user-images/image-20240315172257471.png" alt="image-20240315172257471"></p><p>在示例程序中，子线程的这个匿名的任务函数中通过p.set_value_at_thread_exit(100);在执行完毕并退出之后才会传出数据并激活状态，数据就绪后，外部主线程中的int value &#x3D; f.get();解除阻塞，并将得到的数据打印出来，因此子线程在休眠5秒钟之后主线程中才能得到传出的数据。</p><p>另外，在这两个实例程序中有一个知识点需要强调，在外部主线程中创建的promise对象必须要通过引用的方式传递到子线程的任务函数中，在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到std::ref()函数中，表示要传递这个实参的引用到任务函数中。</p><h2 id="3-std-packaged-task"><a href="#3-std-packaged-task" class="headerlink" title="3. std::packaged_task"></a>3. std::packaged_task</h2><p><img src="/../typora-user-images/image-20240315173740897.png" alt="image-20240315173740897"></p><p><img src="/../typora-user-images/image-20240315173756883.png" alt="image-20240315173756883"></p><p><img src="/../typora-user-images/image-20240315173815065.png" alt="image-20240315173815065"></p><p><img src="/../typora-user-images/image-20240315173834810.png" alt="image-20240315173834810"></p><p>在上面的示例代码中，通过packaged_task类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到future对象，再通过这个future对象取出子线程通过返回值传递出的数据。</p><h2 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. std::async</h2><p>std::async函数比前面提到的std::promise和packaged_task更高级一些，因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个future对象中，当需要获取异步任务的结果时，只需要调用future 类的get()方法即可，如果不关注异步任务的结果，只是简单地等待任务完成的话，可以调用future 类的wait()或者wait_for()方法。该函数的函数原型如下</p><p><img src="/../typora-user-images/image-20240315174232946.png" alt="image-20240315174232946"></p><p><img src="/../typora-user-images/image-20240315174324136.png" alt="image-20240315174324136"></p><p>调用async()函数直接创建线程执行任务</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>([](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    future_status status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (status == future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程还没有执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            f.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::ready)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;子线程返回值: &quot;</span> &lt;&lt; f.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (status == future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;任务还未执行完毕, 继续等待...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (status != future_status::ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315174733609.png" alt="image-20240315174733609"></p><p>调用async()函数时不指定策略就是直接创建线程并执行任务，示例代码的主线程中做了如下操作status &#x3D; f.wait_for(chrono::seconds(1));其实直接调用f.get()就能得到子线程的返回值。</p><p><strong>调用async()函数不创建线程执行任务</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 调用函数直接创建线程执行任务</span></span><br><span class="line">    future&lt;<span class="type">int</span>&gt; f = <span class="built_in">async</span>(launch::deferred, [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程ID: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> x += <span class="number">100</span>;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240315174937314.png" alt="image-20240315174937314"></p><p>由于指定了launch::deferred 策略，因此调用async()函数并不会创建新的线程执行任务，当使用future类对象调用了get()或者wait()方法后才开始执行任务（此处一定要注意调用wait_for()函数是不行的）。</p><p>通过测试程序输出的结果可以看到，两次输出的线程ID是相同的，任务函数是在主线程中被延迟（主线程休眠了5秒）调用了。</p><h2 id="最终总结："><a href="#最终总结：" class="headerlink" title="最终总结："></a>最终总结：</h2><p><strong>&#x3D;&#x3D;使用async()函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。&#x3D;&#x3D;</strong><br><strong>&#x3D;&#x3D;使用std::promise类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。&#x3D;&#x3D;</strong><br>&#x3D;&#x3D;<strong>使用std::packaged_task类，可以将子线程的任务函数进行包装，并且可以得到子线程的返回值。</strong>&#x3D;&#x3D;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性</title>
      <link href="/2024/09/26/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/09/26/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="auto-类型推导语法和规则"><a href="#auto-类型推导语法和规则" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;类型推导语法和规则</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> name=value;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;auto&#x3D;&#x3D;是一个占位符，在编译器期间会被真正的类型替代，且必须初始化，不能只是声明，必须赋值，因为&#x3D;&#x3D;auto&#x3D;&#x3D;会根据&#x3D;右边的值判断&#x3D;&#x3D;auto&#x3D;&#x3D;到底是什么类型。</p><h3 id="auto-高级用法"><a href="#auto-高级用法" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;高级用法"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;高级用法</h3><p>除了可以独立使用，还可以和某些具体类型混合使用，这样&#x3D;&#x3D;auto&#x3D;&#x3D;就是‘半个’类型。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">//p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">//p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">//r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">//r2 为  int，auto 推导为 int</span></span><br><span class="line"><span class="comment">/*第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</span></span><br><span class="line"><span class="comment">第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</span></span><br><span class="line"><span class="comment">第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</span></span><br><span class="line"><span class="comment">第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;auto&#x3D;&#x3D;还可以和&#x3D;&#x3D;const&#x3D;&#x3D;结合</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span>  <span class="keyword">auto</span> n = x;  <span class="comment">//n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;      <span class="comment">//f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第 2 行代码中，n 为 const int，auto 被推导为 int。</span></span><br><span class="line"><span class="comment">第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</span></span><br><span class="line"><span class="comment">第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</span></span><br><span class="line"><span class="comment">第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>·当类型不为引用时，&#x3D;&#x3D;auto&#x3D;&#x3D;的推到结果将不保留表达式的const属性</p><p>·当类型为引用时，&#x3D;&#x3D;auto&#x3D;&#x3D;的推到结果将保留表达式的const属性。</p><h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="&#x3D;&#x3D;auto&#x3D;&#x3D;的限制"></a>&#x3D;&#x3D;auto&#x3D;&#x3D;的限制</h3><p>1）&#x3D;&#x3D;auto&#x3D;&#x3D;不能再函数的参数里使用</p><p>2）&#x3D;&#x3D;auto&#x3D;&#x3D;不能作用于类的非静态成员变量（没有关键字static）</p><p>3）&#x3D;&#x3D;auto&#x3D;&#x3D;关键字不能定义数组</p><p>4）&#x3D;&#x3D;auto&#x3D;&#x3D;不能作用于模板参数</p><hr><h2 id="decltype-类型推导完全攻略"><a href="#decltype-类型推导完全攻略" class="headerlink" title="&#x3D;&#x3D;decltype&#x3D;&#x3D;类型推导完全攻略"></a>&#x3D;&#x3D;decltype&#x3D;&#x3D;类型推导完全攻略</h2><p>&#x3D;&#x3D;decltype&#x3D;&#x3D; C++11的新关键字，和&#x3D;&#x3D;auto&#x3D;&#x3D;的功能一样，都是自动推导除变量的类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname=value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname=value;</span><br></pre></td></tr></table></figure><p>auto必须初始化，但是&#x3D;&#x3D;decltype&#x3D;&#x3D;不需要初始化可以直接声明,exp是一个表达式，auto是根据&#x3D;右边的值推导关键字，decltype与&#x3D;右值无关，只和exp有关。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br></pre></td></tr></table></figure><h3 id="exp注意事项"><a href="#exp注意事项" class="headerlink" title="exp注意事项"></a>exp注意事项</h3><p>原则上讲，exp可以是一个普通的表达式，可以是任意复杂的形式，但是不能是void，尤其是exp调用的一个函数的返回值类型是void，exp结果也是void</p><p>&#x3D;&#x3D;decltype&#x3D;&#x3D;推导规则</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">·如果 exp 是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</span><br><span class="line">·如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</span><br><span class="line">·如果 exp 是一个左值，或者被括号( )包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</span><br></pre></td></tr></table></figure><h4 id="exp是一个普通表达式（不被”（）“包围的表达式）"><a href="#exp是一个普通表达式（不被”（）“包围的表达式）" class="headerlink" title="exp是一个普通表达式（不被”（）“包围的表达式）"></a>exp是一个普通表达式（不被”（）“包围的表达式）</h4><p>exp是什么&#x3D;&#x3D;decltype&#x3D;&#x3D;就是什么</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exp位函数调用（返回值是什么exp就是什么，-不能是void类型-）"><a href="#exp位函数调用（返回值是什么exp就是什么，-不能是void类型-）" class="headerlink" title="exp位函数调用（返回值是什么exp就是什么，&#x3D;&#x3D;不能是void类型&#x3D;&#x3D;）"></a>exp位函数调用（返回值是什么exp就是什么，&#x3D;&#x3D;不能是void类型&#x3D;&#x3D;）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">(<span class="type">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br></pre></td></tr></table></figure><h4 id="exp是左值或者被”（）“包围"><a href="#exp是左值或者被”（）“包围" class="headerlink" title="exp是左值或者被”（）“包围"></a>exp是左值或者被”（）“包围</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="&#x3D;&#x3D;decltype&#x3D;&#x3D;的实际应用"></a>&#x3D;&#x3D;decltype&#x3D;&#x3D;的实际应用</h4><p>auto比decltype简单，但是限制多，</p><p>auto只能用于类的静态成员，不能用于费劲太成员，但是decltype没有这个限制。代码会更加简便一些。</p><p>&#x3D;&#x3D;原格式&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p><p>要想解决这个问题，在之前的 C++98&#x2F;03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;低版本编译器不支持T().begin()写法&#x3D;&#x3D;</p><hr><h2 id="返回值类型后置"><a href="#返回值类型后置" class="headerlink" title="返回值类型后置"></a>返回值类型后置</h2><p>写法1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>() + <span class="built_in">U</span>()) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T,U可能是无参构造函数的类，则需要修改为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用返回值后置写法，需要将auto和decltype混合使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>&amp; f)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="auto-和-decltype的区别"><a href="#auto-和-decltype的区别" class="headerlink" title="auto 和 decltype的区别"></a>auto 和 decltype的区别</h2><p>1.auto是通过编译器计算变量的初始值来推断类型的，decltype同样也是通过编译器来分析表达式进而得到它的类型，但是它不用将表达式的值计算出来。</p><p>2.编译器推断出来的auto类型有可能和初始值类型不同，比如对于顶层const，auto会忽略顶层const性质，但是decltype是保留下来的，这在下面的代码中会有所体现。</p><p>3.与auto不一样，decltype的结果类型与表达式形式有密切关系。比如decltype（）内层没有括号，那么得到的类型就是变量的类型，如果有多层括号decltype（（））那么返回的就是引用，具体可以通过代码分析。</p><figure class="highlight plaintext"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">#include &quot;Sales_item.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 4,&amp;p =i;</span><br><span class="line">auto a = i;//相当于int a=i；</span><br><span class="line">decltype (i) b = i;//编译器推断i是一个int，相当于int b=i；</span><br><span class="line">decltype ((i)) c = i;//只要出现了表达式那么decltype就推断出是引用</span><br><span class="line"> //相当于int &amp;c = i；</span><br><span class="line">decltype(p) q = i;//即int &amp;q = i；</span><br><span class="line">decltype(p + 0) r = i;//表达式的结果是int型 即int r =i；</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt;&quot; &quot;&lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">c++;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">q++;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">const int m = 10;</span><br><span class="line">auto d = m;//由于auto会失去顶层const的性质，即int d=m；</span><br><span class="line">d++;//合法，d是整数</span><br><span class="line">decltype (m) e = 11;//相反decltype 会保留const性质，即const int e=11；</span><br><span class="line">e++;//该句非法操作 e是常量</span><br><span class="line">decltype((m))f = d;//即const int &amp;f=d；</span><br><span class="line">int g = 12;</span><br><span class="line">f = g;//该句非法操作，是因为f是常量引用</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="using定义别名"><a href="#using定义别名" class="headerlink" title="using定义别名"></a>using定义别名</h2><p>一般定义别名的使用typedef(重定义一个类型)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">unit_t</span></span><br></pre></td></tr></table></figure><p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型去了一个新的名字。因此下面的用法不合法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unit_t</span>)</span><span class="comment">//不合法</span></span></span><br></pre></td></tr></table></figure><p>同时也无法重定义一个模板</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, std::string&gt; <span class="type">map_str_t</span>;</span><br></pre></td></tr></table></figure><p>需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><hr><p>C++11出现一个新的语法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure><p>using别名覆盖了typedef的全部功能对普通类型的重定义</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p><p>typedef void (*func_t)(int, int);</p><p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p><p>using func_t &#x3D; void (*)(int, int);</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure><p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t<int> 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</int></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span> (*func_call)(<span class="type">int</span>, <span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">func_t</span>&lt;<span class="type">int</span>&gt; func_call)</span></span>;  <span class="comment">// error: redefinition</span></span><br></pre></td></tr></table></figure><hr><h2 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h2><p>在C++98&#x2F;03，类模板可以有默认的模板参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U=<span class="type">int</span> ,U N=<span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo&#123;&#125;;</span><br></pre></td></tr></table></figure><p>不支持函数的默认模板参数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T</span>=<span class="type">int</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在C++11中可以使用了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p><p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p><p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val&#x3D;97 推导出 R 的类型也为 int；而 func<char>(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U &#x3D; int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</char></p><p>&#x3D;&#x3D;再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    <span class="built_in">func</span>();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h2><h3 id="tuple对象的创建"><a href="#tuple对象的创建" class="headerlink" title="tuple对象的创建"></a>tuple对象的创建</h3><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 <tuple> 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</tuple></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure><p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p><h4 id="1-类的构造函数"><a href="#1-类的构造函数" class="headerlink" title="1) 类的构造函数"></a>1) 类的构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-make-tuple-函数"><a href="#2-make-tuple-函数" class="headerlink" title="2) make_tuple()函数"></a>2) make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 <tuple> 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</tuple></p><p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">make_tuple</span> (<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = std::<span class="built_in">make_tuple</span> (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br></pre></td></tr></table></figure><p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p><h3 id="tuple常用函数"><a href="#tuple常用函数" class="headerlink" title="tuple常用函数"></a>tuple常用函数</h3><p>为了方便您在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数，<tuple> 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如表 1 所示。</tuple></p><table><thead><tr><th>函数或类模板</th><th>描 述</th></tr></thead><tbody><tr><td>tup1.swap(tup2) swap(tup1, tup2)</td><td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数，<tuple> 头文件还提供了一个同名的 swap() 全局函数。  swap() 函数的功能是交换两个 tuple 对象存储的内容。</tuple></td></tr><tr><td>get<num>(tup)</num></td><td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 <tuple> 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</tuple></td></tr><tr><td>tuple_size<type>::value</type></td><td>tuple_size 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</tuple></td></tr><tr><td>tuple_element&lt;I, type&gt;::type</td><td>tuple_element 是定义在 <tuple> 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</tuple></td></tr><tr><td>forward_as_tuple&lt;args…&gt;</td><td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td></tr><tr><td>tie(args…) &#x3D; tup</td><td>tup 表示某个 tuple 对象，tie() 是 <tuple> 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</tuple></td></tr><tr><td>tuple_cat(args…)</td><td>args… 表示多个 tuple 对象，该函数是 <tuple> 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</tuple></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 x</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="C-11列表初始化（统一了初始化方式）"><a href="#C-11列表初始化（统一了初始化方式）" class="headerlink" title="C++11列表初始化（统一了初始化方式）"></a>C++11列表初始化（统一了初始化方式）</h2><p>C++98&#x2F;03的对象初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p><p>为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</span><br></pre></td></tr></table></figure><h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。&#x3D;&#x3D;</p><p>在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，请看下面的代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。</p><p>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p><p>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。</p><p>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure><p>在初始化时，<code>&#123;&#125;</code>前面的等于号是否书写对初始化行为没有影响。</p><p>另外，如同读者所想的那样，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。</p><p>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p><p>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p><p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h2><p>格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) <span class="keyword">mutable</span> <span class="keyword">noexcept</span>/<span class="keyword">throw</span>() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">   函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中各部分的含义分别为：</p><ol><li>[外部变量方位方式说明符]<br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</li></ol><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p></li><li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p></li></ol><p>&#x3D;&#x3D;注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；&#x3D;&#x3D;</p><ol start="4"><li>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</li></ol><p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p><ol start="5"><li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p></li><li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p></li></ol><p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</span><br></pre></td></tr></table></figure><p>下面定义一个最简单的lambda匿名函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h4><p>对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</p><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td></tr><tr><td>[&#x3D;]</td><td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td></tr><tr><td>[&amp;]</td><td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td></tr><tr><td>[val1,val2,…]</td><td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td></tr><tr><td>[&amp;val1,&amp;val2,…]</td><td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td></tr><tr><td>[val,&amp;val2,…]</td><td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td></tr><tr><td>[&#x3D;,&amp;val1,…]</td><td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的 this 指针。</td></tr></tbody></table><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">注意，单个外部变量不允许以相同的传递方式导入多次。例如 [=，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</span><br></pre></td></tr></table></figure><h4 id="lambda-匿名函数的定义和使用。"><a href="#lambda-匿名函数的定义和使用。" class="headerlink" title="lambda 匿名函数的定义和使用。"></a>lambda 匿名函数的定义和使用。</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p><h4 id="值传递和引用传递的区别"><a href="#值传递和引用传递的区别" class="headerlink" title="值传递和引用传递的区别"></a>值传递和引用传递的区别</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p><p>其中，lambda1 匿名函数是以&#x3D;&#x3D;[&#x3D;]&#x3D;&#x3D; 值传递的方式导入的局部变量，这意味着默认情况下，&#x3D;&#x3D;此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外-&#x3D;&#x3D;。相对地，lambda2 匿名函数以 &#x3D;&#x3D;[&amp;]&#x3D;&#x3D; 引用传递的方式导入这 3 个局部变量，&#x3D;&#x3D;因此在该函数的内部不就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。&#x3D;&#x3D;</p><p>如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，&#x3D;&#x3D;真正外部变量的值并不会发生改变。&#x3D;&#x3D;</p><h4 id="执行抛出异常类型"><a href="#执行抛出异常类型" class="headerlink" title="执行抛出异常类型"></a>执行抛出异常类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p><p>在此基础上，在看一下反例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="built_in">throw</span>(<span class="type">char</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">except1</span>();</span><br><span class="line">        <span class="built_in">except2</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p><p>&#x3D;&#x3D;如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。&#x3D;&#x3D;</p><hr><h1 id="C-11非受限联合体（union）"><a href="#C-11非受限联合体（union）" class="headerlink" title="C++11非受限联合体（union）"></a>C++11非受限联合体（union）</h1><p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h4><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</p><p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。</p><p>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p><ol><li><p>没有&#x3D;&#x3D;用户自定义&#x3D;&#x3D;的&#x3D;&#x3D;构造函数、析构函数、拷贝构造函数和移动构造函数&#x3D;&#x3D;。</p></li><li><p>不能包含&#x3D;&#x3D;虚函数和虚基类&#x3D;&#x3D;。</p></li><li><p>非静态成员必须声明为 &#x3D;&#x3D;public&#x3D;&#x3D;。</p></li><li><p>类中的第一个非静态成员的类型与其基类(父类)不同，例如：</p></li></ol><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">class B1&#123;&#125;;</span><br><span class="line">class B2 : B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure><p>class B2 的第一个非静态成员 b 是&#x3D;&#x3D;基类&#x3D;&#x3D;类型，所以它不是 POD 类型。</p><ol start="5"><li>在类或者结构体继承时，满足以下两种情况之一：</li></ol><ul><li>&#x3D;&#x3D;派生类&#x3D;&#x3D;中&#x3D;&#x3D;有非静态成员&#x3D;&#x3D;，且只有一个&#x3D;&#x3D;仅包含静态成员&#x3D;&#x3D;的&#x3D;&#x3D;基类&#x3D;&#x3D;；</li><li>基类有非静态成员，而派生类&#x3D;&#x3D;没有非静态成员&#x3D;&#x3D;。</li></ul><p>总结：父类和子类的非静态成员是冲突的，一个有非静态成员另一个就不能有。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> &#123; <span class="type">static</span> <span class="type">int</span> n; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> : B1 &#123; <span class="type">int</span> n1; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B3</span> : B2 &#123; <span class="type">static</span> <span class="type">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure><p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p><ol start="6"><li><p>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p></li><li><p>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p></li></ol><h4 id="2C-11-允许联合体有静态成员"><a href="#2C-11-允许联合体有静态成员" class="headerlink" title="2C++11 允许联合体有静态成员"></a>2C++11 允许联合体有静态成员</h4><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。&#x3D;&#x3D;</p><h2 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p><p>这条规则可能导致对象构造失败，请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p><hr><p>解决上面问题的一般需要用到 placement new</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p><h4 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h4><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</p><p>placement new 的语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(...)</span><br></pre></td></tr></table></figure><p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p><p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p><h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="type">int</span> x; &#125;;  <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p><p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="constexpr验证常量表达式"><a href="#constexpr验证常量表达式" class="headerlink" title="constexpr验证常量表达式"></a>constexpr验证常量表达式</h1><p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure><p>代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p><p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>&#x3D;&#x3D;constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。&#x3D;&#x3D;</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</span><br></pre></td></tr></table></figure><h2 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p><p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p><p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p><h2 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p><p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p><ol><li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constexpr int display(int x) &#123;</span><br><span class="line">    int ret = 1 + 2 + x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p><p>如下是正确的定义 display() 常量表达式函数的写法：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。&#x3D;&#x3D;</p><ol start="2"><li>该函数必须有返回值，即函数的返回值类型不能是 void。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p><ol start="3"><li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在&#x3D;&#x3D;使用前，必须要有该函数的定义。&#x3D;&#x3D;</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;<span class="comment">//使用前</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</span><br></pre></td></tr></table></figure><ol start="4"><li>return 返回的表达式必须是常量表达式，举个例子：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;<span class="comment">//num影响结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p><p>&#x3D;&#x3D;注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x&#x3D;1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。&#x3D;&#x3D;</p><hr><hr><h2 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p><p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p><p>&#x3D;&#x3D;注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。&#x3D;&#x3D;</p><p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p><p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="long-long-超长整形详解"><a href="#long-long-超长整形详解" class="headerlink" title="long long 超长整形详解"></a>long long 超长整形详解</h1><table><thead><tr><th>整数类型</th><th>等价类型</th><th>C++11标准规定占用最少位数</th></tr></thead><tbody><tr><td>short</td><td>short int（有符号短整型）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed short</td><td></td><td></td></tr><tr><td>signed short int</td><td></td><td></td></tr><tr><td>unsigned short</td><td>unsigned short int（无符号短整型）</td><td></td></tr><tr><td>unsigned short int</td><td></td><td></td></tr><tr><td>int</td><td>int（有符号整形）</td><td>至少 16 位（2 个字节）</td></tr><tr><td>signed</td><td></td><td></td></tr><tr><td>signed int</td><td></td><td></td></tr><tr><td>unsigned</td><td>unsigned int（无符号整形）</td><td></td></tr><tr><td>unsigned int</td><td></td><td></td></tr><tr><td>long</td><td>long int（有符号长整形）</td><td>至少 32 位（4 个字节）</td></tr><tr><td>long int</td><td></td><td></td></tr><tr><td>signed long</td><td></td><td></td></tr><tr><td>signed long int</td><td></td><td></td></tr><tr><td>unsigned long</td><td>unsigned long int（无符号长整形）</td><td></td></tr><tr><td>unsigned long int</td><td></td><td></td></tr><tr><td>long long（C++11）</td><td>long long int（有符号超长整形）</td><td>至少 64 位（8 个字节）</td></tr><tr><td>long long int（C++11）</td><td></td><td></td></tr><tr><td>signed long long（C++11）</td><td></td><td></td></tr><tr><td>signed long long int（C++11）</td><td></td><td></td></tr><tr><td>unsigned long long（C++11）</td><td>unsigned long long int（无符号超长整型）</td><td></td></tr><tr><td>unsigned long long int（C++11）</td><td></td><td></td></tr></tbody></table><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。注意，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</span><br></pre></td></tr></table></figure><h1 id="C-11右值引用（一看即懂）"><a href="#C-11右值引用（一看即懂）" class="headerlink" title="C++11右值引用（一看即懂）"></a>C++11右值引用（一看即懂）</h1><h2 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h2><ol><li>&#x3D;&#x3D;可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。&#x3D;&#x3D;举个例子：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br></pre></td></tr></table></figure><p>变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure><ol start="2"><li>&#x3D;&#x3D;有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。&#x3D;&#x3D;</li></ol><p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 </p><h2 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h2><p> C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98&#x2F;03 标准中的引用又称为左值引用。</p><p>注意，虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p><p>&#x3D;&#x3D;需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>和常量左值引用不同的是，右值引用还可以对右值进行修改</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>C++ 语法上是支持定义常量右值引用的，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>;<span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>引用类型</th><th>可以引用的值类型</th><th>使用场景</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>非常量左值</td><td>常量左值</td><td>非常量右值</td><td>常量右值</td><td></td><td></td></tr><tr><td>非常量左值引用</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>无</td></tr><tr><td>常量左值引用</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>常用于类中构建拷贝构造函数</td></tr><tr><td>非常量右值引用</td><td>N</td><td>N</td><td>Y</td><td>N</td><td>移动语义、完美转发</td></tr><tr><td>常量右值引用</td><td>N</td><td>N</td><td>Y</td><td>Y</td><td>无实际用途</td></tr></tbody></table><h1 id="移动构造函数及std-move-的使用"><a href="#移动构造函数及std-move-的使用" class="headerlink" title="移动构造函数及std::move() 的使用"></a>移动构造函数及std::move() 的使用</h1><h2 id="复制构造和移动构造"><a href="#复制构造和移动构造" class="headerlink" title="复制构造和移动构造"></a>复制构造和移动构造</h2><img src="/2024/09/26/C++11%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images/image-20240313115645107.png" style="zoom:150%;"><img src="/2024/09/26/C++11%E6%96%B0%E7%89%B9%E6%80%A7/typora-user-images/image-20240313115707702.png" style="zoom:150%;"><p>复制构造和移动构造的差别：<br>这种情况下，我们觉得这个临时对象完成了复制构造后，就不需要它了，我们就没有必要去首先产生一个副本，然后析构这个临时对象，这样费两遍事，又占用内存空间，干脆将临时对象原本的堆内存直接转给构造的对象就行了。 当临时对象在被复制后，就不再被利用了。我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制构造。</p><p>什么时候该触发移动构造呢？<br>如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。</p><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>std::move函数可以以非常简单的方式<strong>将左值转换为右值引用</strong>。<br>通过std::move，可以避免不必要的拷贝操作。<br>std::move是为性能而生。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//这里假设我们只需要将str的内容放到vector中，完成以后永远都不需要再用到str</span></span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(str);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After copy, str is :&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="comment">//先把str转为右值引用，然后调用移动构造函数转交所有权</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">move</span>(str));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After move, str is:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The contents of the vector are:&#123;&quot;</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">&lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;&#125;&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://so.csdn.net/so/search?q=string%E7%B1%BB&spm=1001.2101.3001.7020">string类</a>的数据成员简单的来说其实最关键的就是一个<code>char*</code>(至于其他的东西不重要)，指向动态内存分配空间的首地址。</p><p><img src="/../typora-user-images/image-20240313121538178.png" alt="image-20240313121538178"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">s1 = <span class="built_in">move</span>(s2); </span><br><span class="line"><span class="comment">// s1==&quot;banana&quot;</span></span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">v1 = <span class="built_in">move</span>(v2);  <span class="comment">//从v2转移到v1</span></span><br><span class="line"><span class="comment">//v1==&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s1 = move(s2);</code>move函数先把s2转为右值引用，然后就可以执行string类的移动构造函数和移动赋值运算符函数。</p><h3 id="继续深入分析C-11的右值引用："><a href="#继续深入分析C-11的右值引用：" class="headerlink" title="继续深入分析C++11的右值引用："></a>继续深入分析C++11的右值引用：</h3><p>1.什么是左值，什么是右值，<strong>简单说左值可以赋值，右值不可以赋值</strong>。以下面代码为例，“ A a &#x3D; getA();”该语句中a是左值，getA()的返回值是右值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = <span class="built_in">getA</span>();<span class="comment">// getA()是一个右值</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240313121854166.png" alt="image-20240313121854166"></p><p>可以看到A的构造函数调用一次，拷贝构造函数调用了一次，构造函数和拷贝构造函数是消耗比较大的，这里是否可以避免拷贝构造？C++11做到了这一点。（注意，上面这个例子中，虽然getA()是一个右值，但是由于没有自定义move constructor，所以调用了默认的copy constructor。如果对象中有堆内存管理，必须定义move constructor。<br>2.自定义A的移动构造函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = <span class="built_in">getA</span>();<span class="comment">// getA()是一个右值</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/09/26/C++11%E6%96%B0%E7%89%B9%E6%80%A7/Fengzi../Typora/typora-user-images/image-20240313141133632.png" alt="image-20240313141133632"></p><p>3.修改代码，给A类添加一个成员变量如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp;) &#123; cout &lt;&lt; <span class="string">&quot;B Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() : <span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>()) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; src) :<span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb)))<span class="comment">//深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(A&amp;&amp; src) :<span class="built_in">pb</span>(src.pb)</span><br><span class="line">&#123;</span><br><span class="line">src.pb = <span class="literal">nullptr</span>;<span class="comment">//这里是关键，这样以后，当src.pb被delete时，由于其为空指针，并不会释放原来的堆内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A Move Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> pb; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = <span class="built_in">getA</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240313141646721.png" alt="image-20240313141646721"></p><p>4.std::move语句可以将左值变为右值而避免拷贝构造，修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp;) &#123; cout &lt;&lt; <span class="string">&quot;B Copy Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() : <span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>()) &#123; cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; src) :<span class="built_in">pb</span>(<span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb)))<span class="comment">//深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A Copy Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(A&amp;&amp; src) :<span class="built_in">pb</span>(src.pb)</span><br><span class="line">&#123;</span><br><span class="line">src.pb = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A Move Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; src) <span class="keyword">noexcept</span><span class="comment">//深拷贝</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br><span class="line">pb = <span class="keyword">new</span> <span class="built_in">B</span>(*(src.pb));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator=(const A&amp; src)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(A&amp;&amp; src) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pb;</span><br><span class="line">pb = src.pb;</span><br><span class="line">src.pb = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator=(const A&amp;&amp; src)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123; <span class="keyword">delete</span> pb; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">B* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> A <span class="title">getA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a = <span class="built_in">getA</span>();<span class="comment">//移动构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(move(a))</span></span>;<span class="comment">//移动构造</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">a2 = <span class="built_in">getA</span>();<span class="comment">//移动赋值（因为getA()是右值）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">a2 = a1;<span class="comment">//拷贝赋值（因为a1是左值）</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../typora-user-images/image-20240313141943171.png" alt="image-20240313141943171"></p><h3 id="使用move函数转交unique-ptr的所有权"><a href="#使用move函数转交unique-ptr的所有权" class="headerlink" title="使用move函数转交unique_ptr的所有权"></a>使用move函数转交unique_ptr的所有权</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>*p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">56</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up_int1</span><span class="params">(p1)</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; up_int2= <span class="built_in">move</span>(up_int1);<span class="comment">//转交所有权（法1）</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; p2(p1.release()); //转交所有权（法2）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string* p2 = <span class="keyword">new</span> string[<span class="number">2</span>];<span class="comment">//对象数组</span></span><br><span class="line">p2[<span class="number">0</span>] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">p2[<span class="number">1</span>] = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string[]&gt; <span class="title">up_str1</span><span class="params">(p2)</span></span>;</span><br><span class="line">unique_ptr&lt;string[]&gt; up_str2;</span><br><span class="line">up_str2 = <span class="built_in">move</span>(up_str1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="引用限定符的用法"><a href="#引用限定符的用法" class="headerlink" title="引用限定符的用法"></a>引用限定符的用法</h1><p>本节中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p><p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p><p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。</p><p>同理，我们再次修改程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p><p>&#x3D;&#x3D;注意，引用限定符不适用于静态成员函数和友元函数。&#x3D;&#x3D;</p><h2 id="const和引用限定符"><a href="#const和引用限定符" class="headerlink" title="const和引用限定符"></a>const和引用限定符</h2><p>const 也可以用于修饰类的成员函数，我们习惯称为常成员函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 get_num() 就是一个常成员函数。</p><p>const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p><p>需要注意的一点是，当 &#x3D;&#x3D;const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象&#x3D;&#x3D;；当&#x3D;&#x3D;const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。&#x3D;&#x3D;无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，&#x3D;&#x3D;内部都不允许对当前对象做修改操作。&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num,<span class="type">int</span> num2) :<span class="built_in">num</span>(num),<span class="built_in">num2</span>(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;        <span class="comment">// 正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-11完美转发及实现方法"><a href="#C-11完美转发及实现方法" class="headerlink" title="C++11完美转发及实现方法"></a>C++11完美转发及实现方法</h1><h2 id="什么是完美转发？"><a href="#什么是完美转发？" class="headerlink" title="什么是完美转发？"></a><strong>什么是完美转发</strong>？</h2><p>它指的是<strong>函数模板</strong>可以将自己的参数“<strong>完美</strong>”地转发给<strong>内部调用的其它函数</strong>。</p><ul><li>完美，表示能保证被转发参数的左、右值属性不变。</li></ul><p><strong>“不完美“函数举例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span> <span class="comment">// 非引用，形参会对实参进行拷贝。</span></span></span><br><span class="line"><span class="function"></span>&#123;                  <span class="comment">// 对于函数内部来说，t有自己的名称，也可以获取它的存储地址，因此它永远都是左值。</span></span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>传递给 otherdef() 函数的参数 t 永远都是左值。</li></ul><p><strong>C++11实现完美转发：</strong></p><p>问题1：怎么解决函数模板参数的左、右值接收问题？</p><p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。<br>但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为<strong>“万能引用”</strong>）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T &amp;&amp;t)</span> <span class="comment">//既可以接受左值，又可以接受右值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);   <span class="comment">// t继续传参，在otherdef()中又变成了左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>记住：在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</li></ul><p>问题2：如何将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数？</p><ul><li><p>C++11引入了一个模板函数 forword() 。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);   <span class="comment">// rvalue</span></span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);   <span class="comment">// lvalue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr></li></ul><h1 id="nullptr：初始化空指针"><a href="#nullptr：初始化空指针" class="headerlink" title="nullptr：初始化空指针"></a>nullptr：初始化空指针</h1><p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p><p>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p><p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);<span class="comment">// int  n</span></span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);<span class="comment">//int  n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。</p><p>如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="number">0</span> );</span><br></pre></td></tr></table></figure><p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 &#x3D;&#x3D;nullptr&#x3D;&#x3D;。</p><p>&#x3D;&#x3D;<strong>在使用 nullptr 之前，读者需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，读者需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std&#x3D;c++0x 编译选项）。</strong>&#x3D;&#x3D;</p><p>**&#x3D;&#x3D;(nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。)&#x3D;&#x3D;**nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。</p><hr><h1 id="shared-ptr智能指针"><a href="#shared-ptr智能指针" class="headerlink" title="shared_ptr智能指针"></a>shared_ptr智能指针</h1><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><p>C++98&#x2F;03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p><p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p><h2 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h2><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr<T>（其中 T 表示指针指向的具体数据类型）的定义位于&#x3D;&#x3D;<code>&lt;memory&gt;</code>&#x3D;&#x3D;头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</strong>&#x3D;&#x3D;</p><h3 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h3><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数</T></p><ol><li><p>通过如下 2 种方式，可以构造出 shared_ptr<T> 类型的空智能指针：</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。&#x3D;&#x3D;</p></li><li><p>在构建 shared_ptr 智能指针，也可以明确其指向。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p><p>​C++11 标准中还提供了 std::make_shared<T> 模板函数，其可以用于初始化 shared_ptr 智能指针</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，shared_ptr<T> 模板还提供有相应的拷贝构造函数和移动构造函数</T></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure><p>p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 &#x3D;&#x3D;p3 为空智能指针，则 p4 也为空智能指针&#x3D;&#x3D;，其引用计数初始值为 0；反之，&#x3D;&#x3D;则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1&#x3D;&#x3D;。</p><p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，&#x3D;&#x3D;用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针&#x3D;&#x3D;。</p><p>注意，&#x3D;&#x3D;同一普通指针不能同时为多个 shared_ptr 对象赋值&#x3D;&#x3D;，否则会导致程序发生异常</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li></ol><p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p><p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：</T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure><p>借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr<T>模板类提供的成员方法</T></h3><p>为了方便用户使用 shared_ptr 智能指针，shared_ptr<T> 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</T></p><table><thead><tr><th>成员方法名</th><th>功 能</th></tr></thead><tbody><tr><td>operator&#x3D;()</td><td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td></tr><tr><td>operator*()</td><td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td></tr><tr><td>operator-&gt;()</td><td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr><tr><td>swap()</td><td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td></tr><tr><td>reset()</td><td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td></tr><tr><td>get()</td><td>获得 shared_ptr 对象内部包含的普通指针。</td></tr><tr><td>use_count()</td><td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td></tr><tr><td>unique()</td><td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td></tr><tr><td>operator bool()</td><td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">10</span><br><span class="line">p1 为空</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure><hr><h1 id="C-智能指针之unique-ptr"><a href="#C-智能指针之unique-ptr" class="headerlink" title="C++智能指针之unique_ptr"></a>C++智能指针之unique_ptr</h1><h2 id="一、unique-ptr"><a href="#一、unique-ptr" class="headerlink" title="一、unique_ptr"></a>一、unique_ptr</h2><p>一个 unique_ptr“拥有”它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr 被销毁时，它所指向的对象也被销毁。</p><p> <strong>unique_ptr的操作</strong></p><p><img src="https://img-blog.csdnimg.cn/ef47727c15734247a9aed330233e0e02.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/de8258bb34394577878e613f3b5b74e3.png" alt="img"></p><h3 id="1-1-unique-ptr类的初始化"><a href="#1-1-unique-ptr类的初始化" class="headerlink" title="1.1 unique_ptr类的初始化"></a>1.1 unique_ptr类的初始化</h3><p>  unique_ptr没有类似shared_ptr中make_shared的标准库函数返回一个unique_ptr，我们定义一个unique_ptr时，需要将它绑定到一个new返回的指针上，并且不能直接将new的结果用赋值运算符“&#x3D;”赋值给unique_ptr（即初始化方式必须采用直接初始化方式）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; p1;<span class="comment">//正确</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;<span class="comment">//正确</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3 id="1-2-unique-ptr禁止拷贝和赋值"><a href="#1-2-unique-ptr禁止拷贝和赋值" class="headerlink" title="1.2 unique_ptr禁止拷贝和赋值"></a>1.2 unique_ptr禁止拷贝和赋值</h3><p>  因为unique_ptr所指向的对象只能有一个unique_ptr指针，也就是一个引用计数。因此unique_ptr不支持普通的拷贝和赋值操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;HelloWorld&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//是错误</span></span><br><span class="line">unique_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p1;<span class="comment">//错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">虽然两个unique_ptr不可以同时指向同一个内存对象，但是可以将一个即将销毁的unqie_ptr指针拷贝或赋值给另一个unqie_ptr</span><br></pre></td></tr></table></figure><p> 函数的参数传递和返回值就是一个很好的例子，因为在函数内部的unique_ptr指针随着作用域的结束会自动销毁，因此可以将其作为返回值，然后将内存传递给另一个unique_ptr指针管理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*unique_ptr&lt;int&gt; clone(int p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    unique_ptr&lt;int&gt; ret(new int(p));</span></span><br><span class="line"><span class="comment">    return ret;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; p = <span class="built_in">clone</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt;*p &lt;&lt; endl; <span class="comment">//打印10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-release、reset函数"><a href="#1-3-release、reset函数" class="headerlink" title="1.3 release、reset函数"></a>1.3 release、reset函数</h3><p>虽然unique_ptr之间不能拷贝与赋值。但是可以使用release和reset函数来将指针的所有权从一个（非const）unique_ptr转移给另一个unique。</p><p><strong>release函数</strong></p><ul><li>将当前的unique_ptr指针所指的内存置为空，并且对这块内存的所有权消失</li><li>返回值：返回当前unique_ptr所指的内存</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;<span class="comment">//p1将自己所指的内存空间置空，并且返回该内存空间。之后对该内存空间的操作权消失，从而p2得到该内存的权限</span></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">release</span>();<span class="comment">//错误，虽然p1断开了与内存的关系，但是没有另一个unqieu_ptr来接手这块内存，造成内存泄漏</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改正：</span></span><br><span class="line"><span class="comment">unique_ptr&lt;string&gt; p2(p1.release()); //将p1的原来内存交给另一个unique_ptr管理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>  因为release函数会使unque_ptr指针与内存之间的关系。所以unique_ptr调用release函数之后必须将返回值传递给另一个unqiue_ptr，否则就会内存泄露</p><hr><p><strong>reset函数</strong></p><ul><li>用来重置当前unqie_ptr指针。</li><li>重置之后接手另一块内存或者一直处于空状态</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>();<span class="comment">//将p1置空，不指向内存对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);<span class="comment">//同上</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;World&quot;</span>))</span></span>;</span><br><span class="line"> </span><br><span class="line">p1.<span class="built_in">reset</span>(p2.<span class="built_in">release</span>());<span class="comment">//p2置空之后，然后p1也置空，然后p1来接手p2所指向的内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-向unique-ptr传递删除器"><a href="#1-4-向unique-ptr传递删除器" class="headerlink" title="1.4 向unique_ptr传递删除器"></a>1.4 向unique_ptr传递删除器</h3><p>与shared_ptr类相同，unique_ptr默认情况下会调用默认析构函数来释放(delete)自己所指向的对象。不过我们也可以通过重载来指定unqie_ptr的删除器。</p><p>  与shared_ptr重载删除器不同，unique_ptr重载删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。</p><p>  与重载关联容器的比较操作类似，我们必须在&lt;&gt;中unique_ptr指向类型之后提供删除器类型。</p><p>  在创建或reset一个这种unique_ptr类型对象时，必须提供一个指定类型的可调用对象（删除器）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span></span><br><span class="line"><span class="comment">//它会调用一个名为fcn的delT类型对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;objT,delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT,fcn)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们使用decltype来指明函数类型，在后面加一个*代表函数指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span> </span>&#123;</span><br><span class="line">    connection c=<span class="built_in">connec</span>(&amp;d);</span><br><span class="line">    <span class="function">unique_ptr&lt;connection,<span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c,end_connection)</span></span>;</span><br><span class="line"> </span><br><span class="line">    ...<span class="comment">//使用这个连接</span></span><br><span class="line">     <span class="comment">//当f函数退出或者异常退出，p都会调用end_connection函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5-unique-ptr与动态数组的使用"><a href="#1-5-unique-ptr与动态数组的使用" class="headerlink" title="1.5 unique_ptr与动态数组的使用"></a>1.5 unique_ptr与动态数组的使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;)</span></span>; <span class="comment">//定义一个指向int型数组的智能指针对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;</span><br><span class="line">arr.<span class="built_in">release</span>();  <span class="comment">//自动调用delete[]销毁其指针</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>[]&gt; arr= <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;  <span class="comment">//错误</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr类操作数组的方法：</span></span><br><span class="line"><span class="comment">unique_ptr操作数组，不提供点和箭头成员运算符，因为数组不是一个对象。但是可以通过下标运算符来访问操作数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        arr[i] = i;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="C-智能指针weak-ptr"><a href="#C-智能指针weak-ptr" class="headerlink" title="C++智能指针weak_ptr"></a>C++智能指针weak_ptr</h1><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>std::weak_ptr 是一种智能指针，通常不单独使用，只能和 shared_ptr 类型指针搭配使用，可以视为 shared_ptr 指针的一种辅助工具。借助 weak_ptr 类型指针可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、通过expired()判断shared_ptr 指针指向的堆内存是否已经被释放等等，还可以解决shared_ptr 循环引用的问题。</p><h3 id="二、内部函数"><a href="#二、内部函数" class="headerlink" title="二、内部函数"></a>二、内部函数</h3><p>std::weak_ptr的成员函数如下：</p><p><img src="https://img-blog.csdnimg.cn/20200730221824168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzMxNjA4NjQx,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="三、std-weak-ptr用法"><a href="#三、std-weak-ptr用法" class="headerlink" title="三、std::weak_ptr用法"></a>三、std::<a href="https://so.csdn.net/so/search?q=weak_ptr&spm=1001.2101.3001.7020">weak_ptr</a>用法</h3><p>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()&#x3D;&#x3D;0，但更快。表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        std::cout &lt;&lt; sh_ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出1</span></span><br><span class="line"> </span><br><span class="line">        <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sh_ptr)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 赋值给weak_ptr后还是输出1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!wp.<span class="built_in">expired</span>())&#123; <span class="comment">// 检查sh_ptr是否还有效</span></span><br><span class="line">            std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr2 = wp.<span class="built_in">lock</span>(); <span class="comment">//将sh_ptr赋值给sh_ptr2</span></span><br><span class="line">            *sh_ptr = <span class="number">100</span>;</span><br><span class="line">            std::cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//delete memory</span></span><br><span class="line">       </span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sh_ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        wp = sh_ptr;</span><br><span class="line">        std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; std::endl;  <span class="comment">// 输出false，引用对象还没删除</span></span><br><span class="line">    &#125; <span class="comment">//delete memory</span></span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; std::endl;  <span class="comment">// 输出true，引用对象已经删除</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>weak_ptr可以使用一个非常重要的成员函数<code>lock()</code>从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当<code>expired()==true</code>的时候，<code>lock()</code>函数将返回一个存储空指针的shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="comment">//sp.reset();</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; pa = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wp指向对象为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sp.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (std::shared_ptr&lt;<span class="type">int</span>&gt; pa = wp.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; *pa &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wp指向对象为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">wp指向对象为空</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="四、循环引用问题"><a href="#四、循环引用问题" class="headerlink" title="四、循环引用问题"></a>四、循环引用问题</h3><p>weak_ptr的一个作用是解决share_ptr的循环引用问题。如下面代码所示，class AA中含有指向class BB的shared指针, class BB 中含有指向class AA的shared指针，这样形成了循环引用。m_bb_ptr和m_aa_ptr的强引用计数永远大于等于1，所以直到程序退出前都不会被退出，这种情况有时候在正常的业务逻辑中是不可避免的，而解决循环引用的方法是改用weak_ptr：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::~AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">shared_ptr&lt;BB&gt; m_bb_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::~BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">shared_ptr&lt;AA&gt; m_aa_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">ptr_a</span><span class="params">(<span class="keyword">new</span> AA)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;BB&gt; <span class="title">ptr_b</span><span class="params">(<span class="keyword">new</span> BB)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_a use_count: &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_b use_count: &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//下面两句导致了AA与BB的循环引用，结果就是AA和BB对象都不会析构</span></span><br><span class="line">ptr_a-&gt;m_bb_ptr = ptr_b;</span><br><span class="line">ptr_b-&gt;m_aa_ptr = ptr_a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_a use_count: &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr_b use_count: &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200730222046259.png" alt="img"></p><p>可以看到由于AA和BB内部的shared_ptr各自保存了对方的一次引用，所以导致了ptr_a和ptr_b销毁的时候都认为内部保存的指针计数没有变成0，所以AA和BB的析构函数不会被调用。解决方法就是把一个shared_ptr替换成weak_ptr。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;AA::~AA() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">weak_ptr&lt;BB&gt; m_bb_ptr;  <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;BB::~BB() called&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">shared_ptr&lt;AA&gt; m_aa_ptr; <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200730222154923.png" alt="img"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="&#x3D;&#x3D;五、总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;五、总结&#x3D;&#x3D;</h3><p>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。<br>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。<br>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。<br>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++常见函数</title>
      <link href="/2024/09/26/C++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/09/26/C++%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h1><p>C++ STL 标准库提供有很多实用的排序函数，如表 1 所示。通过调用它们，我们可以很轻松地实现对普通数组或者容器中指定范围内的元素进行排序。</p><table><thead><tr><th>函数名</th><th>用法</th></tr></thead><tbody><tr><td>sort (first, last)</td><td>对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td></tr><tr><td>stable_sort (first, last)</td><td>和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td></tr><tr><td>partial_sort (first, middle, last)</td><td>从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td></tr><tr><td>partial_sort_copy (first, last, result_first, result_last)</td><td>从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。</td></tr><tr><td>is_sorted (first, last)</td><td>检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td></tr><tr><td>is_sorted_until (first, last)</td><td>和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。</td></tr><tr><td>void nth_element (first, nth, last)</td><td>找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td></tr></tbody></table><h2 id="sort-最常见使用"><a href="#sort-最常见使用" class="headerlink" title="sort()最常见使用"></a>sort()最常见使用</h2><p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p><p><code>sort() 函数是基于快速排序实现的，有关快速排序的具体实现过程，感兴趣的读者可阅读《[快速排序（QSort，快排）算法](https://c.biancheng.net/view/vip_3445.html)》一文。</code></p><p>sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p><ol><li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持。</li><li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li><li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li></ol><p>还需要注意的一点是，对于指定区域内值相等的元素，sort() 函数无法保证它们的相对位置不发生改变。</p><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403211035708.png" alt="image-20240321103559517"></p><p>sort() 函数有 2 种用法，其语法格式分别为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对 [first, last) 区域内的元素做默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="comment">//以普通函数的方式实现自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式实现自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式，对 32、71、12、45 进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">//(12 32 45 71) 26 80 53 33</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//(71 45 32 12) 26 80 53 33</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第二种语法格式，通过自定义比较规则进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());<span class="comment">//12 26 32 33 45 53 71 80</span></span><br><span class="line">    <span class="comment">//输出 myvector 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中分别以函数和函数对象的方式自定义了具有相同功能的 mycomp 和 mycomp2 升序排序规则。需要注意的是，和为关联式容器设定排序规则不同，给 sort() 函数指定排序规则时，需要为其传入一个函数名（例如 mycomp ）或者函数对象（例如 std::greater<int>() 或者 mycomp2()）。</int></p><p>那么，sort() 函数的效率怎么样吗？该函数实现排序的平均时间复杂度为<code>N*log2N</code>（其中 N 为指定区域 [first, last) 中 last 和 first 的距离）。</p><h2 id="stable-sort-不改变元素相对位置"><a href="#stable-sort-不改变元素相对位置" class="headerlink" title="stable_sort()不改变元素相对位置"></a>stable_sort()不改变元素相对位置</h2><p>已经了解了 sort() 函数的功能和用法。值得一提的是，当指定范围内包含多个相等的元素时，sort() 排序函数无法保证不改变它们的相对位置。那么，如果既要完成排序又要保证相等元素的相对位置，该怎么办呢？可以使用 stable_sort() 函数。</p><blockquote><p>有些场景是需要保证相等元素的相对位置的。例如对于一个保存某种事务（比如银行账户）的容器，在处理这些事务之前，为了能够有序更新这些账户，需要按照账号对它们进行排序。而这时就很有可能出现相等的账号（即同一账号在某段时间做多次的存取钱操作），它们的相对顺序意味着添加到容器的时间顺序，此顺序不能修改，否则很可能出现账户透支的情况。</p></blockquote><p>值得一提的是，stable_sort() 函数完全可以看作是 sort() 函数在功能方面的升级版。换句话说，stable_sort() 和 sort() 具有相同的使用场景，就连语法格式也是相同的（后续会讲），只不过前者在功能上除了可以实现排序，还可以保证不改变相等元素的相对位置。</p><p>注意，关于 stable_sort() 函数的使用场景，《<a href="https://c.biancheng.net/view/7457.html">C++ sort() 排序函数</a>》一节已经做了详细的介绍，这里不再赘述。另外，stable_sort() 函数是基于归并排序实现的，关于此排序算法的具体实现过程，感兴趣的读者可阅读《<a href="https://c.biancheng.net/view/vip_3449.html">归并排序算法</a>》一文。</p><h2 id="partial-sort-部分排序"><a href="#partial-sort-部分排序" class="headerlink" title="partial_sort()部分排序"></a>partial_sort()部分排序</h2><p>假设这样一种情境，有一个存有 100 万个元素的容器，但我们只想从中提取出值最小的 10 个元素，该如何实现呢？</p><p>通过前面的学习，读者可能会想到使用 sort() 或者 stable_sort() 排序函数，即通过对容器中存储的 100 万个元素进行排序，就可以成功筛选出最小的 10 个元素。但仅仅为了提取 10 个元素，却要先对 100 万个元素进行排序，可想而知这种实现方式的效率是非常低的。</p><p>对于解决类似的问题，C++ STL 标准库提供了更高效的解决方案，即使用 partial_sort() 或者 partial_sort_copy() 函数，本节就对这 2 个排序函数的功能和用法做详细的讲解。</p><p>首先需要说明的是，partial_sort() 和 partial_sort_copy() 函数都位于 <algorithm> 头文件中，因此在使用这 2 个函数之前，程序中应引入此头文件</algorithm></p><p>要知道，一个函数的功能往往可以从它的函数名中体现出来，以 partial_sort() 函数为例，partial sort 可直译为“部分排序”。partial_sort() 函数的功能确是如此，即该函数可以从指定区域中提取出部分数据，并对它们进行排序。</p><p>但“部分排序”仅仅是对 partial_sort() 函数功能的一个概括，如果想彻底搞清楚它的功能，需要结合该函数的语法格式。partial_sort() 函数有 2 种用法，其语法格式分别为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照默认的升序排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator last)</span></span>;</span><br><span class="line"><span class="comment">//按照 comp 排序规则，对 [first, last) 范围的数据进行筛选并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partial_sort</span> <span class="params">(RandomAccessIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                   RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first、middle 和 last 都是随机访问迭代器，comp 参数用于自定义排序规则。</p><p><strong>partial_sort() 函数会以交换元素存储位置的方式实现部分排序的。具体来说，partial_sort() 会将 [first, last) 范围内最小（或最大）的 middle-first 个元素移动到 [first, middle) 区域中，并对这部分元素做升序（或降序）排序。</strong></p><p>需要注意的是，partial_sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 partial_sort() 函数：</p><ul><li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，partial_sort() 函数只适用于 array、vector、deque 这 3 个容器。</li><li>当选用默认的升序排序规则时，容器中存储的元素类型必须支持 &lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li><li>partial_sort() 函数在实现过程中，需要交换某些元素的存储位置。因此，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partial_sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//以默认的升序排序作为排序规则，将 myvector 中最小的 4 个元素移动到开头位置并排好序</span></span><br><span class="line">    std::<span class="built_in">partial_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, myvector.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次排序:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n第二次排序:\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 以指定的 mycomp2 作为排序规则，将 myvector 中最大的 4 个元素移动到开头位置并排好序</span></span><br><span class="line">    std::<span class="built_in">partial_sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>partial_sort() 函数实现排序的平均时间复杂度为<code>N*log(M)</code>，其中 N 指的是 [first, last) 范围的长度，M 指的是 [first, middle) 范围的长度。比sort()快.</p><h2 id="partial-sort-copy-部分复制排序"><a href="#partial-sort-copy-部分复制排序" class="headerlink" title="partial_sort_copy()部分复制排序"></a>partial_sort_copy()部分复制排序</h2><p>partial_sort_copy() 函数的功能和 partial_sort() 类似，唯一的区别在于，前者不会对原有数据做任何变动，而是先将选定的部分元素拷贝到另外指定的数组或容器中，然后再对这部分元素进行排序。</p><p>partial_sort_copy() 函数也有 2 种语法格式，分别为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认以升序规则进行部分排序</span></span><br><span class="line"><span class="function">RandomAccessIterator <span class="title">partial_sort_copy</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                       InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                       InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                       RandomAccessIterator result_last)</span></span>;</span><br><span class="line"><span class="comment">//以 comp 规则进行部分排序</span></span><br><span class="line"><span class="function">RandomAccessIterator <span class="title">partial_sort_copy</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                       InputIterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                       InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       RandomAccessIterator result_first,</span></span></span><br><span class="line"><span class="params"><span class="function">                       RandomAccessIterator result_last,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器；result_first 和 result_last 为随机访问迭代器；comp 用于自定义排序规则。</p><p><strong>partial_sort_copy() 函数会将 [first, last) 范围内最小（或最大）的 result_last-result_first 个元素复制到 [result_first, result_last) 区域中，并对该区域的元素做升序（或降序）排序。</strong></p><p>值得一提的是，[first, last] 中的这 2 个迭代器类型仅限定为输入迭代器，这意味着相比 partial_sort() 函数，partial_sort_copy() 函数放宽了对存储原有数据的容器类型的限制。换句话说，partial_sort_copy() 函数还支持对 list 容器或者 forward_list 容器中存储的元素进行“部分排序”，而 partial_sort() 函数不行。</p><p>但是，介于 result_first 和 result_last 仍为随机访问迭代器，因此 [result_first, result_last) 指定的区域仍仅限于普通数组和部分类型的容器，这和 partial_sort() 函数对容器的要求是一样的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partial_sort_copy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>       <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> myints[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span> &#125;;</span><br><span class="line">    <span class="comment">//按照默认的排序规则进行部分排序</span></span><br><span class="line">    std::<span class="built_in">partial_sort_copy</span>(mylist.<span class="built_in">begin</span>(), mylist.<span class="built_in">end</span>(), myints, myints + <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次排序：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; myints[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以自定义的 mycomp2 作为排序规则，进行部分排序</span></span><br><span class="line">    std::<span class="built_in">partial_sort_copy</span>(mylist.<span class="built_in">begin</span>(), mylist.<span class="built_in">end</span>(), myints, myints + <span class="number">5</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n第二次排序：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; myints[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，partial_sort_copy() 函数实现排序的平均时间复杂度为<code>N*log(min(N,M))</code>，其中 N 指的是 [first, last) 范围的长度，M 指的是 [result_first, result_last) 范围的长度。</p><h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element()"></a>nth_element()</h2><p>在系统讲解 nth_element() 函数之前，我们先形成一个共识，即在有序序列中，我们可以称第 n 个元素为整个序列中“第 n 大”的元素。比如，下面是一个升序序列：</p><p>2 4 6 8 10</p><p>在这个序列中，我们可以称元素 6 为整个序列中“第 3 小”的元素，并位于第 3 的位置处；同样，元素 8 为整个序列中“第 4 小”的元素，并位于第 4 的位置处。</p><p>简单的理解 nth_element() 函数的功能，当采用默认的升序排序规则（std::less<T>）时，该函数可以从某个序列中找到第 n 小的元素 K，并将 K 移动到序列中第 n 的位置处。不仅如此，整个序列经过 nth_element() 函数处理后，所有位于 K 之前的元素都比 K 小，所有位于 K 之后的元素都比 K 大。（&#x3D;&#x3D;两边并不是有序的&#x3D;&#x3D;）</T></p><p>当然，我们也可以将 nth_element() 函数的排序规则自定义为降序排序，此时该函数会找到第 n 大的元素 K 并将其移动到第 n 的位置处，同时所有位于 K 之前的元素都比 K 大，所有位于 K 之后的元素都比 K 小。</p><p>以下面这个序列为例：</p><p>3 4 1 2 5</p><p>假设按照升序排序，并通过 nth_element() 函数查找此序列中第 3 小的元素，则最终得到的序列可能为：</p><p>2 1 3 4 5</p><p>显然，nth_element() 函数找到了第 3 小的元素 3 并将其位于第 3 的位置，同时元素 3 之前的所有元素都比该元素小，元素 3 之后的所有元素都比该元素大。</p><p>鉴于 nth_element() 函数中各个参数的类型，其只能对普通数组或者部分容器进行排序。换句话说，只有普通数组和符合以下全部条件的容器，才能使用使用 nth_element() 函数：</p><ol><li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，nth_element() 函数只适用于 array、vector、deque 这 3 个容器。</li><li>当选用默认的升序排序规则时，容器中存储的元素类型必须支持 &lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li><li>nth_element() 函数在实现过程中，需要交换某些元素的存储位置。因此，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::nth_element</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//默认的升序排序作为排序规则</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>()+<span class="number">2</span>, myvector.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次nth_element排序：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义的 mycomp2() 或者 mycomp1 降序排序作为排序规则</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">3</span>, myvector.<span class="built_in">end</span>(),mycomp1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n第二次nth_element排序：\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted()"></a>is_sorted()</h2><p>该函数会返回一个 bool 类型值，即如果 [first, last) 范围内的序列符合我们指定的排序规则，则返回 true；反之，函数返回 false。值得一提得是，如果 [first, last) 指定范围内只有 1 个元素，则该函数始终返回 true。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::is_sorted</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::array</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第 2 种语法格式的 is_sorted() 函数，该判断语句会得到执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_sorted</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="built_in">mycomp2</span>())) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;开始对 myvector 容器排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//对 myvector 容器做降序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="built_in">mycomp2</span>());</span><br><span class="line">        <span class="comment">//输出 myvector 容器中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式的 is_sorted() 函数，该判断语句得不到执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_sorted</span>(mylist.<span class="built_in">begin</span>(), mylist.<span class="built_in">end</span>())) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;开始对 mylist 排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并有序序列"><a href="#合并有序序列" class="headerlink" title="合并有序序列"></a>合并有序序列</h1><h2 id="merge-函数"><a href="#merge-函数" class="headerlink" title="merge()函数"></a>merge()函数</h2><p>merge() 函数用于将 2 个有序序列合并为 1 个有序序列，&#x3D;&#x3D;前提是这 2 个有序序列的排序规则相同（要么都是升序，要么都是降序）&#x3D;&#x3D;。并且最终借助该函数获得的新有序序列，其排序规则也和这 2 个有序序列相同。</p><p>举个例子，假设有 2 个序列，分别为<code>5,10,15,20,25</code>和<code>7,14,21,28,35,42</code>，显然它们不仅有序，而且都是升序序列。因此借助 merge() 函数，我们就可以轻松获得如下这个有序序列：</p><p>5 7 10 15 17 20 25 27 37 47 57</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::merge</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//first 和 second 数组中各存有 1 个有序序列</span></span><br><span class="line">    <span class="type">int</span> first[] = &#123; <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span> &#125;;</span><br><span class="line">    <span class="type">int</span> second[] = &#123; <span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">57</span> &#125;;</span><br><span class="line">    <span class="comment">//用于存储新的有序序列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">myvector</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="comment">//将 [first,first+5) 和 [second,second+6) 合并为 1 个有序序列，并存储到 myvector 容器中。</span></span><br><span class="line">    <span class="built_in">merge</span>(first, first + <span class="number">5</span>, second, second + <span class="number">6</span>, myvector.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">//输出 myvector 容器中存储的元素</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，first 数组和 second 数组中各存有 1 个升序序列，通过借助 merge() 函数，我们成功地将它们合并成了一个有序序列，并存储到 myvector 容器中。</p><blockquote><p>注意，<strong>merge() 函数底层是通过拷贝的方式实现合并操作的。</strong>换句话说，上面程序在采用 merge() 函数实现合并操作的同时，并不会对 first 和 second 数组有任何影响。</p></blockquote><p>实际上，对于 2 个有序序列是各自存储（像 first 和 second 这样）还是存储到一起，merge() 函数并不关心，只需要给它传入恰当的迭代器（或指针），该函数就可以正常工作。因此，我们还可以将上面程序改写为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该数组中存储有 2 个有序序列</span></span><br><span class="line"><span class="type">int</span> first[] = &#123; <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">57</span> &#125;;</span><br><span class="line"><span class="comment">//用于存储新的有序序列</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">myvector</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="comment">//将 [first,first+5) 和 [first+5,first+11) 合并为 1 个有序序列，并存储到 myvector 容器中。</span></span><br><span class="line"><span class="built_in">merge</span>(first, first + <span class="number">5</span>,  first + <span class="number">5</span>, first +<span class="number">11</span> , myvector.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><h2 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge()"></a>inplace_merge()</h2><p>当 2 个有序序列存储在同一个数组或容器中时，如果想将它们合并为 1 个有序序列，除了使用 merge() 函数，更推荐使用 inplace_merge() 函数。</p><p>和 merge() 函数相比，inplace_merge() 函数的语法格式要简单很多</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认采用升序的排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inplace_merge</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                    BidirectionalIterator last)</span></span>;</span><br><span class="line"><span class="comment">//采用自定义的 comp 排序规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inplace_merge</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                    BidirectionalIterator last, Compare comp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::merge</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该数组中存储有 2 个有序序列</span></span><br><span class="line">    <span class="type">int</span> first[] = &#123; <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">57</span> &#125;;</span><br><span class="line">    <span class="comment">//将 [first,first+5) 和 [first+5,first+11) 合并为 1 个有序序列。</span></span><br><span class="line">    <span class="built_in">inplace_merge</span>(first, first + <span class="number">5</span>,first +<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; first[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="查找函数"><a href="#查找函数" class="headerlink" title="查找函数"></a>查找函数</h1><h2 id="find-常用"><a href="#find-常用" class="headerlink" title="find()-常用"></a>find()-常用</h2><p>find() 函数本质上是一个模板函数，用于在指定范围内查找和目标元素值相等的第一个元素。</p><p>如下为 find() 函数的语法格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 为输入迭代器，[first, last) 用于指定该函数的查找范围；val 为要查找的目标元素。</p><blockquote><p>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p></blockquote><p>该函数会返回一个输入迭代器，当 find() 函数查找成功时，其指向的是在 [first, last) 区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和 last 相同。</p><p>值得一提的是，find() 函数的底层实现，其实就是用<code>==</code>运算符将 val 和 [first, last) 区域内的元素逐个进行比对。这也就意味着，[first, last) 区域内的元素必须支持<code>==</code>运算符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//find() 函数作用于普通数组</span></span><br><span class="line">    <span class="type">char</span> stl[] =<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="comment">//调用 find() 查找第一个字符 &#x27;c&#x27;</span></span><br><span class="line">    <span class="type">char</span> * p = <span class="built_in">find</span>(stl, stl + <span class="built_in">strlen</span>(stl), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="comment">//判断是否查找成功</span></span><br><span class="line">    <span class="keyword">if</span> (p != stl + <span class="built_in">strlen</span>(stl)) &#123;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find() 函数作用于容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    it = <span class="built_in">find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-if-函数"><a href="#find-if-函数" class="headerlink" title="find_if()函数"></a>find_if()函数</h2><p>和 find() 函数相同，find_if() 函数也用于在指定区域内执行查找操作。不同的是，前者需要明确指定要查找的元素的值，而后者则允许自定义查找规则。</p><p>所谓自定义查找规则，实际上指的是有一个形参且返回值类型为 bool 的函数。值得一提的是，该函数可以是一个普通函数（又称为一元谓词函数），比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((i%<span class="number">2</span>)==<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以是一个函数对象，比如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以函数对象的形式定义一个 find_if() 函数的查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>确切地说，&#x3D;&#x3D;<strong>find_if() 函数会根据指定的查找规则，在指定区域内查找第一个符合该函数要求（使函数返回 true）的元素。</strong>&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find_if</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义一元谓词函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个 find_if() 函数的查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((i % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//调用 find_if() 函数，并以 IsOdd() 一元谓词函数作为查找规则</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="find-if-not"><a href="#find-if-not" class="headerlink" title="find_if_not()"></a>find_if_not()</h2><p>ind_if_not() 函数和 find_if() 函数的功能恰好相反，通过上面的学习我们知道，find_if() 函数用于查找符合谓词函数规则的第一个元素，而 find_if_not() 函数则用于查找第一个不符合谓词函数规则的元素。</p><blockquote><p>和 find_if() 函数一样，find_if_not() 函数也适用于所有的容器，包括所有序列式容器和关联式容器。</p></blockquote><p>同样，该函数也会返回一个输入迭代器，当 find_if_not() 函数查找成功时，该迭代器指向的是查找到的那个元素；反之，如果查找失败，该迭代器的指向和 last 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find_if_not</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义一元谓词函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//调用 find_if() 函数，并以 mycomp() 一元谓词函数作为查找规则</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if_not</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), mycomp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="find-end"><a href="#find-end" class="headerlink" title="find_end()"></a>find_end()</h2><p>find_end() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，常用于在序列 A 中查找序列 B 最后一次出现的位置。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">序列 A：1,2,3,4,5,1,2,3,4,5</span><br><span class="line">序列 B：1,2,3</span><br></pre></td></tr></table></figure><p>通过观察不难发现，序列 B 在序列 A 中出现了 2 次，而借助 find_end() 函数，可以轻松的得到序列 A 中最后一个（也就是第 2 个） {1,2,3}。</p><p>find_end() 函数的语法格式有 2 种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找序列 [first1, last1) 中最后一个子序列 [first2, last2)</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">find_end</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//查找序列 [first2, last2) 中，和 [first2, last2) 序列满足 pred 规则的最后一个子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">find_end</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，各个参数的含义如下：</p><ul><li>first1、last1：都为正向迭代器，其组合 [first1, last1) 用于指定查找范围（也就是上面例子中的序列 A）；</li><li>first2、last2：都为正向迭代器，其组合 [first2, last2) 用于指定要查找的序列（也就是上面例子中的序列 B）；</li><li>pred：用于自定义查找规则。该规则实际上是一个包含 2 个参数且返回值类型为 bool 的函数（第一个参数接收 [first1, last1) 范围内的元素，第二个参数接收 [first2, last2) 范围内的元素）。函数定义的形式可以是普通函数，也可以是函数对象。</li></ul><blockquote><p>实际上，第一种语法格式也可以看做是包含一个默认的 pred 参数，该参数指定的是一种相等规则，即在 [first1, last1) 范围内查找和 [first2, last2) 中各个元素对应相等的子序列；而借助第二种语法格式，我们可以自定义一个当前场景需要的匹配规则。</p></blockquote><p>同时，find_end() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的形式定义一个匹配规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个匹配规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> myarr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_end</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), myarr, myarr + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最后一个&#123;1,2,3&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> myarr2[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第二种语法格式</span></span><br><span class="line">    it = <span class="built_in">find_end</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), myarr2, myarr2 + <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最后一个&#123;2,3,4&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>匹配{1,2,3}的起始位置为：7,*it &#x3D; 1<br>匹配{2,3,4}的起始位置为：4,*it &#x3D; 8</p><p>上面程序中共调用了 2 次 find_end() 函数：</p><ol><li>第 22 行代码：调用了第一种语法格式的 find_end() 函数，其功能是在 myvector 容器中查找和 {1,2,3} 相等的最后一个子序列，显然最后一个 {1,2,3} 中元素 1 的位置下标为 7（myvector 容器下标从 0 开始）；</li><li>第 29 行代码：调用了第二种格式的 find_end() 函数，其匹配规则为 mycomp2，即在 myvector 容器中找到最后一个子序列，该序列中的元素能分别被 {2、4、6} 中的元素整除。显然，myvector 容器中 {4,8,12} 和 {8,12,18} 都符合，该函数会找到后者并返回一个指向元素 8 的迭代器。</li></ol><blockquote><p>注意，find_end() 函数的第一种语法格式，其底层是借助 &#x3D;&#x3D; 运算符实现的。这意味着，如果 [first1, last1] 和 [first2, last2] 区域内的元素为自定义的类对象或结构体变量时，使用该函数之前需要对 &#x3D;&#x3D; 运算符进行重载。</p></blockquote><hr><h2 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of()"></a>find_first_of()</h2><p>在某些情境中，我们可能需要在 A 序列中查找和 B 序列中任意元素相匹配的第一个元素，这时就可以使用 find_first_of() 函数。</p><p>ind_first_of() 函数用于在 [first1, last1) 范围内查找和 [first2, last2) 中任何元素相匹配的第一个元素。如果匹配成功，该函数会返回一个指向该元素的输入迭代器；反之，则返回一个和 last1 迭代器指向相同的输入迭代器。</p><p>注意，当采用第一种语法格式时，如果 [first1, last1) 或者 [first2, last2) 范围内的元素类型为自定义的类对象或者结构体变量，此时应对 &#x3D;&#x3D; 运算符进行重载，使其适用于当前场景。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::find_first_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义二元谓词函数，作为 find_first_of() 函数的匹配规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> c1, <span class="type">int</span> c2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c2 % c1 == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个 find_first_of() 函数的匹配规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; c1, <span class="type">const</span> <span class="type">int</span>&amp; c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c2 % c1 == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> url[] = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch[] = <span class="string">&quot;stl&quot;</span>;</span><br><span class="line">    <span class="comment">//调用第一种语法格式，找到 url 中和 &quot;stl&quot; 任一字符相同的第一个字符</span></span><br><span class="line">    <span class="type">char</span> *it = <span class="built_in">find_first_of</span>(url, url + <span class="number">27</span>, ch, ch + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != url + <span class="number">27</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*it = &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="type">int</span> inter[] = &#123; <span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第二种语法格式，找到 myvector 容器中和 3、5、7 任一元素有 c2%c1=0 关系的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">find_first_of</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), inter, inter + <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (iter != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find()"></a>adjacent_find()</h2><p>adjacent_find() 函数用于在指定范围内查找 2 个连续相等的元素。该函数的语法格式为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找 2 个连续相等的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span> <span class="params">(ForwardIterator first, ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//查找 2 个连续满足 pred 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                               BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 都为正向迭代器，其组合 [first, last) 用于指定该函数的查找范围；pred 用于接收一个包含 2 个参数且返回值类型为 bool 的函数，以实现自定义查找规则。</p><p>值得一提的是，pred 参数接收的函数既可以定义为普通函数，也可以用函数对象的形式定义。</p><p>另外，该函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向的是连续相等元素的第 1 个元素；而如果查找失败，该迭代器的指向和 last 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::adjacent_find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以创建普通函数的形式定义一个查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i == j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; _Left, <span class="type">const</span> <span class="type">int</span>&amp; _Right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_Left == _Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">5</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;one : &quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用第二种格式，也可以使用 mycomp1</span></span><br><span class="line">    it = <span class="built_in">adjacent_find</span>(++it, myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;two : &quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>one : 30<br>two : 10</p><p>可以看到，程序中调用了 2 次 adjacent_find() 函数：</p><ul><li>第 19 行：使用该函数的第一种语法格式，查找整个 myvector 容器中首个连续 2 个相等的元素，显然最先找到的是 30；</li><li>第 25 行：使用该函数的第二种语法格式，查找 {30,20,10,10,20} 部分中是否有连续 2 个符合 mycomp2 规则的元素。不过，程序中自定义的 mycomp1 或 mycomp2 查找规则也是查找 2 个连续相等的元素，因此最先找到的是元素 10。</li></ul><hr><h2 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h2><p>find_end() 函数用于在序列 A 中查找序列 B 最后一次出现的位置。那么，如果想知道序列 B 在序列 A 中第一次出现的位置，该如何实现呢？可以借助 search() 函数。</p><p>search() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，其功能恰好和 find_end() 函数相反，用于在序列 A 中查找序列 B 第一次出现的位置。</p><p>例如，仍以如下两个序列为例：</p><p>序列 A：1,2,3,4,5,1,2,3,4,5<br>序列 B：1,2,3</p><p>可以看到，序列 B 在序列 A 中出现了 2 次。借助 find_end() 函数，我们可以找到序列 A 中最后一个（也就是第 2 个）{1,2,3}；而借助 search() 函数，我们可以找到序列 A 中第 1 个 {1,2,3}。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找 [first1, last1) 范围内第一个 [first2, last2) 子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ForwardIterator first2, ForwardIterator last2)</span></span>;</span><br><span class="line"><span class="comment">//查找 [first1, last1) 范围内，和 [first2, last2) 序列满足 pred 规则的第一个子序列</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search</span> <span class="params">(ForwardIterator first1, ForwardIterator last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ForwardIterator first2, ForwardIterator last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                        BinaryPredicate pred)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，各个参数的含义分别为：</p><ul><li>first1、last1：都为正向迭代器，其组合 [first1, last1) 用于指定查找范围（也就是上面例子中的序列 A）；</li><li>first2、last2：都为正向迭代器，其组合 [first2, last2) 用于指定要查找的序列（也就是上面例子中的序列 B）；</li><li>pred：用于自定义查找规则。该规则实际上是一个包含 2 个参数且返回值类型为 bool 的函数（第一个参数接收 [first1, last1) 范围内的元素，第二个参数接收 [first2, last2) 范围内的元素）。函数定义的形式可以是普通函数，也可以是函数对象。</li></ul><blockquote><p>实际上，第一种语法格式也可以看做是包含一个默认的 pred 参数，该参数指定的是一种相等规则，即在 [first1, last1) 范围内查找和 [first2, last2) 中各个元素对应相等的子序列；而借助第二种语法格式，我们可以自定义一个当前场景需要的匹配规则。</p></blockquote><p>同时，search() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last1 迭代器相同。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::search</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的形式定义一个匹配规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个匹配规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> myarr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">search</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), myarr, myarr + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个&#123;1,2,3&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> myarr2[] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第二种语法格式</span></span><br><span class="line">    it = <span class="built_in">search</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), myarr2, myarr2 + <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (it != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一个&#123;2,3,4&#125;的起始位置为：&quot;</span> &lt;&lt; it - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>第一个{1,2,3}的起始位置为：0,*it &#x3D; 1<br>第一个{2,3,4}的起始位置为：3,*it &#x3D; 4</p><p>通过程序的执行结果可以看到，第 22 行代码借助 search() 函数找到了 myvector 容器中第一个 {1,2,3}，并返回了一个指向元素 1 的迭代器（其下标位置为 0）。</p><p>而在第 29 行中，search() 函数使用的是第 2 种格式，其自定义了 mycomp2 匹配规则，即在 myvector 容器中找到第一个连续的 3 个元素，它们能分别被 2、4、6 整除。显然，myvector 容器中符合要求的子序列有 2 个，分别为 {4,8,12} 和 {8,12,18}，但 search() 函数只会查找到第一个，并返回指向元素 4 的迭代器（其下标为 3）。</p><hr><h2 id="search-n-鸡肋"><a href="#search-n-鸡肋" class="headerlink" title="search_n() 鸡肋"></a>search_n() 鸡肋</h2><p>已经详细介绍了 search() 函数的功能和用法。在此基础上，本节再介绍一个功能类似的函数，即 search_n() 函数。</p><p>和 search() 一样，search_n() 函数也定义在<code>&lt;algorithm&gt;</code>头文件中，用于在指定区域内查找第一个符合要求的子序列。不同之处在于，前者查找的子序列中可包含多个不同的元素，而后者查找的只能是包含多个相同元素的子序列。</p><p>关于 search() 函数和 search_n() 函数的区别，给大家举个例子，下面有 3 个序列：</p><p>序列 A：1,2,3,4,4,4,1,2,3,4,4,4<br>序列 B：1,2,3<br>序列 C：4,4,4</p><p>如果想查找序列 B 在序列 A 中第一次出现的位置，就只能使用 search() 函数；而如果想查找序列 C 在序列 A 中第一次出现的位置，既可以使用 search() 函数，也可以使用 search_n() 函数。</p><p>search_n() 函数的语法格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 [first, last] 中查找 count 个 val 第一次连续出现的位置</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Size count, <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last] 中查找第一个序列，该序列和 count 个 val 满足 pred 匹配规则</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">search_n</span> <span class="params">( ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Size count, <span class="type">const</span> T&amp; val, BinaryPredicate pred )</span></span>;</span><br></pre></td></tr></table></figure><p>其中，各个参数的含义分别为：</p><ul><li>first、last：都为正向迭代器，其组合 [first, last) 用于指定查找范围（也就是上面例子中的序列 A）；</li><li>count、val：指定要查找的元素个数和元素值，以上面的序列 B 为例，该序列实际上就是 3 个元素 4，其中 count 为 3，val 为 4；</li><li>pred：用于自定义查找规则。该规则实际上是一个包含 2 个参数且返回值类型为 bool 的函数（第一个参数接收[first, last) 范围内的元素，第二个参数接收 val）。函数定义的形式可以是普通函数，也可以是函数对象。</li></ul><blockquote><p>实际上，第一种语法格式也可以看做是包含一个默认的 pred 参数，该参数指定的是一种相等规则，即在 [first, last) 范围内查找和 count 个 val 相等的子序列；而借助第二种语法格式，我们可以自定义一个当前场景需要的匹配规则。</p></blockquote><p>同时，search_n() 函数会返回一个正向迭代器，当函数查找成功时，该迭代器指向查找到的子序列中的第一个元素；反之，如果查找失败，则该迭代器的指向和 last 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::search_n</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的形式定义一个匹配规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义一个匹配规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%j == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式,查找 myvector 容器中第一个 &#123;4,4,4&#125;</span></span><br><span class="line">    <span class="type">int</span> * it = <span class="built_in">search_n</span>(a, a+<span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != a+<span class="number">12</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;one：&quot;</span> &lt;&lt; it - a &lt;&lt; <span class="string">&quot;,*it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">//调用第二种语法格式，以自定义的 mycomp2 作为匹配规则，查找 myvector 容器中和 &#123;16,16,16&#125; 满足 mycomp2 规则的序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">search_n</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">2</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">if</span> (iter != myvector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;two：&quot;</span> &lt;&lt; iter - myvector.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>one：3,*it &#x3D; 4<br>two：1,*iter &#x3D; 2</p><p>程序中先后调用了 2 种语法格式的 search_n() 函数，其中第 28 行代码中，search_n() 函数不再采用默认的相等匹配规则，而是采用了自定义了 mycomp2 匹配规则。这意味着，该函数会去 myvector 容器中查找一个子序列，该序列中的 3 个元素都满足和 2 有 (i%j &#x3D;&#x3D; 0) 的关系。显然，myvector 容器中符合条件的子序列有 2 个，分别为 {2,4,8} 和 {4,6,8}，但 search_n() 函数只会查找到 {2,4,8}。</p><blockquote><p>注意，search_n() 函数的第一种语法格式，其底层是借助 &#x3D;&#x3D; 运算符实现的。这意味着，如果 [first, last] 区域内的元素为自定义的类对象或结构体变量时，使用此格式的 search_n() 函数之前，需要对 &#x3D;&#x3D; 运算符进行重载。</p></blockquote><hr><h1 id="筛选函数"><a href="#筛选函数" class="headerlink" title="筛选函数"></a>筛选函数</h1><h2 id="partition"><a href="#partition" class="headerlink" title="partition()"></a>partition()</h2><p>partition 可直译为“分组”，partition() 函数可根据用户自定义的筛选规则，重新排列指定区域内存储的数据，使其分为 2 组，第一组为符合筛选条件的数据，另一组为不符合筛选条件的数据。</p><p>举个例子，假设有一个数组 a[9]，其存储数据如下：</p><p>1 2 3 4 5 6 7 8 9</p><p>在此基础上，如果设定筛选规则为 i%2&#x3D;0（其中 i 即代指数组 a 中的各个元素），则借助 partition() 函数，a[9] 数组中存储数据的顺序可能变为：</p><p>1 9 3 7 5 6 4 8 2</p><p>其中 {1,9,3,7,5} 为第一组，{6,4,8,2} 为第二组。显然前者中的各个元素都符合筛选条件，而后者则都不符合。由此还可看出，partition() 函数只会根据筛选条件将数据进行分组，并不关心分组后各个元素具体的存储位置。</p><blockquote><p>如果想在分组之后仍不改变各元素之间的相对位置，可以选用 stable_partition() 函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partition</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义partition()函数的筛选规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i % <span class="number">2</span>) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义筛选规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator bound;</span><br><span class="line">    <span class="comment">//以 mycomp2 规则，对 myvector 容器中的数据进行分组</span></span><br><span class="line">    bound = std::<span class="built_in">partition</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nbound = &quot;</span> &lt;&lt; *bound;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>8 2 6 4 5 3 7 1 9<br>bound &#x3D; 5</p><p>可以看到，程序中借助 partition() 对 myvector 容器中的数据进行了再加工，基于 mycomp2() 筛选规则，能够被 2 整除的元素位于第 1 组，不能被 2 整除的元素位于第 2 组。</p><p>同时，parition() 函数会返回一个迭代器，通过观察程序的执行结果可以看到，该迭代器指向的是元素 5，同时也是第 2 组数据中的第 1 个元素。</p><hr><h2 id="stable-partition"><a href="#stable-partition" class="headerlink" title="stable_partition()"></a>stable_partition()</h2><p>partition() 函数只负责对指定区域内的数据进行分组，并不保证各组中元素的相对位置不发生改变。而如果想在分组的同时保证不改变各组中元素的相对位置，可以使用 stable_partition() 函数。</p><p>仍以数组 a[9] 举例，其存储的数据如下：</p><p>1 2 3 4 5 6 7 8 9</p><p>假定筛选规则为 i%2&#x3D;0（其中 i 即代指数组 a 中的各个元素），则借助 stable_partition() 函数，a[9] 数组中存储数据的顺序为：</p><p>2 4 6 8 1 3 5 7 9</p><hr><h2 id="partition-copy"><a href="#partition-copy" class="headerlink" title="partition_copy()"></a>partition_copy()</h2><p>而在某些场景中，我们需要类似 partition() 或者 stable_partition() 函数“分组”的功能，但并不想对原序列做任何修改。这种情况下，就可以考虑使用 partition_copy() 函数。</p><p>和 stable_partition() 一样，partition_copy() 函数也能按照某个筛选规则对指定区域内的数据进行“分组”，并且分组后不会改变各个元素的相对位置。更重要的是，partition_copy() 函数不会对原序列做修改，而是以复制的方式将序列中各个元组“分组”到其它的指定位置存储。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partition_copy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义筛选规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i % <span class="number">2</span>) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义筛选规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;, c[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//以 mycomp 规则，对 myvector 容器中的数据进行分组，这里的 mycomp 还可以改为 mycomp2()，即以 mycomp2 为筛选规则</span></span><br><span class="line">    pair&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; result= <span class="built_in">partition_copy</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), b, c, mycomp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[10]：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *p = b; p &lt; result.first; p++) &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nc[10]：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *p = c; p &lt; result.second; p++) &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>b[10]：2 4 6 8<br>c[10]：1 3 5 7 9</p><blockquote><p>程序中仅演示了如何用数组来存储 partition_copy() 函数分组后的数据，当然也可以用容器来存储。</p></blockquote><hr><h1 id="分界指向函数"><a href="#分界指向函数" class="headerlink" title="分界指向函数"></a>分界指向函数</h1><h2 id="partition-point"><a href="#partition-point" class="headerlink" title="partition_point()"></a>partition_point()</h2><p>事实上，有些数据本身就已经是按照某个筛选规则分好组的，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7      &lt;-- 根据规则 i&lt;4，&#123;1,2,3&#125; 为一组，&#123;4,5,6,7&#125; 为另一组</span><br><span class="line">2,4,6,8,1,3,5,7,9  &lt;-- 根据规则 i%2=0，&#123;2,4,6,8&#125; 为一组，&#123;1,3,5,7,9&#125; 为另一组</span><br></pre></td></tr></table></figure><p>类似上面这样已经“分好组”的数据，在使用时会有一个问题，即不知道两组数据之间的分界在什么位置。有读者可能想到，再调用一次 partition()、stale_partition() 或者 partition_copy() 不就可以了吗？这种方法确实可行，但对已经分好组的数据再进行一次分组，是没有任何必要的。</p><p>实际上，对于如何在已分好组的数据中找到分界位置，C++ 11标准库提供了专门解决此问题的函数，即 partition_point() 函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::partition_point</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义筛选规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i % <span class="number">2</span>) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义筛选规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//根据 mycomp 规则，为 myvector 容器中的数据找出分界</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">partition_point</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),mycomp);</span><br><span class="line">    <span class="comment">//输出第一组的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myvector.<span class="built_in">begin</span>(); it != iter; ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//输出第二组的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = iter; it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>2 4 6 8<br>1 3 5 7 9<br>*iter &#x3D; 1</p><p>通过分析程序并结合输出结果可以看到，partition_point() 返回了一个指向元素 1 的迭代器，而该元素为 myvector 容器中第一个不符合 mycomp 规则的元素，同时其也可以第二组数据中第一个元素。</p><hr><h2 id="lower-bound-不小于的第一个元素"><a href="#lower-bound-不小于的第一个元素" class="headerlink" title="lower_bound()不小于的第一个元素"></a>lower_bound()不小于的第一个元素</h2><p>lower_bound() 函数用于在指定区域内查找&#x3D;&#x3D;不小于&#x3D;&#x3D;目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</p><p>该函数还会返回一个正向迭代器，当查找成功时，迭代器指向找到的元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。</p><p><code>原理是二分查找</code></p><p>再次强调，该函数仅适用于已排好序的序列。所谓“已排好序”，指的是 [first, last) 区域内所有令 element&lt;val（或者 comp(element,val)，其中 element 为指定范围内的元素）成立的元素都位于不成立元素的前面。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::lower_bound</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i&gt;j; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//从 a 数组中找到第一个不小于 3 的元素</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//根据 mycomp2 规则，从 myvector 容器中找到第一个违背 mycomp2 规则的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">lower_bound</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="upper-bound-大于的第一个元素"><a href="#upper-bound-大于的第一个元素" class="headerlink" title="upper_bound()大于的第一个元素"></a>upper_bound()大于的第一个元素</h2><p>upper_bound() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，用于在指定范围内查找&#x3D;&#x3D;大&#x3D;&#x3D;于目标值的第一个元素。该函数的语法格式有 2 种，分别是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个大于 val 的元素。</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>由于 upper_bound() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。注意，<strong>这里所说的“已排好序”，并不要求数据完全按照某个排序规则进行升序或降序排序，而仅仅要求 [first, last) 区域内所有令 element&lt;val（或者 comp(val, element）成立的元素都位于不成立元素的前面（其中 element 为指定范围内的元素）。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::upper_bound</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i &gt; j; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//从 a 数组中找到第一个大于 3 的元素</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">upper_bound</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//根据 mycomp2 规则，从 myvector 容器中找到第一个违背 mycomp2 规则的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">upper_bound</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*iter = &quot;</span> &lt;&lt; *iter;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="equel-range-范围查询相等"><a href="#equel-range-范围查询相等" class="headerlink" title="equel_range()范围查询相等"></a>equel_range()范围查询相等</h2><p>equel_range() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，用于在指定范围内查找等于目标值的所有元素。</p><p>得一提的是，当指定范围内的数据支持用 &lt; 小于运算符直接做比较时，可以使用如下格式的 equel_range() 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//找到 [first, last) 范围中所有等于 val 的元素</span><br><span class="line">pair&lt;ForwardIterator,ForwardIterator&gt; equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val);</span><br></pre></td></tr></table></figure><p>如果指定范围内的数据为自定义的类型（用结构体或类），就需要自定义比较规则，这种情况下可以使用如下格式的 equel_range() 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//找到 [first, last) 范围内所有等于 val 的元素</span><br><span class="line">pair&lt;ForwardIterator,ForwardIterator&gt; equal_range (ForwardIterator first, ForwardIterator last, const T&amp; val, Compare comp);</span><br></pre></td></tr></table></figure><p>以上 2 种格式中，first 和 last 都为正向迭代器，[first, last) 用于指定该函数的作用范围；val 用于指定目标值；comp 用于指定比较规则，此参数可接收一个包含 2 个形参（第二个形参值始终为 val）且返回值为 bool 类型的函数，可以是普通函数，也可以是函数对象。</p><p>同时，该函数会返回一个 pair 类型值，其包含 2 个正向迭代器。当查找成功时：</p><ol><li>第 1 个迭代器指向的是 [first, last) 区域中第一个等于 val 的元素；</li><li>第 2 个迭代器指向的是 [first, last) 区域中第一个大于 val 的元素。</li></ol><p>反之如果查找失败，则这 2 个迭代器要么都指向大于 val 的第一个元素（如果有），要么都和 last 迭代器指向相同。</p><p>需要注意的是，由于 equel_range() 底层实现采用的是二分查找的方式，因此该函数仅适用于“已排好序”的序列。所谓“已排好序”，并不是要求 [first, last) 区域内的数据严格按照某个排序规则进行升序或降序排序，只要满足“所有令 element&lt;val（或者 comp(element,val）成立的元素都位于不成立元素的前面（其中 element 为指定范围内的元素）”即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::equal_range</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i &gt; j; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">9</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">//从 a 数组中找到所有的元素 4</span></span><br><span class="line">    pair&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; range = <span class="built_in">equal_range</span>(a, a + <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[9]：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *p = range.first; p &lt; range.second; ++p) &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;myvector&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    pair&lt;vector&lt;<span class="type">int</span>&gt;::iterator, vector&lt;<span class="type">int</span>&gt;::iterator&gt; range2;</span><br><span class="line">    <span class="comment">//在 myvector 容器中找到所有的元素 3</span></span><br><span class="line">    range2 = <span class="built_in">equal_range</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">3</span>,<span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nmyvector：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range2.first; it != range2.second; ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search()"></a>binary_search()</h2><p>binary_search() 函数定义在<code>&lt;algorithm&gt;</code>头文件中，用于查找指定区域内是否包含某个目标元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::binary_search</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//以普通函数的方式定义查找规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i &gt; j; &#125;</span><br><span class="line"><span class="comment">//以函数对象的形式定义查找规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i, <span class="type">const</span> <span class="type">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line">    <span class="comment">//从 a 数组中查找元素 4</span></span><br><span class="line">    <span class="type">bool</span> haselem = <span class="built_in">binary_search</span>(a, a + <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;haselem：&quot;</span> &lt;&lt; haselem &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//从 myvector 容器查找元素 3</span></span><br><span class="line">    <span class="type">bool</span> haselem2 = <span class="built_in">binary_search</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="built_in">mycomp2</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;haselem2：&quot;</span> &lt;&lt; haselem2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="all-of、any-of及none-of"><a href="#all-of、any-of及none-of" class="headerlink" title="all_of、any_of及none_of"></a>all_of、any_of及none_of</h2><p>用来检查在算法应用到序列中的元素上时，什么时候使谓词返回 true。这些算法的前两个参数是定义谓词应用范围的输入迭代器；第三个参数指定了谓词。检查元素是否能让谓词返回 true 似乎很简单，但它却是十分有用的。</p><ul><li>all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。</li><li>any_of() 算法会返回 true，前提是序列中的任意一个元素都可以使谓词返回 true。</li><li>none_of() 算法会返回 true，前提是序列中没有元素可以使谓词返回 true。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; ages &#123;<span class="number">22</span>, <span class="number">19</span>, <span class="number">46</span>, <span class="number">75</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">66</span>, <span class="number">61</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">19</span>&#125;;</span><br><span class="line"><span class="type">int</span> min_age&#123;<span class="number">18</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span>&lt;&lt; (std::<span class="built_in">none_of</span>(std::<span class="built_in">begin</span>(ages), std::<span class="built_in">end</span>(ages),[min_age](<span class="type">int</span> age) &#123; <span class="keyword">return</span> age &lt; min_age; &#125;) ? <span class="string">&quot;no&quot;</span>: <span class="string">&quot;some&quot;</span>) &lt;&lt; <span class="string">&quot; people under &quot;</span> &lt;&lt; min_age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这个谓词是一个 lambda 表达式，用来将传入的 ages 容器中的元素和 min_age 的值作比较。用 none_of() 返回的布尔值来选择包含在输出信息中的是“no”还是“some”。当 ages 中没有元素小于 min_age 时，none_of() 算法会返回 true。在这种情况下，会选择“no”。当然，用 any_of() 也能产生同样的结果：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span>&lt;&lt; (std::<span class="built_in">any_of</span>(std::<span class="built_in">begin</span>(ages), std::<span class="built_in">end</span>(ages),[min_age] (<span class="type">int</span> age) &#123; <span class="keyword">return</span> age &lt; min_age;&#125;) ? <span class="string">&quot;some&quot;</span>:<span class="string">&quot;no&quot;</span>) &lt;&lt;<span class="string">&quot; people under &quot;</span> &lt;&lt; min_age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>只有在有一个或多个元素小于 min_age 时，any_of() 算法才会返回 true。</p><p>没有元素小于 min_age，所以也会选择“no”。</p><p>下面是一段代码，用来展示用 all_of() 检查 ages 容器中的元素：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> good_age&#123;<span class="number">100</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; (std::<span class="built_in">all_of</span>(std::<span class="built_in">begin</span>(ages), std::<span class="built_in">end</span>(ages),[good_age] (<span class="type">int</span> age) &#123; <span class="keyword">return</span> age &lt; good_age; &#125;) ? <span class="string">&quot;None&quot;</span>: <span class="string">&quot;Some&quot;</span>) &lt;&lt; <span class="string">&quot; of the people are centenarians.&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h2 id="count-和-count-if"><a href="#count-和-count-if" class="headerlink" title="count 和 count_if"></a>count 和 count_if</h2><p>count 和 count_if 可以告诉我们，在前两个参数指定的范围内，有多少满足指定的第三个参数条件的元素。count() 会返回等同于第三个参数的元素的个数。count_if() 会返回可以使作为第三个参数的谓词返回 true 的元素个数。</p><p>下面是一些将这些算法应用到 ages 容器的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; ages &#123;<span class="number">22</span>, <span class="number">19</span>, <span class="number">46</span>, <span class="number">75</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">66</span>, <span class="number">61</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">19</span>&#125;;</span><br><span class="line"><span class="type">int</span> the_age&#123;<span class="number">19</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span>&lt;&lt; std::<span class="built_in">count</span>(std::<span class="built_in">begin</span>(ages),std::<span class="built_in">end</span>(ages),the_age)&lt;&lt; <span class="string">&quot; people aged &quot;</span>&lt;&lt; the_age &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> max_age&#123;<span class="number">60</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span>&lt;&lt; std::<span class="built_in">count_if</span>(std::<span class="built_in">begin</span>(ages), std::<span class="built_in">end</span>(ages),[max_age](<span class="type">int</span> age) &#123; <span class="keyword">return</span> age &gt; max_age; &#125;) &lt;&lt; <span class="string">&quot; people aged over &quot;</span> &lt;&lt; max_age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>在第一条输出语句中使用 count() 算法来确定 ages 中等于 the_age 的元素个数，第二条输出语句使用 count_if() 来报告大于 max_age 的元素个数。</p><h1 id="比较算法"><a href="#比较算法" class="headerlink" title="比较算法"></a>比较算法</h1><h2 id="equal-STL-equal"><a href="#equal-STL-equal" class="headerlink" title="equal(STL equal)"></a>equal(STL equal)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the equal() algorithm</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                                      <span class="comment">// For standard streams</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>                                        <span class="comment">// For vector container</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                                     <span class="comment">// For equal() algorithm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>                                      <span class="comment">// For stream iterators</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                                        <span class="comment">// For string class</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;string&gt; words1 &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line">    std::vector&lt;string&gt; words2 &#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter1 = std::<span class="built_in">begin</span>(words1);</span><br><span class="line">    <span class="keyword">auto</span> end_iter1 = std::<span class="built_in">end</span>(words1);</span><br><span class="line">    <span class="keyword">auto</span> iter2 = std::<span class="built_in">begin</span>(words2);</span><br><span class="line">    <span class="keyword">auto</span> end_iter2 = std::<span class="built_in">end</span>(words2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Container - words1:&quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(iter1, end_iter1, std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nContainer - words2:&quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(iter2, end_iter2, std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n1. Compare from words1[1] to end with words2:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1 + <span class="number">1</span>, end_iter1, iter2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2. Compare from words2[0] to second-to-last with words1:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter2, end_iter2 - <span class="number">1</span>, iter1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3. Compare from words1[1] to words1[5] with words2:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1 + <span class="number">1</span>, iter1 + <span class="number">6</span>, iter2) &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;4. Compare first 6 from words1 with first 6 in words2:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1, iter1 + <span class="number">6</span>, iter2, iter2 + <span class="number">6</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5. Compare all words1 with words2:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1, end_iter1, iter2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;6. Compare all of words1 with all of words2:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1, end_iter1, iter2, end_iter2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;7. Compare from words1[1] to end with words2 from first to second-to-last:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::<span class="built_in">equal</span>(iter1 + <span class="number">1</span>, end_iter1, iter2, end_iter2 - <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Container - words1: one two three four five six seven eight nine</span><br><span class="line">Container - words2: two three four five six seven eight nine ten</span><br><span class="line"><span class="number">1.</span>Compare from words1[<span class="number">1</span>] to end with words2: <span class="literal">true</span></span><br><span class="line"><span class="number">2.</span>Compare from words2[<span class="number">0</span>] to second-to-last with words1: <span class="literal">false</span></span><br><span class="line"><span class="number">3.</span>Compare from words1[<span class="number">1</span>] to wordsl[<span class="number">5</span>] with words2: <span class="literal">true</span></span><br><span class="line"><span class="number">4.</span>Compare first <span class="number">6</span> from words1 with first <span class="number">6</span> in words2: <span class="literal">false</span></span><br><span class="line"><span class="number">5.</span>Compare all wordsl with words2: <span class="literal">false</span></span><br><span class="line"><span class="number">6.</span>Compare all of words1 with all of words2: <span class="literal">false</span></span><br><span class="line"><span class="number">7.</span>Compare from words1[<span class="number">1</span>] to end with words2 from first to second_to_last: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在这个示例中，对来自于 words1 和 words2 容器的元素的不同序列进行了比较。equal() 调用产生这些输出的原因如下：</p><ul><li>第 1 条语句的输出为 true，因为 words1 的第二个元素到最后一个元素都从 words2 的第一个元素开始匹配。第二个序列的元素个数比第一个序列的元素个数多 1，<strong>但 第一个序列的元素个数决定了比较多少个对应的元素。</strong></li><li>第 2 条语句的输出为 false，因为有直接的不匹配；words2 和 words1 的第一个元素不同。</li><li>第 3 条语句的输出为 true，因为 word1 中从第二个元素开始的 5 个元素和 words2 的前五个元素相等。</li><li>在第 4 条语句中，words2 的元素序列是由开始和结束迭代器指定的。序列长度相同，但它们的第一个元素不同，所以结果为 false。</li><li>在第 5 条语句中，两个序列的第一个元素直接就不匹配，所以结果为 false。</li><li>第 6 条语句的输出为 false，因为序列是不同的。这条语句不同于前面的 equal() 调用，因为指定了第二个序列的结束迭代器。</li><li>第 7 条语句会从 words1 的第二个元素开始，与 word2 从第一个元素开始比较相同个数的元素，所以输出为 true。</li></ul><p>当用 equal() 从开始迭代器开始比较两个序列时，第二个序列用来和第一个序列比较的元素个数由第一个序列的长度决定。就算第二个序列比第一个序列的元素多，equal() 仍然会返回 true。如果为两个序列提供了开始和结束迭代器，为了使结果为 true，序列必须是相同的长度。</p><p>尽管可以用 equal() 来比较两个同种类型的容器的全部内容，但最好还是使用容器的成员函数 operator&#x3D;&#x3D;() 来做这些事。示例中的第 6 条输出语句可以这样写：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::boolalpha &lt;&lt; (words1 == words2) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h2 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch()"></a>mismatch()</h2><p>equal() 算法可以告诉我们两个序列是否匹配。mismatch() 算法也可以告诉我们两个序列是否匹配，而且如果不匹配，它还能告诉我们不匹配的位置。</p><p>mismatch() 返回的 pair 对象包含两个迭代器。它的 first 成员是一个来自前两个参数所指定序列的迭代器，second 是来自于第二个序列的迭代器。当序列不匹配时，pair 包含的迭代器指向第一对不匹配的元素；因此这个 pair 对象为 pair&lt;iter1+n，iter2 + n&gt;，这两个序列中索引为 n 的元素是第一个不匹配的元素。</p><p>当序列匹配时，pair 的成员取决于使用的 mismatch() 的版本和具体情况。iter1 和 end_iter1 表示定义第一个序列的迭代器，iter2 和 end_iter2 表示第二个序列的开始和结束迭代器。返回的匹配序列的 pair 的内容如下：</p><p>对于 mismatch(iter1，end_iter1，iter2):</p><ul><li>返回 pair&lt;end_iter1，(iter2 + (end_ter1 - iter1))&gt;，pair 的成员 second 等于 iter2 加上第一个序列的长度。如果第二个序列比第一个序列短，结果是未定义的。</li></ul><p>对于 mismatch(iterl, end_iter1, iter2, end_iter2)：</p><ul><li>当第一个序列比第二个序列长时，返回 pair&lt;end_iter1, (iter2 + (end_iter1 - iter1))&gt;，所以成员 second 为 iter2 加上第一个序列的长度。</li><li>当第二个序列比第一个序列长时，返回 pair&lt;(iter1 + (end_iter2 - iter2)),end_iter2&gt;， 所以成员 first 等于 iter1 加上第二个序列的长度。</li><li>当序列的长度相等时，返回 pair&lt;end_iter1, end_iter2&gt;。</li></ul><p>不管是否添加一个用于比较的函数对象作为参数，上面的情况都同样适用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Using the mismatch() algorithm</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                                      <span class="comment">// For standard streams</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>                                        <span class="comment">// For vector container</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                                     <span class="comment">// For equal() algorithm</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>                                        <span class="comment">// For string class</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>                                      <span class="comment">// For stream iterators</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> word_iter = std::vector&lt;string&gt;::iterator;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;string&gt; words1 &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>&#125;;</span><br><span class="line">    std::vector&lt;string&gt; words2 &#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;eleven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter1 = std::<span class="built_in">begin</span>(words1);</span><br><span class="line">    <span class="keyword">auto</span> end_iter1 = std::<span class="built_in">end</span>(words1);</span><br><span class="line">    <span class="keyword">auto</span> iter2 = std::<span class="built_in">begin</span>(words2);</span><br><span class="line">    <span class="keyword">auto</span> end_iter2 = std::<span class="built_in">end</span>(words2);</span><br><span class="line">    <span class="comment">// Lambda expression to output mismatch() result</span></span><br><span class="line">    <span class="keyword">auto</span> print_match = [](<span class="type">const</span> std::pair&lt;word_iter, word_iter&gt;&amp; pr, <span class="type">const</span> word_iter&amp; end_iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pr.first != end_iter)</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\nFirst pair of words that differ are &quot;</span>&lt;&lt; *pr.first &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; *pr.second &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\nRanges are identical.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Container - words1:  &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(iter1, end_iter1, std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nContainer - words2:  &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(iter2, end_iter2, std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare from words1[1] to end with words2:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter1 + <span class="number">1</span>, end_iter1, iter2), end_iter1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare from words2[0] to second-to-last with words1:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter2, end_iter2 - <span class="number">1</span>, iter1), end_iter2 - <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare from words1[1] to words1[5] with words2:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter1 + <span class="number">1</span>, iter1 + <span class="number">6</span>, iter2), iter1 + <span class="number">6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare first 6 from words1 with first 6 in words2:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter1, iter1 + <span class="number">6</span>, iter2, iter2 + <span class="number">6</span>), iter1 + <span class="number">6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare all words1 with words2:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter1, end_iter1, iter2), end_iter1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare all of words2 with all of words1:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter2, end_iter2, iter1, end_iter1), end_iter2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCompare from words1[1] to end with words2[0] to second-to-last:&quot;</span>;</span><br><span class="line">    <span class="built_in">print_match</span>(std::<span class="built_in">mismatch</span>(iter1 + <span class="number">1</span>, end_iter1, iter2, end_iter2 - <span class="number">1</span>), end_iter1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 words2 中的内容和前面示例中的有些不同。每一次应用 mismatch() 的结果都是由定义为 print_match 的 lambda 表达式生成的。它的参数是一个 pair 对象和一个 vector<string> 容器的迭代器。使用 using 指令生成 word_iter 别名可以使 lambda 表达式的定义更简单。</string></p><p>在 main() 的代码中使用了不同版本的 mismatch()，它们都没有包含比较函数对象的参数。如果第二个序列只用开始迭代器指定，为了和第一个序列匹配，它只需要有和第一个序列相等长度的元素，但也可以更长。如果第二个序列是完全指定的，会由最短的序列来确定比较多少个元素。</p><hr><h2 id="lexicographical-compare-直接看示例"><a href="#lexicographical-compare-直接看示例" class="headerlink" title="lexicographical_compare()直接看示例"></a>lexicographical_compare()直接看示例</h2><p>两个字符串的字母排序是通过从第一个字符开始比较对应字符得到的。第一对不同的对应字符决定了哪个字符串排在首位。字符串的顺序就是不同字符的顺序。如果字符串的长度相同，而且所有的字符都相等，那么这些字符串就相等。如果字符串的长度不同，短字符串的字符序列和长字符串的初始序列是相同的，那么短字符串小于长字符串。因此 “age” 在“beauty” 之前，“a lull” 在 “a storm” 之前。显然，“the chicken” 而不是 “the egg” 会排在首位。</p><p>对于任何类型的对象序列来说，字典序都是字母排序思想的泛化。从两个序列的第一个元素开始依次比较对应的元素，前两个对象的不同会决定序列的顺序。显然，序列中的对象必须是可比较的。</p><p>lexicographical_compare()算法可以比较由开始和结束迭代器定义的两个序列。它的前两个参数定义了第一个序列，第 3 和第 4 个参数分别是第二个序列的开始和结束迭代器。默认用 &lt; 运算符来比较元素，但在需要时，也可以提供一个实现小于比较的函数对象作为可选的第 5 个参数。如果第一个序列的字典序小于第二个，这个算法会返回 true，否则返回 false。所以，返回 false 表明第一个序列大于或等于第二个序列。</p><p>序列是逐个元素比较的。第一对不同的对应元素决定了序列的顺序。如果序列的长度不同，而且短序列和长序列的初始元素序列匹配，那么短序列小于长序列。长度相同而且对应元素都相等的两个序列是相等的。空序列总是小于非空序列。下面是一个使用 lexicographical_compare() 的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; phrase1 &#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;tigers&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;wrath&quot;</span>&#125;;</span><br><span class="line">std::vector&lt;string&gt; phrase2 &#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;horses&quot;</span>, <span class="string">&quot;of&quot;</span>, <span class="string">&quot;instruction&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> less = std::<span class="built_in">lexicographical_compare</span> (std::<span class="built_in">begin</span> (phrase1), std: :<span class="built_in">end</span> (phrase1),</span><br><span class="line">std::<span class="built_in">begin</span>(phrase2), std::<span class="built_in">end</span>(phrase2)); std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(phrase1), std::<span class="built_in">end</span>(phrase1), std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; (less ? <span class="string">&quot;are&quot;</span>:<span class="string">&quot;are not&quot;</span>) &lt;&lt; <span class="string">&quot; less than &quot;</span>;</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(phrase2), std::<span class="built_in">end</span>(phrase2), std::ostream_iterator &lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><hr><h2 id="next-permutation全排列"><a href="#next-permutation全排列" class="headerlink" title="next_permutation全排列"></a>next_permutation全排列</h2><p>排列就是一次对对象序列或值序列的重新排列。例如，“ABC”中字符可能的排列是：</p><p>“ABC”, “ACB”, “BAC”, “BCA”, “CAB”, “CBA”</p><p>三个不同的字符有 6 种排列，这个数字是从 3<em>2</em>1 得到的。一般来说，n 个不同的字 符有 n! 种排列，n! 是 nx(n_1)x(n-2)…x2x1。很容易明白为什么要这样算。有 n 个对象 时，在序列的第一个位置就有 n 种可能的选择。对于第一个对象的每一种选择，序列的第 二个位置还剩下 n-1 种选择，因此前两个有 nx((n-1) 种可能选择。在选择了前两个之后， 第三个位置还剩下 n-2 种选择，因此前三个有 nx(n-1)x(n-2) 种可能选择，以此类推。序列的末尾是 Hobson 选择，因为只剩下 1 种选择。</p><p>对于包含相同元素的序列来说，只要一个序列中的元素顺序不同，就是一种排列。next_permutation() 会生成一个序列的重排列，它是所有可能的字典序中的下一个排列，默认使用 &lt; 运算符来做这些事情。它的参数为定义序列的迭代器和一个返回布尔值的函数，这个函数在下一个排列大于上一个排列时返回 true，如果上一个排列是序列中最大的，它返回 false，所以会生成字典序最小的排列。</p><p>下面展示了如何生成一个包含 4 个整数的 vector 的排列：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; range &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::<span class="built_in">copy</span> (std::<span class="built_in">begin</span>(range), std::<span class="built_in">end</span>(range), std::ostream_iterator&lt;<span class="type">int</span>&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(std::<span class="built_in">begin</span>(range), std::<span class="built_in">end</span>(range)));</span><br></pre></td></tr></table></figure><p>当 next_permutation() 返回 false 时，循环结束，表明到达最小排列。这样恰好可以生成 序列的全部排列，这只是因为序列的初始排列为 1、2、3、4，这是排列集合中的第一个排列。有一种方法可以得到序列的全排列，就是使用 next_permutation() 得到的最小排列：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(std::<span class="built_in">begin</span>(words)， std::<span class="built_in">end</span>(words)));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(words),std::<span class="built_in">end</span>(words), std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words)));</span><br></pre></td></tr></table></figure><p>words 中的初始序列不是最小的排列序列，循环会继续进行，直到 words 包含最小排列。do-wliile 循环会输出全部的排列。如果想执行这段代码，需要记住它会生成 8! 种排列，从而输出 40320 行，因此首先可能会减少 words 中元素的个数。</p><p>当排列中的每个元素都小于或等于它后面的元素时，它就是元素序列的最小排列，所以可以用 min_element() 来返回一个指向序列中最小元素的迭代器，然后用 iter_swap() 算法交换两个迭代器指向的元素，从而生成最小的排列，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,</span><br><span class="line"><span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = std::<span class="built_in">begin</span>(words); iter != std::<span class="built_in">end</span>(words)<span class="number">-1</span> ;++iter)</span><br><span class="line">    std::<span class="built_in">iter_swap</span>(iter, std::<span class="built_in">min_element</span>(iter, std::<span class="built_in">end</span>(words)));</span><br></pre></td></tr></table></figure><hr><h2 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h2><p>next_permutation() 是按照字典升序的方式生成的排列。当我们想以降序的方式生成排列时，可以使用 prev_permutation()。</p><p>prev_permutation 和 next_permutation() 一样有两个版本，默认使用 &lt; 来比较元素。因为排列是以降序的方式生成的，所以算法大多数时候会返回 true。当生成最大排列时，返回 false。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data &#123;<span class="number">44.5</span>, <span class="number">22.0</span>, <span class="number">15.6</span>, <span class="number">1.5</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), std::ostream_iterator&lt;<span class="type">double</span>&gt; &#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">while</span>(std::<span class="built_in">prev_permutation</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data)));</span><br></pre></td></tr></table></figure><hr><h2 id="is-permutation有用"><a href="#is-permutation有用" class="headerlink" title="is_permutation有用"></a>is_permutation有用</h2><p>is_permutation() 算法可以用来检查一个序列是不是另一个序列的排列，如果是，会返回 true。下面是在这个算法中使用 lambda 表达式的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data1&#123;<span class="number">44.5</span>, <span class="number">22.0</span>, <span class="number">15.6</span>, <span class="number">1.5</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; data2&#123;<span class="number">22.5</span>, <span class="number">44.5</span>, <span class="number">1.5</span>, <span class="number">15.6</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt; data3&#123;<span class="number">1.5</span>, <span class="number">44.5</span>, <span class="number">15.6</span>, <span class="number">22.0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> test = [] (<span class="type">const</span> <span class="keyword">auto</span>&amp; d1, <span class="type">const</span> <span class="keyword">auto</span>&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(d1), std::<span class="built_in">end</span>(d1), std::ostream_iterator&lt;<span class="type">double</span>&gt; &#123;std::cout,<span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">is_permutation</span> (std::<span class="built_in">begin</span> (d1), std::<span class="built_in">end</span>(d1), std::begin &#123;d2), std::<span class="built_in">end</span>(d2))?<span class="string">&quot;is&quot;</span>:<span class="string">&quot;is not&quot;</span>)&gt;&gt;<span class="string">&quot; a permutation of &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(d2), std::<span class="built_in">end</span>(d2), std::ostream_iterator&lt;<span class="type">double</span>&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">test</span>(data1, data2);</span><br><span class="line"><span class="built_in">test</span>(data1, data3);</span><br><span class="line"><span class="built_in">test</span>(data3, data2);</span><br></pre></td></tr></table></figure><p>lambda 表达式 test 的类型参数是用 auto 指定的，编译器会推断出它的实际类型为 const std::vector<double>&amp;。使用 auto 来指定类型参数的 lambda 表达式叫作泛型 lambda。lambda 表达式 test 用 is_permutation() 来评估参数是否是另一种排列。</double></p><hr><h1 id="复制函数"><a href="#复制函数" class="headerlink" title="复制函数"></a>复制函数</h1><h2 id="copy-n没啥用"><a href="#copy-n没啥用" class="headerlink" title="copy_n没啥用"></a>copy_n没啥用</h2><p>copy_n() 算法可以从源容器复制指定个数的元素到目的容器中。第一个参数是指向第一个源元素的输入迭代器，第二个参数是需要复制的元素的个数，第三个参数是指向目的容器的第一个位置的迭代器。这个算法会返回一个指向最后一个被复制元素的后一个位置的迭代器，或者只是第三个参数——输出迭代器——如果第二个参数为 0。下面是一个使用它的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; names &#123;<span class="string">&quot;A1&quot;</span>,<span class="string">&quot;Beth&quot;</span>, <span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;Dan&quot;</span>, <span class="string">&quot;Eve&quot;</span>,<span class="string">&quot;Fred&quot;</span>,<span class="string">&quot;George&quot;</span> ,<span class="string">&quot;Harry&quot;</span>, <span class="string">&quot;Iain&quot;</span>, <span class="string">&quot;Joe&quot;</span>&#125;;</span><br><span class="line">std::unordered_set&lt;string&gt; more_names &#123;<span class="string">&quot;Janet&quot;</span>, <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line">std::<span class="built_in">copy_n</span>(std:<span class="built_in">rbegin</span>(names)+<span class="number">1</span>, <span class="number">3</span>, std::<span class="built_in">inserter</span>(more_names, std::<span class="built_in">begin</span>(more_names)));</span><br></pre></td></tr></table></figure><hr><h2 id="copy-if有用"><a href="#copy-if有用" class="headerlink" title="copy_if有用"></a>copy_if有用</h2><p>copy_if() 算法可以从源序列复制使谓词返回 true 的元素，所以可以把它看作一个过滤器。前两个参数定义源序列的输入迭代器，第三个参数是指向目的序列的第一个位置的输出迭代器，第 4 个参数是一个谓词。会返回一个输出迭代器，它指向最后一个被复制元素的下一个位置。下面是一个使用 copy_if() 的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; names &#123;<span class="string">&quot;A1&quot;</span>, <span class="string">&quot;Beth&quot;</span>, <span class="string">&quot;Carol&quot;</span>, <span class="string">&quot;Dan&quot;</span>, <span class="string">&quot;Eve&quot;</span>,<span class="string">&quot;Fred&quot;</span>, <span class="string">&quot;George&quot;</span>, <span class="string">&quot;Harry&quot;</span>, <span class="string">&quot;Iain&quot;</span>, <span class="string">&quot;Joe&quot;</span>&#125;;</span><br><span class="line">std::unordered_set&lt;string&gt; more_names &#123;<span class="string">&quot;Jean&quot;</span>, <span class="string">&quot;John&quot;</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> max_length&#123;<span class="number">4</span>&#125;;</span><br><span class="line">std::<span class="built_in">copy_if</span>(std::<span class="built_in">begin</span>(names), std::<span class="built_in">end</span>(names), std::<span class="built_in">inserter</span>(more_names, std::<span class="built_in">begin</span>(more_names)), [max_length](<span class="type">const</span> string&amp; s) &#123; <span class="keyword">return</span> s.<span class="built_in">length</span>() &lt;= max_length;&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h2><p>不要被 copy_backward() 算法的名称所误导，它不会逆转元素的顺序。它只会像 copy() 那样复制元素，<strong>但是从最后一个元素开始直到第一个元素。</strong></p><p>copy_backward() 会复制前两个迭代器参数指定的序列。第三个参数是目的序列的结束迭代器，通过将源序列中的最后一个元素复制到目的序列的结束迭代器之前，源序列会被复制到目的序列中，如图 1 所示。copy_backward() 的 3 个参数都必须是可以自增或自减的双向迭代器，这意味着这个算法只能应用到序列容器的序列上。</p><p><img src="https://c.biancheng.net/uploads/allimg/180919/2-1P9191A019220.jpg" alt="img"></p><p> 说明了源序列 from 的最后一个元素是如何先被复制到目的序列 to 的最后一个元素的。从源序列的反向，将每一个元素依次复制到目的序列的前一个元素之前的位置。在进行这个操作之前，目的序列中的元素必须存在，因此目的序列至少要有和源序列一样多的元素，但也可以有更多。copy_backward() 算法会返回一个指向最后一个被复制元素的迭代器，在目的序列的新位置，它是一个开始迭代器。</p><p>我们可能会好奇，相对于普通的从第一个元素开始复制的 copy() 算法，copy_backward() 提供了哪些优势。</p><p>一个回答是，在序列重叠时，可以用 copy() 将元素复制到重叠的目的序列剩下的位置——也就是目的序列第一个元素之前的位置。如果想尝试用 copy() 算法将元素复制到同一个序列的右边，这个操作不会成功，因为被复制的元素在复制之前会被重写。如果想将它们复制到右边，可以使用 copy_backward()，只要目的序列的结束迭代器在源序列的结束迭代器的右边。图 2 说明了在将元素复制到重叠的序列的右边时，这两个算法的不同。</p><p><img src="https://c.biancheng.net/uploads/allimg/180919/2-1P9191A13J35.jpg" alt="img"></p><p>展示了在序列右边的前三个位置运用 copy() 和 copy_backward() 算法的结果。在想将元素复制到右边时，copy() 算法显然不能如我们所愿，因为一些元素在复制之前会被重写。在这种情况下，copy_backward() 可以做到我们想做的事。相反在需要将元素复制到 序列的左边时，copy() 可以做到，但 copy_backward() 做不到。</p><p>下面是一个说明 copy_backward() 用法的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;string&gt; song&#123; <span class="string">&quot;jingle&quot;</span>, <span class="string">&quot;bells&quot;</span>，<span class="string">&quot;jingle&quot;</span>, <span class="string">&quot;all&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;way&quot;</span>&#125;;</span><br><span class="line">song.<span class="built_in">resize</span>(song.<span class="built_in">size</span>()+<span class="number">2</span>); <span class="comment">// Add 2 elements</span></span><br><span class="line">std::<span class="built_in">copy_backward</span>(std::<span class="built_in">begin</span>(song), std::<span class="built_in">begin</span>(song)+<span class="number">6</span>, std::<span class="built_in">end</span>(song));</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(song), std::<span class="built_in">end</span>(song), std::ostream iterator &lt;string&gt; &#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h2><p>reverse_copy() 算法可以将源序列复制到目的序列中，目的序列中的元素是逆序的。定义源序列的前两个迭代器参数必须是双向迭代器。目的序列由第三个参数指定，它是目的序列的开始迭代器，也是一个输出迭代器。如果序列是重叠的，函数的行为是未定义的。这个算法会返回一个输出迭代器，它指向目的序列最后一个元素的下一个位置。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Testing for palindromes using reverse_copy()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                                      <span class="comment">// For standard streams</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>                                      <span class="comment">// For stream iterators and begin() and end()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>                                     <span class="comment">// For reverse_copy() and copy_if()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>                                        <span class="comment">// For toupper() and isalpha()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string sentence;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter a sentence or Ctrl+Z to end: &quot;</span>;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin, sentence);</span><br><span class="line">        <span class="keyword">if</span>(std::cin.<span class="built_in">eof</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Copy as long as the characters are alphabetic &amp; convert to upper case</span></span><br><span class="line">        string only_letters;</span><br><span class="line">        std::<span class="built_in">copy_if</span>(std::<span class="built_in">begin</span>(sentence), std::<span class="built_in">end</span>(sentence), std::<span class="built_in">back_inserter</span>(only_letters),[](<span class="type">char</span> ch) &#123; <span class="keyword">return</span> std::<span class="built_in">isalpha</span>(ch); &#125;);</span><br><span class="line">        std::for_each(std::<span class="built_in">begin</span>(only_letters), std::<span class="built_in">end</span>(only_letters), [](<span class="type">char</span>&amp; ch) &#123; ch = <span class="built_in">toupper</span>(ch); &#125;);</span><br><span class="line">        <span class="comment">// Make a reversed copy</span></span><br><span class="line">        string reversed;</span><br><span class="line">        std::<span class="built_in">reverse_copy</span>(std::<span class="built_in">begin</span>(only_letters), std::<span class="built_in">end</span>(only_letters), std::<span class="built_in">back_inserter</span>(reversed));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span> &lt;&lt; sentence &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span>&lt;&lt; (only_letters == reversed ? <span class="string">&quot; is&quot;</span> : <span class="string">&quot; is not&quot;</span>) &lt;&lt; <span class="string">&quot; a palindrome.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出结果为：</p><p>Enter a sentence or Ctrl+Z to end: Lid off a daffodil.<br>“Lid off a daffodil.” is a palindrome.<br>Enter a sentence or Ctrl+Z to end: Engaga le jeu que je le gagne.<br>“Engaga le jeu que je le gagne.” is not a palindrome.<br>Enter a sentence or Ctrl+Z to end: ^Z</p><p>reverse() 算法可以在原地逆序它的两个双向迭代器参数所指定序列的元素。可以如下 所示用它来代替上述程序中的 reverse_copy():</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string reversed &#123;only_letters&#125;;std::reverse(std::begin(reversed), std::end(reversed));</span><br></pre></td></tr></table></figure><p>这两条语句会替换上述程序中 reversed 的定义和 reverse_copy() 调用。它们生成一个 only_letters 的副本 reversed，然后调用 reverse() 原地逆序 reversed 中的字符序列。</p><h2 id="unique-去重"><a href="#unique-去重" class="headerlink" title="unique 去重"></a>unique 去重</h2><p>unique() 算法可以在序列中原地移除重复的元素，这就要求被处理的序列必须是正向迭代器所指定的。在移除重复元素后，它会返回一个正向迭代器作为新序列的结束迭代器。可以提供一个函数对象作为可选的第三个参数，这个参数会定义一个用来代替 <code>==</code> 比较元素的方法。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> end_iter = std::<span class="built_in">unique</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words));</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(words), end_iter, std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这样会通过覆盖来消除 words 中的连续元素。输出为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">one two three two</span><br></pre></td></tr></table></figure><p>当然，没有元素会从输入序列中移除;算法并没有方法去移除元素，因为它并不知道它们的具体上下文。整个序列仍然存在。但是，无法保证新末尾之后的元素的状态；如果在上面的代码中用 std::end(words) 代替 end_iter 来输出结果，得到的输出如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">one two three two two two</span><br></pre></td></tr></table></figure><p>相同个数的元素仍然存在，但新的结束迭代器指向的元素为空字符串；最后两个元素还和之前一样。在你的系统上，可能会有不同的结果。因为这个，在执行 unique() 后，最好按如下方式截断序列：</p><h2 id="rotate旋转数组"><a href="#rotate旋转数组" class="headerlink" title="rotate旋转数组"></a>rotate旋转数组</h2><p><img src="https://raw.githubusercontent.com/romafang/picgo/master/data/202403212321288.jpeg" alt="img"></p><p>为了理解如何旋转序列，可以将序列中的元素想象成手镯上的珠子。rotate() 操作会导致一个新元素成为开始迭代器所指向的第一个元素。在旋转之后，最后一个元素会在新的第一个元素之前。</p><p>rotate() 的第一个参数是这个序列的开始迭代器；第二个参数是指向新的第一个元素的迭代器，它必定在序列之内。第三个参数是这个序列的结束迭代器。图 1 中的示例说明在容器 ns 上的旋转操作使值为 4 的元素成为新的第一个元素，最后一个元素的值为 3。元素的圆形序列会被维持，因此可以有效地旋转元素环，直到新的第一个元素成为序列的开始。这个算法会返回一个迭代器，它指向原始的第一个元素所在的新位置。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">rotate</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">begin</span>(words)+<span class="number">3</span>, std::<span class="built_in">end</span>(words));</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words),std::ostream_iterator&lt;string&gt; &#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;First element before rotation: &quot;</span> &lt;&lt; *iter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这段代码对 words 中的所有元素进行了旋转。执行这段代码会生成如下内容：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">four five six seven eight one two three</span><br><span class="line">First element before rotation: one</span><br></pre></td></tr></table></figure><p>输出说明 “four” 成为新的第一个元素，而且 rotate() 返回的迭代器指向之前的第一个元素”one”。</p><h2 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h2><p>rotate_copy() 算法会在新序列中生成一个序列的旋转副本，并保持原序列不变。rotate_copy() 的前 3 个参数和 copy() 是相同的；第 4 个参数是一个输出迭代器，它指向目的序列的第一个元素。这个算法会返回一个目的序列的输出迭代器，它指向最后一个被复制元素的下一个位置。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>，<span class="string">&quot;ten&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> start = std::<span class="built_in">find</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words), <span class="string">&quot;two&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> end_iter = std::<span class="built_in">find</span> (std::<span class="built_in">begin</span>(words) , std::<span class="built_in">end</span> (words) ,<span class="string">&quot;eight&quot;</span>);</span><br><span class="line">std::vector&lt;string&gt; words_copy;</span><br><span class="line">std::<span class="built_in">rotate_copy</span>(start, std::<span class="built_in">find</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words),<span class="string">&quot;five&quot;</span>) , end_iter, std::<span class="built_in">back_inserter</span> (words_copy));</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(words_copy), std::<span class="built_in">end</span>(words_copy),std::ostream_iterator&lt;string&gt; &#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="move移动构造函数常用"><a href="#move移动构造函数常用" class="headerlink" title="move移动构造函数常用"></a>move移动构造函数常用</h2><p>move() 算法会将它的前两个输入迭代器参数指定的序列移到第三个参数定义的目的序列的开始位置，第三个参数必须是输出迭代器。这个算法返回的迭代器指向最后一个被移动到目的序列的元素的下一个位置。</p><p>这是一个移动操作，因此无法保证在进行这个操作之后，输入序列仍然保持不变；源元素仍然会存在，但它们的值可能不再相同了，因此在移动之后，就不应该再使用它们。如果源序列可以被替换或破坏，就可以选择使用 move() 算法。如果不想扰乱源序列，可以使用 copy() 算法。下面是一个展示如何使用它的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; srce &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dest &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">std::<span class="built_in">move</span>(std::<span class="built_in">begin</span>(srce), std::<span class="built_in">end</span>(srce), std::<span class="built_in">back_inserter</span>(dest));</span><br></pre></td></tr></table></figure><hr><h2 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h2><p>可以用 swap_ranges() 算法来交换两个序列。这个算法需要 3 个正向迭代器作为参数。前两个参数分别是第一个序列的开始和结束迭代器，第三个参数是第二个序列的开始迭代器。显然，这两个序列的长度必须相同。这个算法会返回一个迭代器，它指向第二个序列的最后一个被交换元素的下一个位置。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Name = std::pair&lt;string, string&gt;; <span class="comment">// First and second name</span></span><br><span class="line">std::vector&lt;Name&gt; people &#123;Name&#123;<span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Bedo&quot;</span> &#125;, Name &#123; <span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Ounce&quot;</span>&#125;, Name&#123;<span class="string">&quot;Jo&quot;</span>，<span class="string">&quot;King&quot;</span>&#125;&#125;;</span><br><span class="line">std::list&lt;Name&gt; folks &#123;Name&#123;<span class="string">&quot;Stan&quot;</span>, <span class="string">&quot;Down&quot;</span>&#125;, Name&#123;<span class="string">&quot;Dan&quot;</span>,<span class="string">&quot;Druff&quot;</span>&#125;,Name &#123;<span class="string">&quot;Bea&quot;</span>, <span class="string">&quot;Gone&quot;</span>&#125;&#125;;</span><br><span class="line">std::<span class="built_in">swap_ranges</span>(std::<span class="built_in">begin</span>(people), std::<span class="built_in">begin</span>(people) + <span class="number">2</span>, ++std::<span class="built_in">begin</span>(folks));</span><br><span class="line">std::for_each(std::<span class="built_in">begin</span>(people), std::<span class="built_in">end</span>(people),[](<span class="type">const</span> Name&amp; name) &#123;std: :cout &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span> &lt;&lt; name.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name.second &lt;&lt; <span class="string">&quot;\&quot; &quot;</span>;&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl; <span class="comment">// &quot;Dan Druff&quot; &quot;Bea Gone&quot; &quot;Jo King&quot;</span></span><br><span class="line">std::for_each (std::<span class="built_in">begin</span> (folks) , std::<span class="built_in">end</span> (folks) ,[] (<span class="type">const</span> Name&amp; name)&#123;std::cout &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span> &lt;&lt; name.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name.second &lt;&lt; <span class="string">&quot;\&quot; &quot;</span>; &#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;<span class="comment">// &quot;Stan Down&quot; &quot;Al Bedo&quot; &quot;Ann Ounce&quot;</span></span><br></pre></td></tr></table></figure><p>这里使用 vector 和 list 容器来保存 pair&lt;string,string&gt; 类型的元素，pair&lt;string,string&gt; 用来表示名称。swap_ranges() 算法被用来交换 people 的前两个元素和 folks 的后两个元素。这里并没有为了将 pair 对象写入流而重载 operator&lt;&lt;() 函数，因此 copy() 无法用输出流迭代器来列出容器的内容。为了生成输出，选择使用 for_each() 算法将 lambda 表达式运用到容器的每个元素上。这个 lambda 表达式只会将传给它的 Name 元素的成员变量写入标准输出流。注释展示了执行这段代码后输出的结果</p><hr><h1 id="移除算法"><a href="#移除算法" class="headerlink" title="移除算法"></a>移除算法</h1><p>有 4 种移除算法：</p><ul><li>**remove() **可以从它的前两个正向迭代器参数指定的序列中移除和第三个参数相等的对象。基本上每个元素都是通过用它后面的元素覆盖它来实现移除的。它会返回一个指向新的最后一个元素之后的位置的迭代器。</li><li>**remove_copy() **可以将前两个正向迭代器参数指定的序列中的元素复制到第三个参数指定的目的序列中，并忽略和第 4 个参数相等的元素。它返回一个指向最后一个被复制到目的序列的元素的后一个位置的迭代器。序列不能是重叠的。</li><li><strong>remove_if()</strong> 可以从前两个正向迭代器指定的序列中移除能够使作为第三个参数的谓词返回 true 的元素。</li><li><strong>remove_copy_if()</strong> 可以将前两个正向迭代器参数指定的序列中，能够使作为第 4 个参数的谓词返回 true 的元素，复制到第三个参数指定的目的序列中。它返回一个指向最后一个被复制到目的序列的元素的后一个位置的迭代器。序列不能是重叠的。</li></ul><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">double</span>&gt; samples &#123;<span class="number">1.5</span>, <span class="number">2.6</span>, <span class="number">0.0</span>, <span class="number">3.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.0</span>, <span class="number">6.7</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">samples.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(std::<span class="built_in">begin</span>(samples), std::<span class="built_in">end</span>(samples), <span class="number">0.0</span>), std::<span class="built_in">end</span>(samples));</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(samples),std::<span class="built_in">end</span>(samples), std::ostream iterator &lt;<span class="type">double</span>&gt; &#123;std::cout,<span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 1.5 2.6 3.1 4.1 6.7</span></span><br></pre></td></tr></table></figure><h2 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy()"></a>remove_copy()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">double</span>&gt; samples &#123;<span class="number">1.5</span>, <span class="number">2.6</span>, <span class="number">0.0</span>, <span class="number">3.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.0</span>, <span class="number">6.7</span>, <span class="number">0.0</span>&#125;; std::vector&lt;<span class="type">double</span>&gt; edited_samples;</span><br><span class="line">std::<span class="built_in">remove_copy</span>(std::<span class="built_in">begin</span>(samples), std::<span class="built_in">end</span>(samples), std::<span class="built_in">back_inserter</span>(edited_samples), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><h2 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if()"></a>remove_if()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Name = std::pair&lt;string, string&gt;； <span class="comment">// First and second name</span></span><br><span class="line">std::set&lt;Name&gt; blacklist &#123;Name &#123;<span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Bedo&quot;</span>&#125;, Name &#123;<span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Ounce&quot;</span>&#125;, Name &#123;<span class="string">&quot;Jo&quot;</span>,<span class="string">&quot;King&quot;</span>&#125;&#125;;</span><br><span class="line">std::deque&lt;Name&gt; candidates &#123;Name&#123;<span class="string">&quot;Stan&quot;</span>, <span class="string">&quot;Down&quot;</span>&#125;, Name &#123;<span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Bedo&quot;</span>&#125;, Name &#123;<span class="string">&quot;Dan&quot;</span>, <span class="string">&quot;Druff&quot;</span>&#125;,Name &#123;<span class="string">&quot;Di&quot;</span>, <span class="string">&quot;Gress&quot;</span>&#125;, Name &#123;<span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Ounce&quot;</span>&#125;, Name &#123;<span class="string">&quot;Bea&quot;</span>, <span class="string">&quot;Gone&quot;</span>&#125;&#125;; candidates.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(std::<span class="built_in">begin</span>(candidates), std::<span class="built_in">end</span>(candidates),[&amp;blacklist](<span class="type">const</span> Name&amp; name) &#123; <span class="keyword">return</span> blacklist.<span class="built_in">count</span>(name); &#125;), std::<span class="built_in">end</span>(candidates)); std::for_each(std::<span class="built_in">begin</span>(candidates), std::<span class="built_in">end</span>(candidates), [] (<span class="type">const</span> Name&amp; name)&#123;std::cout &lt;&lt; <span class="string">&#x27;&quot;&#x27;</span> &lt;&lt; name.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name.second &lt;&lt; <span class="string">&quot;\&quot; &quot;</span>;&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;  <span class="comment">// &quot;Stan Down&quot; &quot;Dan Druff&quot; &quot;Di Gress&quot; &quot;Bea Gone&quot;</span></span><br></pre></td></tr></table></figure><h2 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if()"></a>remove_copy_if()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::set&lt;Name&gt; blacklist &#123;Name &#123;<span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Bedo&quot;</span>&#125;, Name &#123;<span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Ounce&quot;</span>&#125;, Name &#123;<span class="string">&quot;Jo&quot;</span>, ,<span class="string">&quot;King&quot;</span> &#125; &#125;;</span><br><span class="line">std::deque&lt;Name&gt; candidates &#123;Name &#123;<span class="string">&quot;Stan&quot;</span>, <span class="string">&quot;Down&quot;</span>&#125;, Name &#123; <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Bedo&quot;</span>&#125;,Name &#123;<span class="string">&quot;Dan&quot;</span>, <span class="string">&quot;Druff&quot;</span>&#125;, Name &#123;<span class="string">&quot;Di&quot;</span>, <span class="string">&quot;Gress&quot;</span>&#125;, Name &#123;<span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Ounce&quot;</span>&#125;,Name &#123;<span class="string">&quot;Bea&quot;</span>, <span class="string">&quot;Gone&quot;</span>&#125;&#125;;</span><br><span class="line">std::deque&lt;Name&gt; validated;</span><br><span class="line">std::<span class="built_in">remove_copy_if</span>(std::<span class="built_in">begin</span>(candidates) , std::<span class="built_in">end</span>(candidates), std::back <span class="built_in">inserter</span>(validated), [&amp;blacklist] (<span class="type">const</span> Name&amp; name) &#123; <span class="keyword">return</span> blacklist.<span class="built_in">count</span>(name); &#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="填充函数"><a href="#填充函数" class="headerlink" title="填充函数"></a>填充函数</h1><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; data &#123;<span class="number">12</span>&#125;; <span class="comment">// Container has 12 elements</span></span><br><span class="line">std::<span class="built_in">fill</span> (std::<span class="built_in">begin</span> (data), std::<span class="built_in">end</span> (data), <span class="string">&quot;none&quot;</span>); <span class="comment">// Set all elements to &quot;none&quot;</span></span><br></pre></td></tr></table></figure><p>fill 的前两个参数是定义序列的正向迭代器，第三个参数是赋给每个元素的值。当然这个序列并不一定要代表容器的全部元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">values</span> <span class="params">(<span class="number">13</span>)</span></span>; <span class="comment">//Container has 13 elements</span></span><br><span class="line"><span class="type">int</span> n&#123;<span class="number">2</span>&#125;;   <span class="comment">// Initial element value</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> step &#123;<span class="number">7</span>&#125;; <span class="comment">// Element value increment</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> count&#123;<span class="number">3</span>&#125;;  <span class="comment">// Number of elements with given value</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">begin</span>(values);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> t0_end = std::<span class="built_in">distance</span>(iter, std::<span class="built_in">end</span>(values)); <span class="comment">// Number of elements remaining</span></span><br><span class="line">    <span class="keyword">if</span> (to_end &lt; count) <span class="comment">//In case no. of elements not a multiple of count</span></span><br><span class="line">    &#123;</span><br><span class="line">        std:: <span class="built_in">fill</span> (iter, iter + to_end, n); <span class="comment">// Just fill remaining elements and end the loop</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std:: <span class="built_in">fill</span> (iter, std:: <span class="built_in">end</span> (values), n); <span class="comment">// Fill next count elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    iter = std::<span class="built_in">next</span>(iter, count); <span class="comment">// Increment iter</span></span><br><span class="line">    n += step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面创建了具有 13 个元素的 value 容器。在这种情况下，必须用圆括号将值传给构造函数；使用花括号会生成一个有单个元素的容器，单个元素的值为 13。在循环中，fill() 算法会将 values 赋值给 count 个元素。以 iter 作为容器的开始迭代器，如果还有足够的元素剩下，每次遍历中，它会被加上 count，因此它会指向下个序列的第一个元素。执行这段代码会将 values 中的元素设置为：</p><p>2 2 2 9 9 9 16 16 16 23 23 23 30</p><p>fill_n() 的参数分别是指向被修改序列的第一个元素的正向迭代器、被修改元素的个数以及要被设置的值。distance() 和 next() 函数定义在 iterator 头文件中。前者必须使用输入迭代器，而后者需要使用正向迭代器。</p><hr><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>你已经知道可以用for_each()算法将一个函数对象应用到序列中的每一个元素上。函数对象的参数是for_each()的前两个参数所指定序列中元素的引用，因此它可以直接修改被保存的值。generate()算法和它有些不同，它的前两个参数是指定范围的正向迭代器，第三个参数是用来定义下面这种形式的函数的函数对象：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">fun</span> <span class="params">()</span></span>; <span class="comment">// T is a type that can be assigned to an element in the range</span></span><br></pre></td></tr></table></figure><p>无法在函数内访问序列元素的值。generate() 算法只会保存函数为序列中每个元素所返回的值，而且 genemte() 没有任何返回值。为了使这个算法更有用，可以将生成的不同的值赋给无参数函数中的不同元素。也可以用一个可以捕获一个或多个外部变量的函数对象作为 generate() 的第三个参数。例如</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">chars</span> <span class="params">(<span class="number">30</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;<span class="comment">// 30 space characters</span></span><br><span class="line"><span class="type">char</span> ch &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> incr &#123;&#125;;</span><br><span class="line">std::<span class="built_in">generate</span> (std::<span class="built_in">begin</span> (chars) , std::<span class="built_in">end</span> (chars), [ch, &amp;incr]</span><br><span class="line">&#123;</span><br><span class="line">    incr += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> ch + (incr % <span class="number">26</span>);&#125;)；</span><br><span class="line">std::cout &lt;&lt; chars &lt;&lt; std: :endl;</span><br><span class="line"><span class="comment">// chars is: dgjmpsvybehknqtwzcfiloruxadgjm</span></span><br></pre></td></tr></table></figure><p>变量 chars 被初始化为了个有 30 个空格的字符串。作为 generate() 的第三个参数的 lambda 表达式的返回值会被治存到 chars 的连续字符中。lambda 表达式以值的方式捕获 ch，以引用的方式捕获 incr，因此会在 lambda 的主体中对后者进行修改。lambda 表达式会返回 ch 加上 incr 后得到的字符，增加的值是 26 的模，因此返回的值总是在 ‘a’ 到 ‘z’ 之间，给定的起始值为 ‘a’。这个操作的结果会在注释中展示出来。可以对 lambda 表达式做一些修改， 使它可以用于任何大写或小写字母，但只生成保存在 ch 中的这种类型的字母。</p><p>generate_n() 和 generate() 的工作方式是相似的。不同之处是，它的第一个参数仍然是序列的开始迭代器，第二个参数是由第三个参数设置的元素的个数。为了避免程序崩溃，这个序列必须至少有第二个参数定义的元素个数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">chars</span> <span class="params">(<span class="number">30</span>,<span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">// 30 space characters</span></span><br><span class="line"><span class="type">char</span> ch &#123;<span class="string">&#x27;a&#x27;</span>&#125;/ <span class="type">int</span> incr &#123;&#125;;</span><br><span class="line">std::<span class="built_in">generate_n</span>(std::<span class="built_in">begin</span>(chars), chars.<span class="built_in">size</span>()/<span class="number">2</span>,[ch, &amp;incr]</span><br><span class="line">&#123;</span><br><span class="line">    incr += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> ch + (incr % <span class="number">26</span>);</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure><h2 id="transform-对原序列映射处理"><a href="#transform-对原序列映射处理" class="headerlink" title="transform 对原序列映射处理"></a>transform 对原序列映射处理</h2><p>transform() 可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，&#x3D;&#x3D;它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。&#x3D;&#x3D;</p><p>这个算法有一个版本和 for_each() 相似，可以将一个一元函数应用到元素序列上来改变它们的值，但这里有很大的区别。for_each() 中使用的函数的返回类型必须为 void，而且可以通过这个函数的引用参数来修改输入序列中的值；而 transform() 的二元函数必须返回一个值，并且也能够将应用函数后得到的结果保存到另一个序列中。</p><p>不仅如此，输出序列中的元素类型可以和输入序列中的元素类型不同。对于 for_each()，函数总是会被应用序列的元素上，但对于 transform()，这一点无法保证。</p><p>第二个版本的 transform() 允许将二元函数应用到两个序列相应的元素上，但先来看一下如何将一元函数应用到序列上。在这个算法的这个版本中，它的前两个参数是定义输入序列的输入迭代器，第 3 个参数是目的位置的第一个元素的输出迭代器，第 4 个参数是一个二元函数。这个函数必须接受来自输入序列的一个元素为参数，并且必须返回一个可以保存在输出序列中的值。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; deg_C &#123;<span class="number">21.0</span>, <span class="number">30.5</span>, <span class="number">0.0</span>, <span class="number">3.2</span>, <span class="number">100.0</span>&#125;;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">deg_F</span><span class="params">(deg_C.size())</span></span>;</span><br><span class="line">std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span>(deg_C), std::<span class="built_in">end</span>(deg_C), std:<span class="built_in">rbegin</span>(deg_F),[](<span class="type">double</span> temp)&#123; <span class="keyword">return</span> <span class="number">32.0</span> + <span class="number">9.0</span>*temp/<span class="number">5.0</span>; &#125;);</span><br><span class="line"><span class="comment">//Result 69.8 86.9 32 37.76 212</span></span><br></pre></td></tr></table></figure><p>这个 transform() 算法会将 deg_C 容器中的摄氏温度转换为华氏温度，并将这个结果保存到 deg_F 容器中。为了保存全部结果，生成的 deg_F 需要一定个数的元素。因此第三个参数是 deg_F 的开始迭代器。通过用 back_insert_iterator 作为 transform() 的第三个参数，可以将结果保存到空的容器中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; deg_F; <span class="comment">// Empty container</span></span><br><span class="line">std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span>(deg_C), std::<span class="built_in">end</span>(deg_C),std::<span class="built_in">back_inserter</span>(deg_F),[](<span class="type">double</span> temp)&#123; <span class="keyword">return</span> <span class="number">32.0</span> + <span class="number">9.0</span>* temp/<span class="number">5.0</span>; &#125;);</span><br><span class="line"><span class="comment">// Result 69.8 86.9 32 37.76 212</span></span><br></pre></td></tr></table></figure><p>用 back_insert_iterator 在 deg_F 中生成保存了操作结果的元素；结果是相同的。第三个参数可以是指向输入容器的元素的迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; temps &#123;<span class="number">21.0</span>, <span class="number">30.5</span>, <span class="number">0.0</span>, <span class="number">3.2</span>, <span class="number">100.0</span>&#125;; <span class="comment">// In Centigrade</span></span><br><span class="line">std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span> (temps), std::<span class="built_in">end</span>(temps), std::<span class="built_in">begin</span>(temps),[](<span class="type">double</span> temp)&#123; <span class="keyword">return</span> <span class="number">32.0</span> + <span class="number">9.0</span>* temp / <span class="number">5.0</span>; &#125;);</span><br><span class="line"><span class="comment">// Result 69.8 86.9 32 37.76 212</span></span><br></pre></td></tr></table></figure><p>这里将 temp 容器中的值从摄氏温度转换成了华氏温度。第三个参数是输入序列的开始迭代器，应用第 4 个参数指定的函数的结果会被存回它所运用的元素上。</p><p>&#x3D;&#x3D;下面的代码展示了目的序列和输入序列是不同类型的情况：&#x3D;&#x3D;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; hash_values;</span><br><span class="line">std::<span class="built_in">transform</span> (std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words),std::<span class="built_in">back_inserter</span>(hash_values),std::<span class="built_in">hash</span>&lt;string&gt;()); <span class="comment">// string hashing function</span></span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(hash_values), std::<span class="built_in">end</span>(hash_values),std::ostream_iterator&lt;<span class="type">size_t</span>&gt; &#123;std::cout,<span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>目的序列是由 back_insert_iterator 对象指定的，这里 transform() 算法会返回一个 back_insert_iterator&lt;vector<size_T>&gt; 类型的迭代器，因此不能在 copy() 算法中用它作为输入序列的结束迭代器。为了充分利用 transform() 返回的迭代器，这段代码可以这样写：</size_T></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>&#125;; <span class="function">std::vector&lt;<span class="type">size_t</span>&gt; <span class="title">hash_values</span><span class="params">(words.size())</span></span>;</span><br><span class="line"><span class="keyword">auto</span> end_iter = std::<span class="built_in">transform</span>(std::<span class="built_in">begin</span>(words),std::<span class="built_in">end</span>(words), std::<span class="built_in">begin</span>(hash_values), std::<span class="built_in">hash</span>&lt;string&gt;()); <span class="comment">// string hashing function</span></span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(hash_values) , end_iter, std::ostream iterator&lt;size t&gt;&#123;std::cout,<span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h1 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h1><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h2><p>replace() 算法会用新的值来替换和给定值相匹配的元素。它的前两个参数是被处理序列的正向迭代器，第 3 个参数是被替换的值，第 4 个参数是新的值。下面展示了它的用法:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; data &#123;<span class="number">10</span>, <span class="number">-5</span>, <span class="number">12</span>, <span class="number">-6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">-7</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">std::<span class="built_in">replace</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="number">10</span>, <span class="number">99</span>);</span><br><span class="line"><span class="comment">// Result: 99 -5 12 -6 99 8 -7 99 11</span></span><br></pre></td></tr></table></figure><p>这里，data 容器中和 10 匹配的全部元素都会被 99 替代。</p><h2 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if()"></a>replace_if()</h2><p>replace_if() 会将使谓词返回 true 的元素替换为新的值。它的第 3 个参数是一个谓词，第 4 个参数是新的值。参数的类型一般是元素类型的 const 引用；const 不是强制性的，但谓词不应该改变元素。下面是一个使用 replace_if() 的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string password &#123; <span class="string">&quot;This is a good choice !&quot;</span>&#125;;</span><br><span class="line">std::<span class="built_in">replace_if</span>(std::<span class="built_in">begin</span>(password), std::<span class="built_in">end</span>(password),[](<span class="type">char</span> ch)&#123;<span class="keyword">return</span> std::<span class="built_in">isspace</span>(ch);&#125;, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"><span class="comment">//Result:This_is_a_good_choice!</span></span><br></pre></td></tr></table></figure><p>这个谓词会为任何是空格字符的元素返回 true，因此这里的空格都会被下划线代替。</p><h2 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy()"></a>replace_copy()</h2><p>replace_copy() 算法和 replace() 做的事是一样的，但它的结果会被保存到另一个序列中，而不会改变原始序列。它的前两个参数是输入序列的正向迭代器，第 3 个参数是输入序列的开始迭代器，最后两个参数分别是要被替换的值和替换值。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; words &#123; <span class="string">&quot;one&quot;</span>,<span class="string">&quot;none&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;four&quot;</span>&#125;;</span><br><span class="line">std::vector&lt;string&gt; new_words;</span><br><span class="line">std::<span class="built_in">replace_copy</span> (std::<span class="built_in">begin</span> (words), std::<span class="built_in">end</span>(words), std::<span class="built_in">back_inserter</span> (new_words), string&#123;<span class="string">&quot;none&quot;</span>&#125;, string&#123;<span class="string">&quot;0&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// Result:&quot;one&quot;, &quot;0&quot;, &quot;two&quot;,&quot;three&quot;,&quot;0&quot;,&quot;four&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这段代码后，new_words 会包含注释中的 string 元素。</p><h2 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if()"></a>replace_copy_if()</h2><p>可以在序列中有选择地替换元素的最后一个算法是 replace_copy_if()，它和 replace_if() 算法是相同的，但它的结果会被保存到另一个序列中。它的前两个参数是输入序列的迭代器，第 3 个参数是输出序列的开始迭代器，最后两个参数分别是谓词和替换值。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="type">int</span>&gt; data &#123;<span class="number">10</span>, <span class="number">-5</span>, <span class="number">12</span>, <span class="number">-6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">-7</span>, <span class="number">10</span>，<span class="number">11</span>&#125;; std::vector&lt;<span class="type">int</span>&gt; data_copy;</span><br><span class="line">std::<span class="built_in">replace_copy_if</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data),std::<span class="built_in">back_inserter</span>(data_copy),[](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value == <span class="number">10</span>;&#125;, <span class="number">99</span>);</span><br><span class="line"><span class="comment">// Result:99 -5 12 -6 99 8 -7 99 11</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
